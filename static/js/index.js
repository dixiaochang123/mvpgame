/*! For license information please see app.5f5e3f4be2722e1cc610.js.LICENSE.txt */
/*

*/
!function (t) {
  function e(e) {
    for (var n, r, o = e[0], s = e[1], a = 0, c = []; a < o.length; a++) r = o[a], Object.prototype.hasOwnProperty.call(i, r) && i[r] && c.push(i[r][0]), i[r] = 0;
    for (n in s) Object.prototype.hasOwnProperty.call(s, n) && (t[n] = s[n]);
    for (l && l(e); c.length;) c.shift()()
  }

  var n = {}, r = {6: 0}, i = {6: 0};

  function o(e) {
    if (n[e]) return n[e].exports;
    var r = n[e] = {i: e, l: !1, exports: {}};
    return t[e].call(r.exports, r, r.exports, o), r.l = !0, r.exports
  }

  o.e = function (t) {
    var e = [];
    r[t] ? e.push(r[t]) : 0 !== r[t] && {0: 1}[t] && e.push(r[t] = new Promise((function (e, n) {
      for (var i = "assets/css/" + ({}[t] || t) + ".f5bf71b3016f4bf93035.css", s = o.p + i, a = document.getElementsByTagName("link"), c = 0; c < a.length; c++) {
        var l = (h = a[c]).getAttribute("data-href") || h.getAttribute("href");
        if ("stylesheet" === h.rel && (l === i || l === s)) return e()
      }
      var u = document.getElementsByTagName("style");
      for (c = 0; c < u.length; c++) {
        var h;
        if ((l = (h = u[c]).getAttribute("data-href")) === i || l === s) return e()
      }
      var f = document.createElement("link");
      f.rel = "stylesheet", f.type = "text/css", f.onload = e, f.onerror = function (e) {
        var i = e && e.target && e.target.src || s, o = new Error("Loading CSS chunk " + t + " failed.\n(" + i + ")");
        o.code = "CSS_CHUNK_LOAD_FAILED", o.request = i, delete r[t], f.parentNode.removeChild(f), n(o)
      }, f.href = s, document.getElementsByTagName("head")[0].appendChild(f)
    })).then((function () {
      r[t] = 0
    })));
    var n = i[t];
    if (0 !== n) if (n) e.push(n[2]); else {
      var s = new Promise((function (e, r) {
        n = i[t] = [e, r]
      }));
      e.push(n[2] = s);
      var a, c = document.createElement("script");
      c.charset = "utf-8", c.timeout = 120, o.nc && c.setAttribute("nonce", o.nc), c.src = function (t) {
        return ''
        // o.p + "assets/js/" + ({}[t] || t) + "." + {
        //   0: "441edab4fe7e2eba3d0e",
        //   1: "f9ffc32dab3cc192f11e",
        //   2: "39400ee5ca651cd4671b",
        //   3: "7d47b540b7333db6ce98",
        //   4: "dc5f710a5db3d6aed928",
        //   5: "b0c3daae24773d194866",
        //   7: "aac2ccabcc01ff87b537",
        //   8: "408b0b85b4a5bbbf44af",
        //   9: "e4c4d2ba5bf08eb3d83d",
        //   10: "c3cafe98bc076a0fef3b"
        // }[t] + ".js"
      }(t);
      var l = new Error;
      a = function (e) {
        c.onerror = c.onload = null, clearTimeout(u);
        var n = i[t];
        // if (0 !== n) {
        //   if (n) {
        //     var r = e && ("load" === e.type ? "missing" : e.type), o = e && e.target && e.target.src;
        //     l.message = "Loading chunk " + t + " failed.\n(" + r + ": " + o + ")", l.name = "ChunkLoadError", l.type = r, l.request = o, n[1](l)
        //   }
        //   i[t] = void 0
        // }
      };
      var u = setTimeout((function () {
        a({type: "timeout", target: c})
      }), 12e4);
      c.onerror = c.onload = a, document.head.appendChild(c)
    }
    return Promise.all(e)
  }, o.m = t, o.c = n, o.d = function (t, e, n) {
    o.o(t, e) || Object.defineProperty(t, e, {enumerable: !0, get: n})
  }, o.r = function (t) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(t, "__esModule", {value: !0})
  }, o.t = function (t, e) {
    if (1 & e && (t = o(t)), 8 & e) return t;
    if (4 & e && "object" == typeof t && t && t.__esModule) return t;
    var n = Object.create(null);
    if (o.r(n), Object.defineProperty(n, "default", {
      enumerable: !0,
      value: t
    }), 2 & e && "string" != typeof t) for (var r in t) o.d(n, r, function (e) {
      return t[e]
    }.bind(null, r));
    return n
  }, o.n = function (t) {
    var e = t && t.__esModule ? function () {
      return t.default
    } : function () {
      return t
    };
    return o.d(e, "a", e), e
  }, o.o = function (t, e) {
    return Object.prototype.hasOwnProperty.call(t, e)
  }, o.p = "/", o.oe = function (t) {
    throw console.error(t), t
  };
  var s = window.webpackJsonp = window.webpackJsonp || [], a = s.push.bind(s);
  s.push = e, s = s.slice();
  for (var c = 0; c < s.length; c++) e(s[c]);
  var l = a;
  o(o.s = 124)
}([function (t, e, n) {
  "use strict";
  var r = n(89),
    i = new (n.n(r).a)({prefix: "v-", page: document.querySelector(".app").getAttribute("data-v-page").split(" ")});
  e.a = i, i.load.add({
    do: function () {
      i.html.classList.remove("v-no-transition")
    }
  })
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return t instanceof HTMLElement || t instanceof Element
  }

  function i(t, e) {
    if (t instanceof Window) return t;
    if (r(t)) return t;
    if (void 0 !== e) {
      const n = i(e);
      if (n) return n.querySelector(t)
    }
    return document.querySelector(t)
  }

  function o(t, e) {
    if (t instanceof NodeList) return t;
    if (r(t)) return [t];
    if (Array.isArray(t)) return t;
    if (void 0 !== e) {
      const n = i(e);
      if (n) return n.querySelectorAll(t)
    }
    return document.querySelectorAll(t)
  }

  function s(t, e, n) {
    const r = e.split(" ");
    for (let i = 0; i < r.length; i++) void 0 === n ? t.classList.toggle(r[i]) : n ? t.classList.add(r[i]) : t.classList.remove(r[i])
  }

  function a(t, e = {}) {
    const n = document.createElement(t);
    if (e.class && function (t, e) {
      if (t instanceof Element) s(t, e, !0); else for (let n = 0; n < t.length; n++) s(t[n], e, !0)
    }(n, e.class), e.id && n.setAttribute("id", e.id), e.attr) for (let r = 0, i = e.attr.length; r < i; r++) {
      const t = e.attr[r];
      n.setAttribute(t[0], t[1])
    }
    if (e.parent && e.parent.appendChild(n), e.html && (n.innerHTML = e.html), e.children) for (let r = 0, i = e.children.length; r < i; r++) n.appendChild(e.children[r]);
    return n
  }

  n.d(e, "c", (function () {
    return r
  })), n.d(e, "g", (function () {
    return i
  })), n.d(e, "f", (function () {
    return o
  })), n.d(e, "b", (function () {
    return a
  })), n.d(e, "a", (function () {
    return l
  })), n.d(e, "e", (function () {
    return h
  })), n.d(e, "d", (function () {
    return f
  }));
  const c = [];

  function l(t, e, n, r) {
    if (void 0 !== r) {
      const i = {passive: !1, once: !1};
      r.once && (i.once = !0), r.passive && (i.passive = !0), t.addEventListener(e, n, i)
    } else t.addEventListener(e, n);
    const i = `${Math.random()}-${+new Date}`;
    return c.push({id: i, el: t, target: e, callback: n}), {id: i, remove: u.bind(this, i)}
  }

  function u(t) {
    const e = [];
    for (let n = 0, r = c.length; n < r; n++) {
      const r = c[n];
      r.id === t ? r.el.removeEventListener(r.target, r.callback) : e.push(r)
    }
  }

  function h(t, e, n = 1 / 0, r = 0) {
    return !(r >= n) && (r++, t.parentElement instanceof Element && (t.parentElement.tagName.toLowerCase() === e.toLowerCase() ? t.parentElement : h(t.parentElement, e, n, r)))
  }

  function f(t, e, n = 1 / 0, r = 0) {
    return !(r >= n) && (r++, t.parentElement instanceof Element && (t.parentElement.classList.contains(e) ? t.parentElement : f(t.parentElement, e, n, r)))
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return a
  })), n.d(e, "b", (function () {
    return ec
  })), n.d(e, "c", (function () {
    return o
  })), n.d(e, "d", (function () {
    return bt
  })), n.d(e, "e", (function () {
    return sn
  })), n.d(e, "f", (function () {
    return rs
  })), n.d(e, "g", (function () {
    return m
  })), n.d(e, "h", (function () {
    return pc
  })), n.d(e, "i", (function () {
    return Ge
  })), n.d(e, "j", (function () {
    return d
  })), n.d(e, "k", (function () {
    return zn
  })), n.d(e, "l", (function () {
    return ma
  })), n.d(e, "m", (function () {
    return Uc
  })), n.d(e, "n", (function () {
    return s
  })), n.d(e, "o", (function () {
    return Y
  })), n.d(e, "p", (function () {
    return fa
  })), n.d(e, "q", (function () {
    return Je
  })), n.d(e, "r", (function () {
    return E
  })), n.d(e, "s", (function () {
    return Ji
  })), n.d(e, "t", (function () {
    return T
  })), n.d(e, "u", (function () {
    return oe
  })), n.d(e, "v", (function () {
    return Go
  })), n.d(e, "w", (function () {
    return zo
  })), n.d(e, "x", (function () {
    return Xo
  })), n.d(e, "y", (function () {
    return B
  })), n.d(e, "z", (function () {
    return b
  })), n.d(e, "A", (function () {
    return ua
  })), n.d(e, "B", (function () {
    return ca
  })), n.d(e, "C", (function () {
    return r
  })), n.d(e, "D", (function () {
    return Ne
  })), n.d(e, "E", (function () {
    return st
  })), n.d(e, "F", (function () {
    return Yt
  })), n.d(e, "G", (function () {
    return Mn
  })), n.d(e, "H", (function () {
    return Ve
  })), n.d(e, "I", (function () {
    return Bs
  })), n.d(e, "J", (function () {
    return Is
  })), n.d(e, "K", (function () {
    return js
  })), n.d(e, "L", (function () {
    return g
  })), n.d(e, "M", (function () {
    return Qa
  })), n.d(e, "N", (function () {
    return sl
  })), n.d(e, "O", (function () {
    return Ln
  })), n.d(e, "P", (function () {
    return Se
  })), n.d(e, "Q", (function () {
    return Gn
  })), n.d(e, "R", (function () {
    return $o
  })), n.d(e, "S", (function () {
    return Yo
  })), n.d(e, "T", (function () {
    return vt
  })), n.d(e, "U", (function () {
    return A
  })), n.d(e, "V", (function () {
    return G
  })), n.d(e, "W", (function () {
    return P
  })), n.d(e, "X", (function () {
    return H
  })), n.d(e, "Y", (function () {
    return nc
  })), n.d(e, "Z", (function () {
    return io
  })), n.d(e, "ab", (function () {
    return Pn
  })), n.d(e, "bb", (function () {
    return It
  })), n.d(e, "cb", (function () {
    return Ds
  })), n.d(e, "db", (function () {
    return Rc
  })), n.d(e, "eb", (function () {
    return Xa
  })), n.d(e, "fb", (function () {
    return Dc
  })), n.d(e, "gb", (function () {
    return i
  })), n.d(e, "hb", (function () {
    return ft
  })), n.d(e, "ib", (function () {
    return l
  })), n.d(e, "jb", (function () {
    return Wn
  })), n.d(e, "kb", (function () {
    return An
  })), n.d(e, "lb", (function () {
    return w
  })), n.d(e, "mb", (function () {
    return at
  })), n.d(e, "nb", (function () {
    return gt
  })), n.d(e, "ob", (function () {
    return pt
  })), n.d(e, "pb", (function () {
    return es
  })), n.d(e, "qb", (function () {
    return mt
  })), n.d(e, "rb", (function () {
    return eo
  }));
  const r = {LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2},
    i = {ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3}, o = 1, s = 2, a = 2, c = 100, l = 300, u = 301, h = 302,
    f = 306, d = 307, p = 1e3, m = 1001, v = 1002, g = 1003, y = 1004, _ = 1005, b = 1006, x = 1008, w = 1009, S = 1012,
    M = 1014, E = 1015, T = 1016, O = 1020, H = 1022, A = 1023, P = A, R = 1026, L = 1027, C = 2300, k = 2301, D = 2302,
    N = 2400, z = 2401, j = 2402, I = 2500, B = 3e3, F = 3001, U = 3007, G = 3002, V = 7680, W = 35044, X = 35048,
    q = "300 es";

  class Y {
    addEventListener(t, e) {
      void 0 === this._listeners && (this._listeners = {});
      const n = this._listeners;
      void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
    }

    hasEventListener(t, e) {
      if (void 0 === this._listeners) return !1;
      const n = this._listeners;
      return void 0 !== n[t] && -1 !== n[t].indexOf(e)
    }

    removeEventListener(t, e) {
      if (void 0 === this._listeners) return;
      const n = this._listeners[t];
      if (void 0 !== n) {
        const t = n.indexOf(e);
        -1 !== t && n.splice(t, 1)
      }
    }

    dispatchEvent(t) {
      if (void 0 === this._listeners) return;
      const e = this._listeners[t.type];
      if (void 0 !== e) {
        t.target = this;
        const n = e.slice(0);
        for (let e = 0, r = n.length; e < r; e++) n[e].call(this, t);
        t.target = null
      }
    }
  }

  const Z = [];
  for (let ml = 0; ml < 256; ml++) Z[ml] = (ml < 16 ? "0" : "") + ml.toString(16);
  let J = 1234567;
  const K = Math.PI / 180, Q = 180 / Math.PI;

  function $() {
    const t = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0,
      r = 4294967295 * Math.random() | 0;
    return (Z[255 & t] + Z[t >> 8 & 255] + Z[t >> 16 & 255] + Z[t >> 24 & 255] + "-" + Z[255 & e] + Z[e >> 8 & 255] + "-" + Z[e >> 16 & 15 | 64] + Z[e >> 24 & 255] + "-" + Z[63 & n | 128] + Z[n >> 8 & 255] + "-" + Z[n >> 16 & 255] + Z[n >> 24 & 255] + Z[255 & r] + Z[r >> 8 & 255] + Z[r >> 16 & 255] + Z[r >> 24 & 255]).toUpperCase()
  }

  function tt(t, e, n) {
    return Math.max(e, Math.min(n, t))
  }

  function et(t, e) {
    return (t % e + e) % e
  }

  function nt(t, e, n) {
    return (1 - n) * t + n * e
  }

  function rt(t) {
    return 0 == (t & t - 1) && 0 !== t
  }

  function it(t) {
    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
  }

  function ot(t) {
    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
  }

  var st = Object.freeze({
    __proto__: null,
    DEG2RAD: K,
    RAD2DEG: Q,
    generateUUID: $,
    clamp: tt,
    euclideanModulo: et,
    mapLinear: function (t, e, n, r, i) {
      return r + (t - e) * (i - r) / (n - e)
    },
    inverseLerp: function (t, e, n) {
      return t !== e ? (n - t) / (e - t) : 0
    },
    lerp: nt,
    damp: function (t, e, n, r) {
      return nt(t, e, 1 - Math.exp(-n * r))
    },
    pingpong: function (t, e = 1) {
      return e - Math.abs(et(t, 2 * e) - e)
    },
    smoothstep: function (t, e, n) {
      return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
    },
    smootherstep: function (t, e, n) {
      return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
    },
    randInt: function (t, e) {
      return t + Math.floor(Math.random() * (e - t + 1))
    },
    randFloat: function (t, e) {
      return t + Math.random() * (e - t)
    },
    randFloatSpread: function (t) {
      return t * (.5 - Math.random())
    },
    seededRandom: function (t) {
      return void 0 !== t && (J = t % 2147483647), J = 16807 * J % 2147483647, (J - 1) / 2147483646
    },
    degToRad: function (t) {
      return t * K
    },
    radToDeg: function (t) {
      return t * Q
    },
    isPowerOfTwo: rt,
    ceilPowerOfTwo: it,
    floorPowerOfTwo: ot,
    setQuaternionFromProperEuler: function (t, e, n, r, i) {
      const o = Math.cos, s = Math.sin, a = o(n / 2), c = s(n / 2), l = o((e + r) / 2), u = s((e + r) / 2),
        h = o((e - r) / 2), f = s((e - r) / 2), d = o((r - e) / 2), p = s((r - e) / 2);
      switch (i) {
        case"XYX":
          t.set(a * u, c * h, c * f, a * l);
          break;
        case"YZY":
          t.set(c * f, a * u, c * h, a * l);
          break;
        case"ZXZ":
          t.set(c * h, c * f, a * u, a * l);
          break;
        case"XZX":
          t.set(a * u, c * p, c * d, a * l);
          break;
        case"YXY":
          t.set(c * d, a * u, c * p, a * l);
          break;
        case"ZYZ":
          t.set(c * p, c * d, a * u, a * l);
          break;
        default:
          console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
      }
    }
  });

  class at {
    constructor(t = 0, e = 0) {
      this.x = t, this.y = e
    }

    get width() {
      return this.x
    }

    set width(t) {
      this.x = t
    }

    get height() {
      return this.y
    }

    set height(t) {
      this.y = t
    }

    set(t, e) {
      return this.x = t, this.y = e, this
    }

    setScalar(t) {
      return this.x = t, this.y = t, this
    }

    setX(t) {
      return this.x = t, this
    }

    setY(t) {
      return this.y = t, this
    }

    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        default:
          throw new Error("index is out of range: " + t)
      }
      return this
    }

    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + t)
      }
    }

    clone() {
      return new this.constructor(this.x, this.y)
    }

    copy(t) {
      return this.x = t.x, this.y = t.y, this
    }

    add(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
    }

    addScalar(t) {
      return this.x += t, this.y += t, this
    }

    addVectors(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this
    }

    addScaledVector(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this
    }

    sub(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
    }

    subScalar(t) {
      return this.x -= t, this.y -= t, this
    }

    subVectors(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this
    }

    multiply(t) {
      return this.x *= t.x, this.y *= t.y, this
    }

    multiplyScalar(t) {
      return this.x *= t, this.y *= t, this
    }

    divide(t) {
      return this.x /= t.x, this.y /= t.y, this
    }

    divideScalar(t) {
      return this.multiplyScalar(1 / t)
    }

    applyMatrix3(t) {
      const e = this.x, n = this.y, r = t.elements;
      return this.x = r[0] * e + r[3] * n + r[6], this.y = r[1] * e + r[4] * n + r[7], this
    }

    min(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
    }

    max(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
    }

    clamp(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
    }

    clampScalar(t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
    }

    clampLength(t, e) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
    }

    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
    }

    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
    }

    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this
    }

    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
    }

    negate() {
      return this.x = -this.x, this.y = -this.y, this
    }

    dot(t) {
      return this.x * t.x + this.y * t.y
    }

    cross(t) {
      return this.x * t.y - this.y * t.x
    }

    lengthSq() {
      return this.x * this.x + this.y * this.y
    }

    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y)
    }

    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y)
    }

    normalize() {
      return this.divideScalar(this.length() || 1)
    }

    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI
    }

    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t))
    }

    distanceToSquared(t) {
      const e = this.x - t.x, n = this.y - t.y;
      return e * e + n * n
    }

    manhattanDistanceTo(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
    }

    setLength(t) {
      return this.normalize().multiplyScalar(t)
    }

    lerp(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
    }

    lerpVectors(t, e, n) {
      return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
    }

    equals(t) {
      return t.x === this.x && t.y === this.y
    }

    fromArray(t, e = 0) {
      return this.x = t[e], this.y = t[e + 1], this
    }

    toArray(t = [], e = 0) {
      return t[e] = this.x, t[e + 1] = this.y, t
    }

    fromBufferAttribute(t, e, n) {
      return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
    }

    rotateAround(t, e) {
      const n = Math.cos(e), r = Math.sin(e), i = this.x - t.x, o = this.y - t.y;
      return this.x = i * n - o * r + t.x, this.y = i * r + o * n + t.y, this
    }

    random() {
      return this.x = Math.random(), this.y = Math.random(), this
    }
  }

  at.prototype.isVector2 = !0;

  class ct {
    constructor() {
      this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }

    set(t, e, n, r, i, o, s, a, c) {
      const l = this.elements;
      return l[0] = t, l[1] = r, l[2] = s, l[3] = e, l[4] = i, l[5] = a, l[6] = n, l[7] = o, l[8] = c, this
    }

    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
    }

    copy(t) {
      const e = this.elements, n = t.elements;
      return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
    }

    extractBasis(t, e, n) {
      return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
    }

    setFromMatrix4(t) {
      const e = t.elements;
      return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
    }

    multiply(t) {
      return this.multiplyMatrices(this, t)
    }

    premultiply(t) {
      return this.multiplyMatrices(t, this)
    }

    multiplyMatrices(t, e) {
      const n = t.elements, r = e.elements, i = this.elements, o = n[0], s = n[3], a = n[6], c = n[1], l = n[4],
        u = n[7], h = n[2], f = n[5], d = n[8], p = r[0], m = r[3], v = r[6], g = r[1], y = r[4], _ = r[7], b = r[2],
        x = r[5], w = r[8];
      return i[0] = o * p + s * g + a * b, i[3] = o * m + s * y + a * x, i[6] = o * v + s * _ + a * w, i[1] = c * p + l * g + u * b, i[4] = c * m + l * y + u * x, i[7] = c * v + l * _ + u * w, i[2] = h * p + f * g + d * b, i[5] = h * m + f * y + d * x, i[8] = h * v + f * _ + d * w, this
    }

    multiplyScalar(t) {
      const e = this.elements;
      return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
    }

    determinant() {
      const t = this.elements, e = t[0], n = t[1], r = t[2], i = t[3], o = t[4], s = t[5], a = t[6], c = t[7], l = t[8];
      return e * o * l - e * s * c - n * i * l + n * s * a + r * i * c - r * o * a
    }

    invert() {
      const t = this.elements, e = t[0], n = t[1], r = t[2], i = t[3], o = t[4], s = t[5], a = t[6], c = t[7], l = t[8],
        u = l * o - s * c, h = s * a - l * i, f = c * i - o * a, d = e * u + n * h + r * f;
      if (0 === d) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const p = 1 / d;
      return t[0] = u * p, t[1] = (r * c - l * n) * p, t[2] = (s * n - r * o) * p, t[3] = h * p, t[4] = (l * e - r * a) * p, t[5] = (r * i - s * e) * p, t[6] = f * p, t[7] = (n * a - c * e) * p, t[8] = (o * e - n * i) * p, this
    }

    transpose() {
      let t;
      const e = this.elements;
      return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
    }

    getNormalMatrix(t) {
      return this.setFromMatrix4(t).invert().transpose()
    }

    transposeIntoArray(t) {
      const e = this.elements;
      return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
    }

    setUvTransform(t, e, n, r, i, o, s) {
      const a = Math.cos(i), c = Math.sin(i);
      return this.set(n * a, n * c, -n * (a * o + c * s) + o + t, -r * c, r * a, -r * (-c * o + a * s) + s + e, 0, 0, 1), this
    }

    scale(t, e) {
      const n = this.elements;
      return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
    }

    rotate(t) {
      const e = Math.cos(t), n = Math.sin(t), r = this.elements, i = r[0], o = r[3], s = r[6], a = r[1], c = r[4],
        l = r[7];
      return r[0] = e * i + n * a, r[3] = e * o + n * c, r[6] = e * s + n * l, r[1] = -n * i + e * a, r[4] = -n * o + e * c, r[7] = -n * s + e * l, this
    }

    translate(t, e) {
      const n = this.elements;
      return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
    }

    equals(t) {
      const e = this.elements, n = t.elements;
      for (let r = 0; r < 9; r++) if (e[r] !== n[r]) return !1;
      return !0
    }

    fromArray(t, e = 0) {
      for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
      return this
    }

    toArray(t = [], e = 0) {
      const n = this.elements;
      return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
    }

    clone() {
      return (new this.constructor).fromArray(this.elements)
    }
  }

  let lt;
  ct.prototype.isMatrix3 = !0;

  class ut {
    static getDataURL(t) {
      if (/^data:/i.test(t.src)) return t.src;
      if ("undefined" == typeof HTMLCanvasElement) return t.src;
      let e;
      if (t instanceof HTMLCanvasElement) e = t; else {
        void 0 === lt && (lt = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), lt.width = t.width, lt.height = t.height;
        const n = lt.getContext("2d");
        t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = lt
      }
      return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
    }
  }

  let ht = 0;

  class ft extends Y {
    constructor(t = ft.DEFAULT_IMAGE, e = ft.DEFAULT_MAPPING, n = m, r = m, i = b, o = 1008, s = A, a = w, c = 1, l = B) {
      super(), Object.defineProperty(this, "id", {value: ht++}), this.uuid = $(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = o, this.anisotropy = c, this.format = s, this.internalFormat = null, this.type = a, this.offset = new at(0, 0), this.repeat = new at(1, 1), this.center = new at(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ct, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = l, this.version = 0, this.onUpdate = null
    }

    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }

    clone() {
      return (new this.constructor).copy(this)
    }

    copy(t) {
      return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
    }

    toJSON(t) {
      const e = void 0 === t || "string" == typeof t;
      if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
      const n = {
        metadata: {version: 4.5, type: "Texture", generator: "Texture.toJSON"},
        uuid: this.uuid,
        name: this.name,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      if (void 0 !== this.image) {
        const r = this.image;
        if (void 0 === r.uuid && (r.uuid = $()), !e && void 0 === t.images[r.uuid]) {
          let e;
          if (Array.isArray(r)) {
            e = [];
            for (let t = 0, n = r.length; t < n; t++) r[t].isDataTexture ? e.push(dt(r[t].image)) : e.push(dt(r[t]))
          } else e = dt(r);
          t.images[r.uuid] = {uuid: r.uuid, url: e}
        }
        n.image = r.uuid
      }
      return e || (t.textures[this.uuid] = n), n
    }

    dispose() {
      this.dispatchEvent({type: "dispose"})
    }

    transformUv(t) {
      if (this.mapping !== l) return t;
      if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
        case p:
          t.x = t.x - Math.floor(t.x);
          break;
        case m:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case v:
          1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
      }
      if (t.y < 0 || t.y > 1) switch (this.wrapT) {
        case p:
          t.y = t.y - Math.floor(t.y);
          break;
        case m:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case v:
          1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
      }
      return this.flipY && (t.y = 1 - t.y), t
    }

    set needsUpdate(t) {
      !0 === t && this.version++
    }
  }

  function dt(t) {
    return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? ut.getDataURL(t) : t.data ? {
      data: Array.prototype.slice.call(t.data),
      width: t.width,
      height: t.height,
      type: t.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
  }

  ft.DEFAULT_IMAGE = void 0, ft.DEFAULT_MAPPING = l, ft.prototype.isTexture = !0;

  class pt {
    constructor(t = 0, e = 0, n = 0, r = 1) {
      this.x = t, this.y = e, this.z = n, this.w = r
    }

    get width() {
      return this.z
    }

    set width(t) {
      this.z = t
    }

    get height() {
      return this.w
    }

    set height(t) {
      this.w = t
    }

    set(t, e, n, r) {
      return this.x = t, this.y = e, this.z = n, this.w = r, this
    }

    setScalar(t) {
      return this.x = t, this.y = t, this.z = t, this.w = t, this
    }

    setX(t) {
      return this.x = t, this
    }

    setY(t) {
      return this.y = t, this
    }

    setZ(t) {
      return this.z = t, this
    }

    setW(t) {
      return this.w = t, this
    }

    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        case 3:
          this.w = e;
          break;
        default:
          throw new Error("index is out of range: " + t)
      }
      return this
    }

    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + t)
      }
    }

    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w)
    }

    copy(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
    }

    add(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
    }

    addScalar(t) {
      return this.x += t, this.y += t, this.z += t, this.w += t, this
    }

    addVectors(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
    }

    addScaledVector(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
    }

    sub(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
    }

    subScalar(t) {
      return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
    }

    subVectors(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
    }

    multiply(t) {
      return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
    }

    multiplyScalar(t) {
      return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
    }

    applyMatrix4(t) {
      const e = this.x, n = this.y, r = this.z, i = this.w, o = t.elements;
      return this.x = o[0] * e + o[4] * n + o[8] * r + o[12] * i, this.y = o[1] * e + o[5] * n + o[9] * r + o[13] * i, this.z = o[2] * e + o[6] * n + o[10] * r + o[14] * i, this.w = o[3] * e + o[7] * n + o[11] * r + o[15] * i, this
    }

    divideScalar(t) {
      return this.multiplyScalar(1 / t)
    }

    setAxisAngleFromQuaternion(t) {
      this.w = 2 * Math.acos(t.w);
      const e = Math.sqrt(1 - t.w * t.w);
      return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
    }

    setAxisAngleFromRotationMatrix(t) {
      let e, n, r, i;
      const o = .01, s = .1, a = t.elements, c = a[0], l = a[4], u = a[8], h = a[1], f = a[5], d = a[9], p = a[2],
        m = a[6], v = a[10];
      if (Math.abs(l - h) < o && Math.abs(u - p) < o && Math.abs(d - m) < o) {
        if (Math.abs(l + h) < s && Math.abs(u + p) < s && Math.abs(d + m) < s && Math.abs(c + f + v - 3) < s) return this.set(1, 0, 0, 0), this;
        e = Math.PI;
        const t = (c + 1) / 2, a = (f + 1) / 2, g = (v + 1) / 2, y = (l + h) / 4, _ = (u + p) / 4, b = (d + m) / 4;
        return t > a && t > g ? t < o ? (n = 0, r = .707106781, i = .707106781) : (n = Math.sqrt(t), r = y / n, i = _ / n) : a > g ? a < o ? (n = .707106781, r = 0, i = .707106781) : (r = Math.sqrt(a), n = y / r, i = b / r) : g < o ? (n = .707106781, r = .707106781, i = 0) : (i = Math.sqrt(g), n = _ / i, r = b / i), this.set(n, r, i, e), this
      }
      let g = Math.sqrt((m - d) * (m - d) + (u - p) * (u - p) + (h - l) * (h - l));
      return Math.abs(g) < .001 && (g = 1), this.x = (m - d) / g, this.y = (u - p) / g, this.z = (h - l) / g, this.w = Math.acos((c + f + v - 1) / 2), this
    }

    min(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
    }

    max(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
    }

    clamp(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
    }

    clampScalar(t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
    }

    clampLength(t, e) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
    }

    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
    }

    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
    }

    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
    }

    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
    }

    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
    }

    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
    }

    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }

    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }

    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }

    normalize() {
      return this.divideScalar(this.length() || 1)
    }

    setLength(t) {
      return this.normalize().multiplyScalar(t)
    }

    lerp(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
    }

    lerpVectors(t, e, n) {
      return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
    }

    equals(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
    }

    fromArray(t, e = 0) {
      return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
    }

    toArray(t = [], e = 0) {
      return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
    }

    fromBufferAttribute(t, e, n) {
      return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
    }

    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
    }
  }

  pt.prototype.isVector4 = !0;

  class mt extends Y {
    constructor(t, e, n) {
      super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new pt(0, 0, t, e), this.scissorTest = !1, this.viewport = new pt(0, 0, t, e), n = n || {}, this.texture = new ft(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = 1, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : b, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
    }

    setTexture(t) {
      t.image = {width: this.width, height: this.height, depth: this.depth}, this.texture = t
    }

    setSize(t, e, n = 1) {
      this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
    }

    clone() {
      return (new this.constructor).copy(this)
    }

    copy(t) {
      return this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
    }

    dispose() {
      this.dispatchEvent({type: "dispose"})
    }
  }

  mt.prototype.isWebGLRenderTarget = !0;
  (class extends mt {
    constructor(t, e, n) {
      super(t, e, n), this.samples = 4
    }

    copy(t) {
      return super.copy.call(this, t), this.samples = t.samples, this
    }
  }).prototype.isWebGLMultisampleRenderTarget = !0;

  class vt {
    constructor(t = 0, e = 0, n = 0, r = 1) {
      this._x = t, this._y = e, this._z = n, this._w = r
    }

    static slerp(t, e, n, r) {
      return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, r)
    }

    static slerpFlat(t, e, n, r, i, o, s) {
      let a = n[r + 0], c = n[r + 1], l = n[r + 2], u = n[r + 3];
      const h = i[o + 0], f = i[o + 1], d = i[o + 2], p = i[o + 3];
      if (0 === s) return t[e + 0] = a, t[e + 1] = c, t[e + 2] = l, void(t[e + 3] = u);
      if (1 === s) return t[e + 0] = h, t[e + 1] = f, t[e + 2] = d, void(t[e + 3] = p);
      if (u !== p || a !== h || c !== f || l !== d) {
        let t = 1 - s;
        const e = a * h + c * f + l * d + u * p, n = e >= 0 ? 1 : -1, r = 1 - e * e;
        if (r > Number.EPSILON) {
          const i = Math.sqrt(r), o = Math.atan2(i, e * n);
          t = Math.sin(t * o) / i, s = Math.sin(s * o) / i
        }
        const i = s * n;
        if (a = a * t + h * i, c = c * t + f * i, l = l * t + d * i, u = u * t + p * i, t === 1 - s) {
          const t = 1 / Math.sqrt(a * a + c * c + l * l + u * u);
          a *= t, c *= t, l *= t, u *= t
        }
      }
      t[e] = a, t[e + 1] = c, t[e + 2] = l, t[e + 3] = u
    }

    static multiplyQuaternionsFlat(t, e, n, r, i, o) {
      const s = n[r], a = n[r + 1], c = n[r + 2], l = n[r + 3], u = i[o], h = i[o + 1], f = i[o + 2], d = i[o + 3];
      return t[e] = s * d + l * u + a * f - c * h, t[e + 1] = a * d + l * h + c * u - s * f, t[e + 2] = c * d + l * f + s * h - a * u, t[e + 3] = l * d - s * u - a * h - c * f, t
    }

    get x() {
      return this._x
    }

    set x(t) {
      this._x = t, this._onChangeCallback()
    }

    get y() {
      return this._y
    }

    set y(t) {
      this._y = t, this._onChangeCallback()
    }

    get z() {
      return this._z
    }

    set z(t) {
      this._z = t, this._onChangeCallback()
    }

    get w() {
      return this._w
    }

    set w(t) {
      this._w = t, this._onChangeCallback()
    }

    set(t, e, n, r) {
      return this._x = t, this._y = e, this._z = n, this._w = r, this._onChangeCallback(), this
    }

    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w)
    }

    copy(t) {
      return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
    }

    setFromEuler(t, e) {
      if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
      const n = t._x, r = t._y, i = t._z, o = t._order, s = Math.cos, a = Math.sin, c = s(n / 2), l = s(r / 2),
        u = s(i / 2), h = a(n / 2), f = a(r / 2), d = a(i / 2);
      switch (o) {
        case"XYZ":
          this._x = h * l * u + c * f * d, this._y = c * f * u - h * l * d, this._z = c * l * d + h * f * u, this._w = c * l * u - h * f * d;
          break;
        case"YXZ":
          this._x = h * l * u + c * f * d, this._y = c * f * u - h * l * d, this._z = c * l * d - h * f * u, this._w = c * l * u + h * f * d;
          break;
        case"ZXY":
          this._x = h * l * u - c * f * d, this._y = c * f * u + h * l * d, this._z = c * l * d + h * f * u, this._w = c * l * u - h * f * d;
          break;
        case"ZYX":
          this._x = h * l * u - c * f * d, this._y = c * f * u + h * l * d, this._z = c * l * d - h * f * u, this._w = c * l * u + h * f * d;
          break;
        case"YZX":
          this._x = h * l * u + c * f * d, this._y = c * f * u + h * l * d, this._z = c * l * d - h * f * u, this._w = c * l * u - h * f * d;
          break;
        case"XZY":
          this._x = h * l * u - c * f * d, this._y = c * f * u - h * l * d, this._z = c * l * d + h * f * u, this._w = c * l * u + h * f * d;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
      }
      return !1 !== e && this._onChangeCallback(), this
    }

    setFromAxisAngle(t, e) {
      const n = e / 2, r = Math.sin(n);
      return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
    }

    setFromRotationMatrix(t) {
      const e = t.elements, n = e[0], r = e[4], i = e[8], o = e[1], s = e[5], a = e[9], c = e[2], l = e[6], u = e[10],
        h = n + s + u;
      if (h > 0) {
        const t = .5 / Math.sqrt(h + 1);
        this._w = .25 / t, this._x = (l - a) * t, this._y = (i - c) * t, this._z = (o - r) * t
      } else if (n > s && n > u) {
        const t = 2 * Math.sqrt(1 + n - s - u);
        this._w = (l - a) / t, this._x = .25 * t, this._y = (r + o) / t, this._z = (i + c) / t
      } else if (s > u) {
        const t = 2 * Math.sqrt(1 + s - n - u);
        this._w = (i - c) / t, this._x = (r + o) / t, this._y = .25 * t, this._z = (a + l) / t
      } else {
        const t = 2 * Math.sqrt(1 + u - n - s);
        this._w = (o - r) / t, this._x = (i + c) / t, this._y = (a + l) / t, this._z = .25 * t
      }
      return this._onChangeCallback(), this
    }

    setFromUnitVectors(t, e) {
      let n = t.dot(e) + 1;
      return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
    }

    angleTo(t) {
      return 2 * Math.acos(Math.abs(tt(this.dot(t), -1, 1)))
    }

    rotateTowards(t, e) {
      const n = this.angleTo(t);
      if (0 === n) return this;
      const r = Math.min(1, e / n);
      return this.slerp(t, r), this
    }

    identity() {
      return this.set(0, 0, 0, 1)
    }

    invert() {
      return this.conjugate()
    }

    conjugate() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
    }

    dot(t) {
      return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
    }

    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }

    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }

    normalize() {
      let t = this.length();
      return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
    }

    multiply(t, e) {
      return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
    }

    premultiply(t) {
      return this.multiplyQuaternions(t, this)
    }

    multiplyQuaternions(t, e) {
      const n = t._x, r = t._y, i = t._z, o = t._w, s = e._x, a = e._y, c = e._z, l = e._w;
      return this._x = n * l + o * s + r * c - i * a, this._y = r * l + o * a + i * s - n * c, this._z = i * l + o * c + n * a - r * s, this._w = o * l - n * s - r * a - i * c, this._onChangeCallback(), this
    }

    slerp(t, e) {
      if (0 === e) return this;
      if (1 === e) return this.copy(t);
      const n = this._x, r = this._y, i = this._z, o = this._w;
      let s = o * t._w + n * t._x + r * t._y + i * t._z;
      if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), s >= 1) return this._w = o, this._x = n, this._y = r, this._z = i, this;
      const a = 1 - s * s;
      if (a <= Number.EPSILON) {
        const t = 1 - e;
        return this._w = t * o + e * this._w, this._x = t * n + e * this._x, this._y = t * r + e * this._y, this._z = t * i + e * this._z, this.normalize(), this._onChangeCallback(), this
      }
      const c = Math.sqrt(a), l = Math.atan2(c, s), u = Math.sin((1 - e) * l) / c, h = Math.sin(e * l) / c;
      return this._w = o * u + this._w * h, this._x = n * u + this._x * h, this._y = r * u + this._y * h, this._z = i * u + this._z * h, this._onChangeCallback(), this
    }

    slerpQuaternions(t, e, n) {
      this.copy(t).slerp(e, n)
    }

    equals(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
    }

    fromArray(t, e = 0) {
      return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
    }

    toArray(t = [], e = 0) {
      return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
    }

    fromBufferAttribute(t, e) {
      return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
    }

    _onChange(t) {
      return this._onChangeCallback = t, this
    }

    _onChangeCallback() {
    }
  }

  vt.prototype.isQuaternion = !0;

  class gt {
    constructor(t = 0, e = 0, n = 0) {
      this.x = t, this.y = e, this.z = n
    }

    set(t, e, n) {
      return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
    }

    setScalar(t) {
      return this.x = t, this.y = t, this.z = t, this
    }

    setX(t) {
      return this.x = t, this
    }

    setY(t) {
      return this.y = t, this
    }

    setZ(t) {
      return this.z = t, this
    }

    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        default:
          throw new Error("index is out of range: " + t)
      }
      return this
    }

    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + t)
      }
    }

    clone() {
      return new this.constructor(this.x, this.y, this.z)
    }

    copy(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this
    }

    add(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
    }

    addScalar(t) {
      return this.x += t, this.y += t, this.z += t, this
    }

    addVectors(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
    }

    addScaledVector(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
    }

    sub(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
    }

    subScalar(t) {
      return this.x -= t, this.y -= t, this.z -= t, this
    }

    subVectors(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
    }

    multiply(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
    }

    multiplyScalar(t) {
      return this.x *= t, this.y *= t, this.z *= t, this
    }

    multiplyVectors(t, e) {
      return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
    }

    applyEuler(t) {
      return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(_t.setFromEuler(t))
    }

    applyAxisAngle(t, e) {
      return this.applyQuaternion(_t.setFromAxisAngle(t, e))
    }

    applyMatrix3(t) {
      const e = this.x, n = this.y, r = this.z, i = t.elements;
      return this.x = i[0] * e + i[3] * n + i[6] * r, this.y = i[1] * e + i[4] * n + i[7] * r, this.z = i[2] * e + i[5] * n + i[8] * r, this
    }

    applyNormalMatrix(t) {
      return this.applyMatrix3(t).normalize()
    }

    applyMatrix4(t) {
      const e = this.x, n = this.y, r = this.z, i = t.elements, o = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]);
      return this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * o, this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * o, this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * o, this
    }

    applyQuaternion(t) {
      const e = this.x, n = this.y, r = this.z, i = t.x, o = t.y, s = t.z, a = t.w, c = a * e + o * r - s * n,
        l = a * n + s * e - i * r, u = a * r + i * n - o * e, h = -i * e - o * n - s * r;
      return this.x = c * a + h * -i + l * -s - u * -o, this.y = l * a + h * -o + u * -i - c * -s, this.z = u * a + h * -s + c * -o - l * -i, this
    }

    project(t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
    }

    unproject(t) {
      return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
    }

    transformDirection(t) {
      const e = this.x, n = this.y, r = this.z, i = t.elements;
      return this.x = i[0] * e + i[4] * n + i[8] * r, this.y = i[1] * e + i[5] * n + i[9] * r, this.z = i[2] * e + i[6] * n + i[10] * r, this.normalize()
    }

    divide(t) {
      return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
    }

    divideScalar(t) {
      return this.multiplyScalar(1 / t)
    }

    min(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
    }

    max(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
    }

    clamp(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
    }

    clampScalar(t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
    }

    clampLength(t, e) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
    }

    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
    }

    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
    }

    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
    }

    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
    }

    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
    }

    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z
    }

    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z
    }

    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }

    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }

    normalize() {
      return this.divideScalar(this.length() || 1)
    }

    setLength(t) {
      return this.normalize().multiplyScalar(t)
    }

    lerp(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
    }

    lerpVectors(t, e, n) {
      return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
    }

    cross(t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
    }

    crossVectors(t, e) {
      const n = t.x, r = t.y, i = t.z, o = e.x, s = e.y, a = e.z;
      return this.x = r * a - i * s, this.y = i * o - n * a, this.z = n * s - r * o, this
    }

    projectOnVector(t) {
      const e = t.lengthSq();
      if (0 === e) return this.set(0, 0, 0);
      const n = t.dot(this) / e;
      return this.copy(t).multiplyScalar(n)
    }

    projectOnPlane(t) {
      return yt.copy(this).projectOnVector(t), this.sub(yt)
    }

    reflect(t) {
      return this.sub(yt.copy(t).multiplyScalar(2 * this.dot(t)))
    }

    angleTo(t) {
      const e = Math.sqrt(this.lengthSq() * t.lengthSq());
      if (0 === e) return Math.PI / 2;
      const n = this.dot(t) / e;
      return Math.acos(tt(n, -1, 1))
    }

    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t))
    }

    distanceToSquared(t) {
      const e = this.x - t.x, n = this.y - t.y, r = this.z - t.z;
      return e * e + n * n + r * r
    }

    manhattanDistanceTo(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
    }

    setFromSpherical(t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
    }

    setFromSphericalCoords(t, e, n) {
      const r = Math.sin(e) * t;
      return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this
    }

    setFromCylindrical(t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
    }

    setFromCylindricalCoords(t, e, n) {
      return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
    }

    setFromMatrixPosition(t) {
      const e = t.elements;
      return this.x = e[12], this.y = e[13], this.z = e[14], this
    }

    setFromMatrixScale(t) {
      const e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(),
        r = this.setFromMatrixColumn(t, 2).length();
      return this.x = e, this.y = n, this.z = r, this
    }

    setFromMatrixColumn(t, e) {
      return this.fromArray(t.elements, 4 * e)
    }

    setFromMatrix3Column(t, e) {
      return this.fromArray(t.elements, 3 * e)
    }

    equals(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z
    }

    fromArray(t, e = 0) {
      return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
    }

    toArray(t = [], e = 0) {
      return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
    }

    fromBufferAttribute(t, e, n) {
      return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
    }

    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
    }
  }

  gt.prototype.isVector3 = !0;
  const yt = new gt, _t = new vt;

  class bt {
    constructor(t = new gt(1 / 0, 1 / 0, 1 / 0), e = new gt(-1 / 0, -1 / 0, -1 / 0)) {
      this.min = t, this.max = e
    }

    set(t, e) {
      return this.min.copy(t), this.max.copy(e), this
    }

    setFromArray(t) {
      let e = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, s = -1 / 0;
      for (let a = 0, c = t.length; a < c; a += 3) {
        const c = t[a], l = t[a + 1], u = t[a + 2];
        c < e && (e = c), l < n && (n = l), u < r && (r = u), c > i && (i = c), l > o && (o = l), u > s && (s = u)
      }
      return this.min.set(e, n, r), this.max.set(i, o, s), this
    }

    setFromBufferAttribute(t) {
      let e = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, s = -1 / 0;
      for (let a = 0, c = t.count; a < c; a++) {
        const c = t.getX(a), l = t.getY(a), u = t.getZ(a);
        c < e && (e = c), l < n && (n = l), u < r && (r = u), c > i && (i = c), l > o && (o = l), u > s && (s = u)
      }
      return this.min.set(e, n, r), this.max.set(i, o, s), this
    }

    setFromPoints(t) {
      this.makeEmpty();
      for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
      return this
    }

    setFromCenterAndSize(t, e) {
      const n = wt.copy(e).multiplyScalar(.5);
      return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
    }

    setFromObject(t) {
      return this.makeEmpty(), this.expandByObject(t)
    }

    clone() {
      return (new this.constructor).copy(this)
    }

    copy(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this
    }

    makeEmpty() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
    }

    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }

    getCenter(t) {
      return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new gt), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
    }

    getSize(t) {
      return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new gt), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
    }

    expandByPoint(t) {
      return this.min.min(t), this.max.max(t), this
    }

    expandByVector(t) {
      return this.min.sub(t), this.max.add(t), this
    }

    expandByScalar(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this
    }

    expandByObject(t) {
      t.updateWorldMatrix(!1, !1);
      const e = t.geometry;
      void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), St.copy(e.boundingBox), St.applyMatrix4(t.matrixWorld), this.union(St));
      const n = t.children;
      for (let r = 0, i = n.length; r < i; r++) this.expandByObject(n[r]);
      return this
    }

    containsPoint(t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
    }

    containsBox(t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
    }

    getParameter(t, e) {
      return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new gt), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
    }

    intersectsBox(t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
    }

    intersectsSphere(t) {
      return this.clampPoint(t.center, wt), wt.distanceToSquared(t.center) <= t.radius * t.radius
    }

    intersectsPlane(t) {
      let e, n;
      return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
    }

    intersectsTriangle(t) {
      if (this.isEmpty()) return !1;
      this.getCenter(Pt), Rt.subVectors(this.max, Pt), Mt.subVectors(t.a, Pt), Et.subVectors(t.b, Pt), Tt.subVectors(t.c, Pt), Ot.subVectors(Et, Mt), Ht.subVectors(Tt, Et), At.subVectors(Mt, Tt);
      let e = [0, -Ot.z, Ot.y, 0, -Ht.z, Ht.y, 0, -At.z, At.y, Ot.z, 0, -Ot.x, Ht.z, 0, -Ht.x, At.z, 0, -At.x, -Ot.y, Ot.x, 0, -Ht.y, Ht.x, 0, -At.y, At.x, 0];
      return !!kt(e, Mt, Et, Tt, Rt) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!kt(e, Mt, Et, Tt, Rt) && (Lt.crossVectors(Ot, Ht), e = [Lt.x, Lt.y, Lt.z], kt(e, Mt, Et, Tt, Rt)))
    }

    clampPoint(t, e) {
      return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new gt), e.copy(t).clamp(this.min, this.max)
    }

    distanceToPoint(t) {
      return wt.copy(t).clamp(this.min, this.max).sub(t).length()
    }

    getBoundingSphere(t) {
      return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(wt).length(), t
    }

    intersect(t) {
      return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
    }

    union(t) {
      return this.min.min(t.min), this.max.max(t.max), this
    }

    applyMatrix4(t) {
      return this.isEmpty() || (xt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), xt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), xt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), xt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), xt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), xt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), xt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), xt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(xt)), this
    }

    translate(t) {
      return this.min.add(t), this.max.add(t), this
    }

    equals(t) {
      return t.min.equals(this.min) && t.max.equals(this.max)
    }
  }

  bt.prototype.isBox3 = !0;
  const xt = [new gt, new gt, new gt, new gt, new gt, new gt, new gt, new gt], wt = new gt, St = new bt, Mt = new gt,
    Et = new gt, Tt = new gt, Ot = new gt, Ht = new gt, At = new gt, Pt = new gt, Rt = new gt, Lt = new gt, Ct = new gt;

  function kt(t, e, n, r, i) {
    for (let o = 0, s = t.length - 3; o <= s; o += 3) {
      Ct.fromArray(t, o);
      const s = i.x * Math.abs(Ct.x) + i.y * Math.abs(Ct.y) + i.z * Math.abs(Ct.z), a = e.dot(Ct), c = n.dot(Ct),
        l = r.dot(Ct);
      if (Math.max(-Math.max(a, c, l), Math.min(a, c, l)) > s) return !1
    }
    return !0
  }

  const Dt = new bt, Nt = new gt, zt = new gt, jt = new gt;

  class It {
    constructor(t = new gt, e = -1) {
      this.center = t, this.radius = e
    }

    set(t, e) {
      return this.center.copy(t), this.radius = e, this
    }

    setFromPoints(t, e) {
      const n = this.center;
      void 0 !== e ? n.copy(e) : Dt.setFromPoints(t).getCenter(n);
      let r = 0;
      for (let i = 0, o = t.length; i < o; i++) r = Math.max(r, n.distanceToSquared(t[i]));
      return this.radius = Math.sqrt(r), this
    }

    copy(t) {
      return this.center.copy(t.center), this.radius = t.radius, this
    }

    isEmpty() {
      return this.radius < 0
    }

    makeEmpty() {
      return this.center.set(0, 0, 0), this.radius = -1, this
    }

    containsPoint(t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius
    }

    distanceToPoint(t) {
      return t.distanceTo(this.center) - this.radius
    }

    intersectsSphere(t) {
      const e = this.radius + t.radius;
      return t.center.distanceToSquared(this.center) <= e * e
    }

    intersectsBox(t) {
      return t.intersectsSphere(this)
    }

    intersectsPlane(t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius
    }

    clampPoint(t, e) {
      const n = this.center.distanceToSquared(t);
      return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new gt), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
    }

    getBoundingBox(t) {
      return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new bt), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
    }

    applyMatrix4(t) {
      return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
    }

    translate(t) {
      return this.center.add(t), this
    }

    expandByPoint(t) {
      jt.subVectors(t, this.center);
      const e = jt.lengthSq();
      if (e > this.radius * this.radius) {
        const t = Math.sqrt(e), n = .5 * (t - this.radius);
        this.center.add(jt.multiplyScalar(n / t)), this.radius += n
      }
      return this
    }

    union(t) {
      return zt.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(Nt.copy(t.center).add(zt)), this.expandByPoint(Nt.copy(t.center).sub(zt)), this
    }

    equals(t) {
      return t.center.equals(this.center) && t.radius === this.radius
    }

    clone() {
      return (new this.constructor).copy(this)
    }
  }

  const Bt = new gt, Ft = new gt, Ut = new gt, Gt = new gt, Vt = new gt, Wt = new gt, Xt = new gt;

  class qt {
    constructor(t = new gt, e = new gt(0, 0, -1)) {
      this.origin = t, this.direction = e
    }

    set(t, e) {
      return this.origin.copy(t), this.direction.copy(e), this
    }

    copy(t) {
      return this.origin.copy(t.origin), this.direction.copy(t.direction), this
    }

    at(t, e) {
      return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new gt), e.copy(this.direction).multiplyScalar(t).add(this.origin)
    }

    lookAt(t) {
      return this.direction.copy(t).sub(this.origin).normalize(), this
    }

    recast(t) {
      return this.origin.copy(this.at(t, Bt)), this
    }

    closestPointToPoint(t, e) {
      void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new gt), e.subVectors(t, this.origin);
      const n = e.dot(this.direction);
      return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
    }

    distanceToPoint(t) {
      return Math.sqrt(this.distanceSqToPoint(t))
    }

    distanceSqToPoint(t) {
      const e = Bt.subVectors(t, this.origin).dot(this.direction);
      return e < 0 ? this.origin.distanceToSquared(t) : (Bt.copy(this.direction).multiplyScalar(e).add(this.origin), Bt.distanceToSquared(t))
    }

    distanceSqToSegment(t, e, n, r) {
      Ft.copy(t).add(e).multiplyScalar(.5), Ut.copy(e).sub(t).normalize(), Gt.copy(this.origin).sub(Ft);
      const i = .5 * t.distanceTo(e), o = -this.direction.dot(Ut), s = Gt.dot(this.direction), a = -Gt.dot(Ut),
        c = Gt.lengthSq(), l = Math.abs(1 - o * o);
      let u, h, f, d;
      if (l > 0) if (u = o * a - s, h = o * s - a, d = i * l, u >= 0) if (h >= -d) if (h <= d) {
        const t = 1 / l;
        u *= t, h *= t, f = u * (u + o * h + 2 * s) + h * (o * u + h + 2 * a) + c
      } else h = i, u = Math.max(0, -(o * h + s)), f = -u * u + h * (h + 2 * a) + c; else h = -i, u = Math.max(0, -(o * h + s)), f = -u * u + h * (h + 2 * a) + c; else h <= -d ? (u = Math.max(0, -(-o * i + s)), h = u > 0 ? -i : Math.min(Math.max(-i, -a), i), f = -u * u + h * (h + 2 * a) + c) : h <= d ? (u = 0, h = Math.min(Math.max(-i, -a), i), f = h * (h + 2 * a) + c) : (u = Math.max(0, -(o * i + s)), h = u > 0 ? i : Math.min(Math.max(-i, -a), i), f = -u * u + h * (h + 2 * a) + c); else h = o > 0 ? -i : i, u = Math.max(0, -(o * h + s)), f = -u * u + h * (h + 2 * a) + c;
      return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), r && r.copy(Ut).multiplyScalar(h).add(Ft), f
    }

    intersectSphere(t, e) {
      Bt.subVectors(t.center, this.origin);
      const n = Bt.dot(this.direction), r = Bt.dot(Bt) - n * n, i = t.radius * t.radius;
      if (r > i) return null;
      const o = Math.sqrt(i - r), s = n - o, a = n + o;
      return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e)
    }

    intersectsSphere(t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius
    }

    distanceToPlane(t) {
      const e = t.normal.dot(this.direction);
      if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
      const n = -(this.origin.dot(t.normal) + t.constant) / e;
      return n >= 0 ? n : null
    }

    intersectPlane(t, e) {
      const n = this.distanceToPlane(t);
      return null === n ? null : this.at(n, e)
    }

    intersectsPlane(t) {
      const e = t.distanceToPoint(this.origin);
      if (0 === e) return !0;
      return t.normal.dot(this.direction) * e < 0
    }

    intersectBox(t, e) {
      let n, r, i, o, s, a;
      const c = 1 / this.direction.x, l = 1 / this.direction.y, u = 1 / this.direction.z, h = this.origin;
      return c >= 0 ? (n = (t.min.x - h.x) * c, r = (t.max.x - h.x) * c) : (n = (t.max.x - h.x) * c, r = (t.min.x - h.x) * c), l >= 0 ? (i = (t.min.y - h.y) * l, o = (t.max.y - h.y) * l) : (i = (t.max.y - h.y) * l, o = (t.min.y - h.y) * l), n > o || i > r ? null : ((i > n || n != n) && (n = i), (o < r || r != r) && (r = o), u >= 0 ? (s = (t.min.z - h.z) * u, a = (t.max.z - h.z) * u) : (s = (t.max.z - h.z) * u, a = (t.min.z - h.z) * u), n > a || s > r ? null : ((s > n || n != n) && (n = s), (a < r || r != r) && (r = a), r < 0 ? null : this.at(n >= 0 ? n : r, e)))
    }

    intersectsBox(t) {
      return null !== this.intersectBox(t, Bt)
    }

    intersectTriangle(t, e, n, r, i) {
      Vt.subVectors(e, t), Wt.subVectors(n, t), Xt.crossVectors(Vt, Wt);
      let o, s = this.direction.dot(Xt);
      if (s > 0) {
        if (r) return null;
        o = 1
      } else {
        if (!(s < 0)) return null;
        o = -1, s = -s
      }
      Gt.subVectors(this.origin, t);
      const a = o * this.direction.dot(Wt.crossVectors(Gt, Wt));
      if (a < 0) return null;
      const c = o * this.direction.dot(Vt.cross(Gt));
      if (c < 0) return null;
      if (a + c > s) return null;
      const l = -o * Gt.dot(Xt);
      return l < 0 ? null : this.at(l / s, i)
    }

    applyMatrix4(t) {
      return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
    }

    equals(t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction)
    }

    clone() {
      return (new this.constructor).copy(this)
    }
  }

  class Yt {
    constructor() {
      this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }

    set(t, e, n, r, i, o, s, a, c, l, u, h, f, d, p, m) {
      const v = this.elements;
      return v[0] = t, v[4] = e, v[8] = n, v[12] = r, v[1] = i, v[5] = o, v[9] = s, v[13] = a, v[2] = c, v[6] = l, v[10] = u, v[14] = h, v[3] = f, v[7] = d, v[11] = p, v[15] = m, this
    }

    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }

    clone() {
      return (new Yt).fromArray(this.elements)
    }

    copy(t) {
      const e = this.elements, n = t.elements;
      return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
    }

    copyPosition(t) {
      const e = this.elements, n = t.elements;
      return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
    }

    setFromMatrix3(t) {
      const e = t.elements;
      return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
    }

    extractBasis(t, e, n) {
      return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
    }

    makeBasis(t, e, n) {
      return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
    }

    extractRotation(t) {
      const e = this.elements, n = t.elements, r = 1 / Zt.setFromMatrixColumn(t, 0).length(),
        i = 1 / Zt.setFromMatrixColumn(t, 1).length(), o = 1 / Zt.setFromMatrixColumn(t, 2).length();
      return e[0] = n[0] * r, e[1] = n[1] * r, e[2] = n[2] * r, e[3] = 0, e[4] = n[4] * i, e[5] = n[5] * i, e[6] = n[6] * i, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
    }

    makeRotationFromEuler(t) {
      t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
      const e = this.elements, n = t.x, r = t.y, i = t.z, o = Math.cos(n), s = Math.sin(n), a = Math.cos(r),
        c = Math.sin(r), l = Math.cos(i), u = Math.sin(i);
      if ("XYZ" === t.order) {
        const t = o * l, n = o * u, r = s * l, i = s * u;
        e[0] = a * l, e[4] = -a * u, e[8] = c, e[1] = n + r * c, e[5] = t - i * c, e[9] = -s * a, e[2] = i - t * c, e[6] = r + n * c, e[10] = o * a
      } else if ("YXZ" === t.order) {
        const t = a * l, n = a * u, r = c * l, i = c * u;
        e[0] = t + i * s, e[4] = r * s - n, e[8] = o * c, e[1] = o * u, e[5] = o * l, e[9] = -s, e[2] = n * s - r, e[6] = i + t * s, e[10] = o * a
      } else if ("ZXY" === t.order) {
        const t = a * l, n = a * u, r = c * l, i = c * u;
        e[0] = t - i * s, e[4] = -o * u, e[8] = r + n * s, e[1] = n + r * s, e[5] = o * l, e[9] = i - t * s, e[2] = -o * c, e[6] = s, e[10] = o * a
      } else if ("ZYX" === t.order) {
        const t = o * l, n = o * u, r = s * l, i = s * u;
        e[0] = a * l, e[4] = r * c - n, e[8] = t * c + i, e[1] = a * u, e[5] = i * c + t, e[9] = n * c - r, e[2] = -c, e[6] = s * a, e[10] = o * a
      } else if ("YZX" === t.order) {
        const t = o * a, n = o * c, r = s * a, i = s * c;
        e[0] = a * l, e[4] = i - t * u, e[8] = r * u + n, e[1] = u, e[5] = o * l, e[9] = -s * l, e[2] = -c * l, e[6] = n * u + r, e[10] = t - i * u
      } else if ("XZY" === t.order) {
        const t = o * a, n = o * c, r = s * a, i = s * c;
        e[0] = a * l, e[4] = -u, e[8] = c * l, e[1] = t * u + i, e[5] = o * l, e[9] = n * u - r, e[2] = r * u - n, e[6] = s * l, e[10] = i * u + t
      }
      return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
    }

    makeRotationFromQuaternion(t) {
      return this.compose(Kt, t, Qt)
    }

    lookAt(t, e, n) {
      const r = this.elements;
      return ee.subVectors(t, e), 0 === ee.lengthSq() && (ee.z = 1), ee.normalize(), $t.crossVectors(n, ee), 0 === $t.lengthSq() && (1 === Math.abs(n.z) ? ee.x += 1e-4 : ee.z += 1e-4, ee.normalize(), $t.crossVectors(n, ee)), $t.normalize(), te.crossVectors(ee, $t), r[0] = $t.x, r[4] = te.x, r[8] = ee.x, r[1] = $t.y, r[5] = te.y, r[9] = ee.y, r[2] = $t.z, r[6] = te.z, r[10] = ee.z, this
    }

    multiply(t, e) {
      return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
    }

    premultiply(t) {
      return this.multiplyMatrices(t, this)
    }

    multiplyMatrices(t, e) {
      const n = t.elements, r = e.elements, i = this.elements, o = n[0], s = n[4], a = n[8], c = n[12], l = n[1],
        u = n[5], h = n[9], f = n[13], d = n[2], p = n[6], m = n[10], v = n[14], g = n[3], y = n[7], _ = n[11],
        b = n[15], x = r[0], w = r[4], S = r[8], M = r[12], E = r[1], T = r[5], O = r[9], H = r[13], A = r[2], P = r[6],
        R = r[10], L = r[14], C = r[3], k = r[7], D = r[11], N = r[15];
      return i[0] = o * x + s * E + a * A + c * C, i[4] = o * w + s * T + a * P + c * k, i[8] = o * S + s * O + a * R + c * D, i[12] = o * M + s * H + a * L + c * N, i[1] = l * x + u * E + h * A + f * C, i[5] = l * w + u * T + h * P + f * k, i[9] = l * S + u * O + h * R + f * D, i[13] = l * M + u * H + h * L + f * N, i[2] = d * x + p * E + m * A + v * C, i[6] = d * w + p * T + m * P + v * k, i[10] = d * S + p * O + m * R + v * D, i[14] = d * M + p * H + m * L + v * N, i[3] = g * x + y * E + _ * A + b * C, i[7] = g * w + y * T + _ * P + b * k, i[11] = g * S + y * O + _ * R + b * D, i[15] = g * M + y * H + _ * L + b * N, this
    }

    multiplyScalar(t) {
      const e = this.elements;
      return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
    }

    determinant() {
      const t = this.elements, e = t[0], n = t[4], r = t[8], i = t[12], o = t[1], s = t[5], a = t[9], c = t[13],
        l = t[2], u = t[6], h = t[10], f = t[14];
      return t[3] * (+i * a * u - r * c * u - i * s * h + n * c * h + r * s * f - n * a * f) + t[7] * (+e * a * f - e * c * h + i * o * h - r * o * f + r * c * l - i * a * l) + t[11] * (+e * c * u - e * s * f - i * o * u + n * o * f + i * s * l - n * c * l) + t[15] * (-r * s * l - e * a * u + e * s * h + r * o * u - n * o * h + n * a * l)
    }

    transpose() {
      const t = this.elements;
      let e;
      return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
    }

    setPosition(t, e, n) {
      const r = this.elements;
      return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = n), this
    }

    invert() {
      const t = this.elements, e = t[0], n = t[1], r = t[2], i = t[3], o = t[4], s = t[5], a = t[6], c = t[7], l = t[8],
        u = t[9], h = t[10], f = t[11], d = t[12], p = t[13], m = t[14], v = t[15],
        g = u * m * c - p * h * c + p * a * f - s * m * f - u * a * v + s * h * v,
        y = d * h * c - l * m * c - d * a * f + o * m * f + l * a * v - o * h * v,
        _ = l * p * c - d * u * c + d * s * f - o * p * f - l * s * v + o * u * v,
        b = d * u * a - l * p * a - d * s * h + o * p * h + l * s * m - o * u * m, x = e * g + n * y + r * _ + i * b;
      if (0 === x) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const w = 1 / x;
      return t[0] = g * w, t[1] = (p * h * i - u * m * i - p * r * f + n * m * f + u * r * v - n * h * v) * w, t[2] = (s * m * i - p * a * i + p * r * c - n * m * c - s * r * v + n * a * v) * w, t[3] = (u * a * i - s * h * i - u * r * c + n * h * c + s * r * f - n * a * f) * w, t[4] = y * w, t[5] = (l * m * i - d * h * i + d * r * f - e * m * f - l * r * v + e * h * v) * w, t[6] = (d * a * i - o * m * i - d * r * c + e * m * c + o * r * v - e * a * v) * w, t[7] = (o * h * i - l * a * i + l * r * c - e * h * c - o * r * f + e * a * f) * w, t[8] = _ * w, t[9] = (d * u * i - l * p * i - d * n * f + e * p * f + l * n * v - e * u * v) * w, t[10] = (o * p * i - d * s * i + d * n * c - e * p * c - o * n * v + e * s * v) * w, t[11] = (l * s * i - o * u * i - l * n * c + e * u * c + o * n * f - e * s * f) * w, t[12] = b * w, t[13] = (l * p * r - d * u * r + d * n * h - e * p * h - l * n * m + e * u * m) * w, t[14] = (d * s * r - o * p * r - d * n * a + e * p * a + o * n * m - e * s * m) * w, t[15] = (o * u * r - l * s * r + l * n * a - e * u * a - o * n * h + e * s * h) * w, this
    }

    scale(t) {
      const e = this.elements, n = t.x, r = t.y, i = t.z;
      return e[0] *= n, e[4] *= r, e[8] *= i, e[1] *= n, e[5] *= r, e[9] *= i, e[2] *= n, e[6] *= r, e[10] *= i, e[3] *= n, e[7] *= r, e[11] *= i, this
    }

    getMaxScaleOnAxis() {
      const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
        r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
      return Math.sqrt(Math.max(e, n, r))
    }

    makeTranslation(t, e, n) {
      return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
    }

    makeRotationX(t) {
      const e = Math.cos(t), n = Math.sin(t);
      return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
    }

    makeRotationY(t) {
      const e = Math.cos(t), n = Math.sin(t);
      return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
    }

    makeRotationZ(t) {
      const e = Math.cos(t), n = Math.sin(t);
      return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }

    makeRotationAxis(t, e) {
      const n = Math.cos(e), r = Math.sin(e), i = 1 - n, o = t.x, s = t.y, a = t.z, c = i * o, l = i * s;
      return this.set(c * o + n, c * s - r * a, c * a + r * s, 0, c * s + r * a, l * s + n, l * a - r * o, 0, c * a - r * s, l * a + r * o, i * a * a + n, 0, 0, 0, 0, 1), this
    }

    makeScale(t, e, n) {
      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
    }

    makeShear(t, e, n) {
      return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
    }

    compose(t, e, n) {
      const r = this.elements, i = e._x, o = e._y, s = e._z, a = e._w, c = i + i, l = o + o, u = s + s, h = i * c,
        f = i * l, d = i * u, p = o * l, m = o * u, v = s * u, g = a * c, y = a * l, _ = a * u, b = n.x, x = n.y,
        w = n.z;
      return r[0] = (1 - (p + v)) * b, r[1] = (f + _) * b, r[2] = (d - y) * b, r[3] = 0, r[4] = (f - _) * x, r[5] = (1 - (h + v)) * x, r[6] = (m + g) * x, r[7] = 0, r[8] = (d + y) * w, r[9] = (m - g) * w, r[10] = (1 - (h + p)) * w, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this
    }

    decompose(t, e, n) {
      const r = this.elements;
      let i = Zt.set(r[0], r[1], r[2]).length();
      const o = Zt.set(r[4], r[5], r[6]).length(), s = Zt.set(r[8], r[9], r[10]).length();
      this.determinant() < 0 && (i = -i), t.x = r[12], t.y = r[13], t.z = r[14], Jt.copy(this);
      const a = 1 / i, c = 1 / o, l = 1 / s;
      return Jt.elements[0] *= a, Jt.elements[1] *= a, Jt.elements[2] *= a, Jt.elements[4] *= c, Jt.elements[5] *= c, Jt.elements[6] *= c, Jt.elements[8] *= l, Jt.elements[9] *= l, Jt.elements[10] *= l, e.setFromRotationMatrix(Jt), n.x = i, n.y = o, n.z = s, this
    }

    makePerspective(t, e, n, r, i, o) {
      void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
      const s = this.elements, a = 2 * i / (e - t), c = 2 * i / (n - r), l = (e + t) / (e - t), u = (n + r) / (n - r),
        h = -(o + i) / (o - i), f = -2 * o * i / (o - i);
      return s[0] = a, s[4] = 0, s[8] = l, s[12] = 0, s[1] = 0, s[5] = c, s[9] = u, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = h, s[14] = f, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
    }

    makeOrthographic(t, e, n, r, i, o) {
      const s = this.elements, a = 1 / (e - t), c = 1 / (n - r), l = 1 / (o - i), u = (e + t) * a, h = (n + r) * c,
        f = (o + i) * l;
      return s[0] = 2 * a, s[4] = 0, s[8] = 0, s[12] = -u, s[1] = 0, s[5] = 2 * c, s[9] = 0, s[13] = -h, s[2] = 0, s[6] = 0, s[10] = -2 * l, s[14] = -f, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
    }

    equals(t) {
      const e = this.elements, n = t.elements;
      for (let r = 0; r < 16; r++) if (e[r] !== n[r]) return !1;
      return !0
    }

    fromArray(t, e = 0) {
      for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
      return this
    }

    toArray(t = [], e = 0) {
      const n = this.elements;
      return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
    }
  }

  Yt.prototype.isMatrix4 = !0;
  const Zt = new gt, Jt = new Yt, Kt = new gt(0, 0, 0), Qt = new gt(1, 1, 1), $t = new gt, te = new gt, ee = new gt,
    ne = new Yt, re = new vt;

  class ie {
    constructor(t = 0, e = 0, n = 0, r = ie.DefaultOrder) {
      this._x = t, this._y = e, this._z = n, this._order = r
    }

    get x() {
      return this._x
    }

    set x(t) {
      this._x = t, this._onChangeCallback()
    }

    get y() {
      return this._y
    }

    set y(t) {
      this._y = t, this._onChangeCallback()
    }

    get z() {
      return this._z
    }

    set z(t) {
      this._z = t, this._onChangeCallback()
    }

    get order() {
      return this._order
    }

    set order(t) {
      this._order = t, this._onChangeCallback()
    }

    set(t, e, n, r) {
      return this._x = t, this._y = e, this._z = n, this._order = r || this._order, this._onChangeCallback(), this
    }

    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order)
    }

    copy(t) {
      return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
    }

    setFromRotationMatrix(t, e, n) {
      const r = t.elements, i = r[0], o = r[4], s = r[8], a = r[1], c = r[5], l = r[9], u = r[2], h = r[6], f = r[10];
      switch (e = e || this._order) {
        case"XYZ":
          this._y = Math.asin(tt(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-l, f), this._z = Math.atan2(-o, i)) : (this._x = Math.atan2(h, c), this._z = 0);
          break;
        case"YXZ":
          this._x = Math.asin(-tt(l, -1, 1)), Math.abs(l) < .9999999 ? (this._y = Math.atan2(s, f), this._z = Math.atan2(a, c)) : (this._y = Math.atan2(-u, i), this._z = 0);
          break;
        case"ZXY":
          this._x = Math.asin(tt(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(a, i));
          break;
        case"ZYX":
          this._y = Math.asin(-tt(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, f), this._z = Math.atan2(a, i)) : (this._x = 0, this._z = Math.atan2(-o, c));
          break;
        case"YZX":
          this._z = Math.asin(tt(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-l, c), this._y = Math.atan2(-u, i)) : (this._x = 0, this._y = Math.atan2(s, f));
          break;
        case"XZY":
          this._z = Math.asin(-tt(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(h, c), this._y = Math.atan2(s, i)) : (this._x = Math.atan2(-l, f), this._y = 0);
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
      }
      return this._order = e, !1 !== n && this._onChangeCallback(), this
    }

    setFromQuaternion(t, e, n) {
      return ne.makeRotationFromQuaternion(t), this.setFromRotationMatrix(ne, e, n)
    }

    setFromVector3(t, e) {
      return this.set(t.x, t.y, t.z, e || this._order)
    }

    reorder(t) {
      return re.setFromEuler(this), this.setFromQuaternion(re, t)
    }

    equals(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
    }

    fromArray(t) {
      return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
    }

    toArray(t = [], e = 0) {
      return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
    }

    toVector3(t) {
      return t ? t.set(this._x, this._y, this._z) : new gt(this._x, this._y, this._z)
    }

    _onChange(t) {
      return this._onChangeCallback = t, this
    }

    _onChangeCallback() {
    }
  }

  ie.prototype.isEuler = !0, ie.DefaultOrder = "XYZ", ie.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];

  class oe {
    constructor() {
      this.mask = 1
    }

    set(t) {
      this.mask = 1 << t | 0
    }

    enable(t) {
      this.mask |= 1 << t | 0
    }

    enableAll() {
      this.mask = -1
    }

    toggle(t) {
      this.mask ^= 1 << t | 0
    }

    disable(t) {
      this.mask &= ~(1 << t | 0)
    }

    disableAll() {
      this.mask = 0
    }

    test(t) {
      return 0 != (this.mask & t.mask)
    }
  }

  let se = 0;
  const ae = new gt, ce = new vt, le = new Yt, ue = new gt, he = new gt, fe = new gt, de = new vt, pe = new gt(1, 0, 0),
    me = new gt(0, 1, 0), ve = new gt(0, 0, 1), ge = {type: "added"}, ye = {type: "removed"};

  class _e extends Y {
    constructor() {
      super(), Object.defineProperty(this, "id", {value: se++}), this.uuid = $(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = _e.DefaultUp.clone();
      const t = new gt, e = new ie, n = new vt, r = new gt(1, 1, 1);
      e._onChange((function () {
        n.setFromEuler(e, !1)
      })), n._onChange((function () {
        e.setFromQuaternion(n, void 0, !1)
      })), Object.defineProperties(this, {
        position: {configurable: !0, enumerable: !0, value: t},
        rotation: {configurable: !0, enumerable: !0, value: e},
        quaternion: {configurable: !0, enumerable: !0, value: n},
        scale: {configurable: !0, enumerable: !0, value: r},
        modelViewMatrix: {value: new Yt},
        normalMatrix: {value: new ct}
      }), this.matrix = new Yt, this.matrixWorld = new Yt, this.matrixAutoUpdate = _e.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new oe, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
    }

    onBeforeRender() {
    }

    onAfterRender() {
    }

    applyMatrix4(t) {
      this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
    }

    applyQuaternion(t) {
      return this.quaternion.premultiply(t), this
    }

    setRotationFromAxisAngle(t, e) {
      this.quaternion.setFromAxisAngle(t, e)
    }

    setRotationFromEuler(t) {
      this.quaternion.setFromEuler(t, !0)
    }

    setRotationFromMatrix(t) {
      this.quaternion.setFromRotationMatrix(t)
    }

    setRotationFromQuaternion(t) {
      this.quaternion.copy(t)
    }

    rotateOnAxis(t, e) {
      return ce.setFromAxisAngle(t, e), this.quaternion.multiply(ce), this
    }

    rotateOnWorldAxis(t, e) {
      return ce.setFromAxisAngle(t, e), this.quaternion.premultiply(ce), this
    }

    rotateX(t) {
      return this.rotateOnAxis(pe, t)
    }

    rotateY(t) {
      return this.rotateOnAxis(me, t)
    }

    rotateZ(t) {
      return this.rotateOnAxis(ve, t)
    }

    translateOnAxis(t, e) {
      return ae.copy(t).applyQuaternion(this.quaternion), this.position.add(ae.multiplyScalar(e)), this
    }

    translateX(t) {
      return this.translateOnAxis(pe, t)
    }

    translateY(t) {
      return this.translateOnAxis(me, t)
    }

    translateZ(t) {
      return this.translateOnAxis(ve, t)
    }

    localToWorld(t) {
      return t.applyMatrix4(this.matrixWorld)
    }

    worldToLocal(t) {
      return t.applyMatrix4(le.copy(this.matrixWorld).invert())
    }

    lookAt(t, e, n) {
      t.isVector3 ? ue.copy(t) : ue.set(t, e, n);
      const r = this.parent;
      this.updateWorldMatrix(!0, !1), he.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? le.lookAt(he, ue, this.up) : le.lookAt(ue, he, this.up), this.quaternion.setFromRotationMatrix(le), r && (le.extractRotation(r.matrixWorld), ce.setFromRotationMatrix(le), this.quaternion.premultiply(ce.invert()))
    }

    add(t) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
        return this
      }
      return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(ge)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
    }

    remove(t) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
        return this
      }
      const e = this.children.indexOf(t);
      return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(ye)), this
    }

    clear() {
      for (let t = 0; t < this.children.length; t++) {
        const e = this.children[t];
        e.parent = null, e.dispatchEvent(ye)
      }
      return this.children.length = 0, this
    }

    attach(t) {
      return this.updateWorldMatrix(!0, !1), le.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), le.multiply(t.parent.matrixWorld)), t.applyMatrix4(le), this.add(t), t.updateWorldMatrix(!1, !0), this
    }

    getObjectById(t) {
      return this.getObjectByProperty("id", t)
    }

    getObjectByName(t) {
      return this.getObjectByProperty("name", t)
    }

    getObjectByProperty(t, e) {
      if (this[t] === e) return this;
      for (let n = 0, r = this.children.length; n < r; n++) {
        const r = this.children[n].getObjectByProperty(t, e);
        if (void 0 !== r) return r
      }
    }

    getWorldPosition(t) {
      return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new gt), this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
    }

    getWorldQuaternion(t) {
      return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new vt), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(he, t, fe), t
    }

    getWorldScale(t) {
      return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new gt), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(he, de, t), t
    }

    getWorldDirection(t) {
      void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new gt), this.updateWorldMatrix(!0, !1);
      const e = this.matrixWorld.elements;
      return t.set(e[8], e[9], e[10]).normalize()
    }

    raycast() {
    }

    traverse(t) {
      t(this);
      const e = this.children;
      for (let n = 0, r = e.length; n < r; n++) e[n].traverse(t)
    }

    traverseVisible(t) {
      if (!1 === this.visible) return;
      t(this);
      const e = this.children;
      for (let n = 0, r = e.length; n < r; n++) e[n].traverseVisible(t)
    }

    traverseAncestors(t) {
      const e = this.parent;
      null !== e && (t(e), e.traverseAncestors(t))
    }

    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
    }

    updateMatrixWorld(t) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
      const e = this.children;
      for (let n = 0, r = e.length; n < r; n++) e[n].updateMatrixWorld(t)
    }

    updateWorldMatrix(t, e) {
      const n = this.parent;
      if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
        const t = this.children;
        for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0)
      }
    }

    toJSON(t) {
      const e = void 0 === t || "string" == typeof t, n = {};
      e && (t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      }, n.metadata = {version: 4.5, type: "Object", generator: "Object3D.toJSON"});
      const r = {};

      function i(e, n) {
        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
      }

      if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isMesh || this.isLine || this.isPoints) {
        r.geometry = i(t.geometries, this.geometry);
        const e = this.geometry.parameters;
        if (void 0 !== e && void 0 !== e.shapes) {
          const n = e.shapes;
          if (Array.isArray(n)) for (let e = 0, r = n.length; e < r; e++) {
            const r = n[e];
            i(t.shapes, r)
          } else i(t.shapes, n)
        }
      }
      if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(t.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) {
        const e = [];
        for (let n = 0, r = this.material.length; n < r; n++) e.push(i(t.materials, this.material[n]));
        r.material = e
      } else r.material = i(t.materials, this.material);
      if (this.children.length > 0) {
        r.children = [];
        for (let e = 0; e < this.children.length; e++) r.children.push(this.children[e].toJSON(t).object)
      }
      if (this.animations.length > 0) {
        r.animations = [];
        for (let e = 0; e < this.animations.length; e++) {
          const n = this.animations[e];
          r.animations.push(i(t.animations, n))
        }
      }
      if (e) {
        const e = o(t.geometries), r = o(t.materials), i = o(t.textures), s = o(t.images), a = o(t.shapes),
          c = o(t.skeletons), l = o(t.animations);
        e.length > 0 && (n.geometries = e), r.length > 0 && (n.materials = r), i.length > 0 && (n.textures = i), s.length > 0 && (n.images = s), a.length > 0 && (n.shapes = a), c.length > 0 && (n.skeletons = c), l.length > 0 && (n.animations = l)
      }
      return n.object = r, n;

      function o(t) {
        const e = [];
        for (const n in t) {
          const r = t[n];
          delete r.metadata, e.push(r)
        }
        return e
      }
    }

    clone(t) {
      return (new this.constructor).copy(this, t)
    }

    copy(t, e = !0) {
      if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (let n = 0; n < t.children.length; n++) {
        const e = t.children[n];
        this.add(e.clone())
      }
      return this
    }
  }

  _e.DefaultUp = new gt(0, 1, 0), _e.DefaultMatrixAutoUpdate = !0, _e.prototype.isObject3D = !0;
  const be = new gt, xe = new gt, we = new ct;

  class Se {
    constructor(t = new gt(1, 0, 0), e = 0) {
      this.normal = t, this.constant = e
    }

    set(t, e) {
      return this.normal.copy(t), this.constant = e, this
    }

    setComponents(t, e, n, r) {
      return this.normal.set(t, e, n), this.constant = r, this
    }

    setFromNormalAndCoplanarPoint(t, e) {
      return this.normal.copy(t), this.constant = -e.dot(this.normal), this
    }

    setFromCoplanarPoints(t, e, n) {
      const r = be.subVectors(n, e).cross(xe.subVectors(t, e)).normalize();
      return this.setFromNormalAndCoplanarPoint(r, t), this
    }

    copy(t) {
      return this.normal.copy(t.normal), this.constant = t.constant, this
    }

    normalize() {
      const t = 1 / this.normal.length();
      return this.normal.multiplyScalar(t), this.constant *= t, this
    }

    negate() {
      return this.constant *= -1, this.normal.negate(), this
    }

    distanceToPoint(t) {
      return this.normal.dot(t) + this.constant
    }

    distanceToSphere(t) {
      return this.distanceToPoint(t.center) - t.radius
    }

    projectPoint(t, e) {
      return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new gt), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
    }

    intersectLine(t, e) {
      void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new gt);
      const n = t.delta(be), r = this.normal.dot(n);
      if (0 === r) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
      const i = -(t.start.dot(this.normal) + this.constant) / r;
      return i < 0 || i > 1 ? null : e.copy(n).multiplyScalar(i).add(t.start)
    }

    intersectsLine(t) {
      const e = this.distanceToPoint(t.start), n = this.distanceToPoint(t.end);
      return e < 0 && n > 0 || n < 0 && e > 0
    }

    intersectsBox(t) {
      return t.intersectsPlane(this)
    }

    intersectsSphere(t) {
      return t.intersectsPlane(this)
    }

    coplanarPoint(t) {
      return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new gt), t.copy(this.normal).multiplyScalar(-this.constant)
    }

    applyMatrix4(t, e) {
      const n = e || we.getNormalMatrix(t), r = this.coplanarPoint(be).applyMatrix4(t),
        i = this.normal.applyMatrix3(n).normalize();
      return this.constant = -r.dot(i), this
    }

    translate(t) {
      return this.constant -= t.dot(this.normal), this
    }

    equals(t) {
      return t.normal.equals(this.normal) && t.constant === this.constant
    }

    clone() {
      return (new this.constructor).copy(this)
    }
  }

  Se.prototype.isPlane = !0;
  const Me = new gt, Ee = new gt, Te = new gt, Oe = new gt, He = new gt, Ae = new gt, Pe = new gt, Re = new gt,
    Le = new gt, Ce = new gt;

  class ke {
    constructor(t = new gt, e = new gt, n = new gt) {
      this.a = t, this.b = e, this.c = n
    }

    static getNormal(t, e, n, r) {
      void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new gt), r.subVectors(n, e), Me.subVectors(t, e), r.cross(Me);
      const i = r.lengthSq();
      return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
    }

    static getBarycoord(t, e, n, r, i) {
      Me.subVectors(r, e), Ee.subVectors(n, e), Te.subVectors(t, e);
      const o = Me.dot(Me), s = Me.dot(Ee), a = Me.dot(Te), c = Ee.dot(Ee), l = Ee.dot(Te), u = o * c - s * s;
      if (void 0 === i && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), i = new gt), 0 === u) return i.set(-2, -1, -1);
      const h = 1 / u, f = (c * a - s * l) * h, d = (o * l - s * a) * h;
      return i.set(1 - f - d, d, f)
    }

    static containsPoint(t, e, n, r) {
      return this.getBarycoord(t, e, n, r, Oe), Oe.x >= 0 && Oe.y >= 0 && Oe.x + Oe.y <= 1
    }

    static getUV(t, e, n, r, i, o, s, a) {
      return this.getBarycoord(t, e, n, r, Oe), a.set(0, 0), a.addScaledVector(i, Oe.x), a.addScaledVector(o, Oe.y), a.addScaledVector(s, Oe.z), a
    }

    static isFrontFacing(t, e, n, r) {
      return Me.subVectors(n, e), Ee.subVectors(t, e), Me.cross(Ee).dot(r) < 0
    }

    set(t, e, n) {
      return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
    }

    setFromPointsAndIndices(t, e, n, r) {
      return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this
    }

    clone() {
      return (new this.constructor).copy(this)
    }

    copy(t) {
      return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
    }

    getArea() {
      return Me.subVectors(this.c, this.b), Ee.subVectors(this.a, this.b), .5 * Me.cross(Ee).length()
    }

    getMidpoint(t) {
      return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new gt), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }

    getNormal(t) {
      return ke.getNormal(this.a, this.b, this.c, t)
    }

    getPlane(t) {
      return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new Se), t.setFromCoplanarPoints(this.a, this.b, this.c)
    }

    getBarycoord(t, e) {
      return ke.getBarycoord(t, this.a, this.b, this.c, e)
    }

    getUV(t, e, n, r, i) {
      return ke.getUV(t, this.a, this.b, this.c, e, n, r, i)
    }

    containsPoint(t) {
      return ke.containsPoint(t, this.a, this.b, this.c)
    }

    isFrontFacing(t) {
      return ke.isFrontFacing(this.a, this.b, this.c, t)
    }

    intersectsBox(t) {
      return t.intersectsTriangle(this)
    }

    closestPointToPoint(t, e) {
      void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new gt);
      const n = this.a, r = this.b, i = this.c;
      let o, s;
      He.subVectors(r, n), Ae.subVectors(i, n), Re.subVectors(t, n);
      const a = He.dot(Re), c = Ae.dot(Re);
      if (a <= 0 && c <= 0) return e.copy(n);
      Le.subVectors(t, r);
      const l = He.dot(Le), u = Ae.dot(Le);
      if (l >= 0 && u <= l) return e.copy(r);
      const h = a * u - l * c;
      if (h <= 0 && a >= 0 && l <= 0) return o = a / (a - l), e.copy(n).addScaledVector(He, o);
      Ce.subVectors(t, i);
      const f = He.dot(Ce), d = Ae.dot(Ce);
      if (d >= 0 && f <= d) return e.copy(i);
      const p = f * c - a * d;
      if (p <= 0 && c >= 0 && d <= 0) return s = c / (c - d), e.copy(n).addScaledVector(Ae, s);
      const m = l * d - f * u;
      if (m <= 0 && u - l >= 0 && f - d >= 0) return Pe.subVectors(i, r), s = (u - l) / (u - l + (f - d)), e.copy(r).addScaledVector(Pe, s);
      const v = 1 / (m + p + h);
      return o = p * v, s = h * v, e.copy(n).addScaledVector(He, o).addScaledVector(Ae, s)
    }

    equals(t) {
      return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
    }
  }

  let De = 0;

  function Ne() {
    Object.defineProperty(this, "id", {value: De++}), this.uuid = $(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = c, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = V, this.stencilZFail = V, this.stencilZPass = V, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
  }

  Ne.prototype = Object.assign(Object.create(Y.prototype), {
    constructor: Ne, isMaterial: !0, onBuild: function () {
    }, onBeforeCompile: function () {
    }, customProgramCacheKey: function () {
      return this.onBeforeCompile.toString()
    }, setValues: function (t) {
      if (void 0 !== t) for (const e in t) {
        const n = t[e];
        if (void 0 === n) {
          console.warn("THREE.Material: '" + e + "' parameter is undefined.");
          continue
        }
        if ("shading" === e) {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
          continue
        }
        const r = this[e];
        void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
      }
    }, toJSON: function (t) {
      const e = void 0 === t || "string" == typeof t;
      e && (t = {textures: {}, images: {}});
      const n = {metadata: {version: 4.5, type: "Material", generator: "Material.toJSON"}};

      function r(t) {
        const e = [];
        for (const n in t) {
          const r = t[n];
          delete r.metadata, e.push(r)
        }
        return e
      }

      if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
        const e = r(t.textures), i = r(t.images);
        e.length > 0 && (n.textures = e), i.length > 0 && (n.images = i)
      }
      return n
    }, clone: function () {
      return (new this.constructor).copy(this)
    }, copy: function (t) {
      this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
      const e = t.clippingPlanes;
      let n = null;
      if (null !== e) {
        const t = e.length;
        n = new Array(t);
        for (let r = 0; r !== t; ++r) n[r] = e[r].clone()
      }
      return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
    }, dispose: function () {
      this.dispatchEvent({type: "dispose"})
    }
  }), Object.defineProperty(Ne.prototype, "needsUpdate", {
    set: function (t) {
      !0 === t && this.version++
    }
  });
  const ze = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  }, je = {h: 0, s: 0, l: 0}, Ie = {h: 0, s: 0, l: 0};

  function Be(t, e, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
  }

  function Fe(t) {
    return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
  }

  function Ue(t) {
    return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
  }

  class Ge {
    constructor(t, e, n) {
      return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
    }

    set(t) {
      return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
    }

    setScalar(t) {
      return this.r = t, this.g = t, this.b = t, this
    }

    setHex(t) {
      return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
    }

    setRGB(t, e, n) {
      return this.r = t, this.g = e, this.b = n, this
    }

    setHSL(t, e, n) {
      if (t = et(t, 1), e = tt(e, 0, 1), n = tt(n, 0, 1), 0 === e) this.r = this.g = this.b = n; else {
        const r = n <= .5 ? n * (1 + e) : n + e - n * e, i = 2 * n - r;
        this.r = Be(i, r, t + 1 / 3), this.g = Be(i, r, t), this.b = Be(i, r, t - 1 / 3)
      }
      return this
    }

    setStyle(t) {
      function e(e) {
        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
      }

      let n;
      if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
        let t;
        const r = n[1], i = n[2];
        switch (r) {
          case"rgb":
          case"rgba":
            if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[4]), this;
            if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[4]), this;
            break;
          case"hsl":
          case"hsla":
            if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) {
              const n = parseFloat(t[1]) / 360, r = parseInt(t[2], 10) / 100, i = parseInt(t[3], 10) / 100;
              return e(t[4]), this.setHSL(n, r, i)
            }
        }
      } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
        const t = n[1], e = t.length;
        if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
        if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
      }
      return t && t.length > 0 ? this.setColorName(t) : this
    }

    setColorName(t) {
      const e = ze[t.toLowerCase()];
      return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this
    }

    clone() {
      return new this.constructor(this.r, this.g, this.b)
    }

    copy(t) {
      return this.r = t.r, this.g = t.g, this.b = t.b, this
    }

    copyGammaToLinear(t, e = 2) {
      return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
    }

    copyLinearToGamma(t, e = 2) {
      const n = e > 0 ? 1 / e : 1;
      return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
    }

    convertGammaToLinear(t) {
      return this.copyGammaToLinear(this, t), this
    }

    convertLinearToGamma(t) {
      return this.copyLinearToGamma(this, t), this
    }

    copySRGBToLinear(t) {
      return this.r = Fe(t.r), this.g = Fe(t.g), this.b = Fe(t.b), this
    }

    copyLinearToSRGB(t) {
      return this.r = Ue(t.r), this.g = Ue(t.g), this.b = Ue(t.b), this
    }

    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this
    }

    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this
    }

    getHex() {
      return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
    }

    getHexString() {
      return ("000000" + this.getHex().toString(16)).slice(-6)
    }

    getHSL(t) {
      void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {h: 0, s: 0, l: 0});
      const e = this.r, n = this.g, r = this.b, i = Math.max(e, n, r), o = Math.min(e, n, r);
      let s, a;
      const c = (o + i) / 2;
      if (o === i) s = 0, a = 0; else {
        const t = i - o;
        switch (a = c <= .5 ? t / (i + o) : t / (2 - i - o), i) {
          case e:
            s = (n - r) / t + (n < r ? 6 : 0);
            break;
          case n:
            s = (r - e) / t + 2;
            break;
          case r:
            s = (e - n) / t + 4
        }
        s /= 6
      }
      return t.h = s, t.s = a, t.l = c, t
    }

    getStyle() {
      return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
    }

    offsetHSL(t, e, n) {
      return this.getHSL(je), je.h += t, je.s += e, je.l += n, this.setHSL(je.h, je.s, je.l), this
    }

    add(t) {
      return this.r += t.r, this.g += t.g, this.b += t.b, this
    }

    addColors(t, e) {
      return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
    }

    addScalar(t) {
      return this.r += t, this.g += t, this.b += t, this
    }

    sub(t) {
      return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
    }

    multiply(t) {
      return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
    }

    multiplyScalar(t) {
      return this.r *= t, this.g *= t, this.b *= t, this
    }

    lerp(t, e) {
      return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
    }

    lerpColors(t, e, n) {
      return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
    }

    lerpHSL(t, e) {
      this.getHSL(je), t.getHSL(Ie);
      const n = nt(je.h, Ie.h, e), r = nt(je.s, Ie.s, e), i = nt(je.l, Ie.l, e);
      return this.setHSL(n, r, i), this
    }

    equals(t) {
      return t.r === this.r && t.g === this.g && t.b === this.b
    }

    fromArray(t, e = 0) {
      return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
    }

    toArray(t = [], e = 0) {
      return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
    }

    fromBufferAttribute(t, e) {
      return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
    }

    toJSON() {
      return this.getHex()
    }
  }

  Ge.NAMES = ze, Ge.prototype.isColor = !0, Ge.prototype.r = 1, Ge.prototype.g = 1, Ge.prototype.b = 1;

  class Ve extends Ne {
    constructor(t) {
      super(), this.type = "MeshBasicMaterial", this.color = new Ge(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t)
    }

    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
    }
  }

  Ve.prototype.isMeshBasicMaterial = !0;
  const We = new gt, Xe = new at;

  class qe {
    constructor(t, e, n) {
      if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = W, this.updateRange = {
        offset: 0,
        count: -1
      }, this.version = 0, this.onUploadCallback = function () {
      }
    }

    set needsUpdate(t) {
      !0 === t && this.version++
    }

    setUsage(t) {
      return this.usage = t, this
    }

    copy(t) {
      return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
    }

    copyAt(t, e, n) {
      t *= this.itemSize, n *= e.itemSize;
      for (let r = 0, i = this.itemSize; r < i; r++) this.array[t + r] = e.array[n + r];
      return this
    }

    copyArray(t) {
      return this.array.set(t), this
    }

    copyColorsArray(t) {
      const e = this.array;
      let n = 0;
      for (let r = 0, i = t.length; r < i; r++) {
        let i = t[r];
        void 0 === i && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), i = new Ge), e[n++] = i.r, e[n++] = i.g, e[n++] = i.b
      }
      return this
    }

    copyVector2sArray(t) {
      const e = this.array;
      let n = 0;
      for (let r = 0, i = t.length; r < i; r++) {
        let i = t[r];
        void 0 === i && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), i = new at), e[n++] = i.x, e[n++] = i.y
      }
      return this
    }

    copyVector3sArray(t) {
      const e = this.array;
      let n = 0;
      for (let r = 0, i = t.length; r < i; r++) {
        let i = t[r];
        void 0 === i && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), i = new gt), e[n++] = i.x, e[n++] = i.y, e[n++] = i.z
      }
      return this
    }

    copyVector4sArray(t) {
      const e = this.array;
      let n = 0;
      for (let r = 0, i = t.length; r < i; r++) {
        let i = t[r];
        void 0 === i && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), i = new pt), e[n++] = i.x, e[n++] = i.y, e[n++] = i.z, e[n++] = i.w
      }
      return this
    }

    applyMatrix3(t) {
      if (2 === this.itemSize) for (let e = 0, n = this.count; e < n; e++) Xe.fromBufferAttribute(this, e), Xe.applyMatrix3(t), this.setXY(e, Xe.x, Xe.y); else if (3 === this.itemSize) for (let e = 0, n = this.count; e < n; e++) We.fromBufferAttribute(this, e), We.applyMatrix3(t), this.setXYZ(e, We.x, We.y, We.z);
      return this
    }

    applyMatrix4(t) {
      for (let e = 0, n = this.count; e < n; e++) We.x = this.getX(e), We.y = this.getY(e), We.z = this.getZ(e), We.applyMatrix4(t), this.setXYZ(e, We.x, We.y, We.z);
      return this
    }

    applyNormalMatrix(t) {
      for (let e = 0, n = this.count; e < n; e++) We.x = this.getX(e), We.y = this.getY(e), We.z = this.getZ(e), We.applyNormalMatrix(t), this.setXYZ(e, We.x, We.y, We.z);
      return this
    }

    transformDirection(t) {
      for (let e = 0, n = this.count; e < n; e++) We.x = this.getX(e), We.y = this.getY(e), We.z = this.getZ(e), We.transformDirection(t), this.setXYZ(e, We.x, We.y, We.z);
      return this
    }

    set(t, e = 0) {
      return this.array.set(t, e), this
    }

    getX(t) {
      return this.array[t * this.itemSize]
    }

    setX(t, e) {
      return this.array[t * this.itemSize] = e, this
    }

    getY(t) {
      return this.array[t * this.itemSize + 1]
    }

    setY(t, e) {
      return this.array[t * this.itemSize + 1] = e, this
    }

    getZ(t) {
      return this.array[t * this.itemSize + 2]
    }

    setZ(t, e) {
      return this.array[t * this.itemSize + 2] = e, this
    }

    getW(t) {
      return this.array[t * this.itemSize + 3]
    }

    setW(t, e) {
      return this.array[t * this.itemSize + 3] = e, this
    }

    setXY(t, e, n) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
    }

    setXYZ(t, e, n, r) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this
    }

    setXYZW(t, e, n, r, i) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = i, this
    }

    onUpload(t) {
      return this.onUploadCallback = t, this
    }

    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this)
    }

    toJSON() {
      const t = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.prototype.slice.call(this.array),
        normalized: this.normalized
      };
      return "" !== this.name && (t.name = this.name), this.usage !== W && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
    }
  }

  qe.prototype.isBufferAttribute = !0;

  class Ye extends qe {
    constructor(t, e, n) {
      super(new Uint16Array(t), e, n)
    }
  }

  class Ze extends qe {
    constructor(t, e, n) {
      super(new Uint32Array(t), e, n)
    }
  }

  (class extends qe {
    constructor(t, e, n) {
      super(new Uint16Array(t), e, n)
    }
  }).prototype.isFloat16BufferAttribute = !0;

  class Je extends qe {
    constructor(t, e, n) {
      super(new Float32Array(t), e, n)
    }
  }

  function Ke(t) {
    if (0 === t.length) return -1 / 0;
    let e = t[0];
    for (let n = 1, r = t.length; n < r; ++n) t[n] > e && (e = t[n]);
    return e
  }

  Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
  let Qe = 0;
  const $e = new Yt, tn = new _e, en = new gt, nn = new bt, rn = new bt, on = new gt;

  class sn extends Y {
    constructor() {
      super(), Object.defineProperty(this, "id", {value: Qe++}), this.uuid = $(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
        start: 0,
        count: 1 / 0
      }, this.userData = {}
    }

    getIndex() {
      return this.index
    }

    setIndex(t) {
      return Array.isArray(t) ? this.index = new (Ke(t) > 65535 ? Ze : Ye)(t, 1) : this.index = t, this
    }

    getAttribute(t) {
      return this.attributes[t]
    }

    setAttribute(t, e) {
      return this.attributes[t] = e, this
    }

    deleteAttribute(t) {
      return delete this.attributes[t], this
    }

    hasAttribute(t) {
      return void 0 !== this.attributes[t]
    }

    addGroup(t, e, n = 0) {
      this.groups.push({start: t, count: e, materialIndex: n})
    }

    clearGroups() {
      this.groups = []
    }

    setDrawRange(t, e) {
      this.drawRange.start = t, this.drawRange.count = e
    }

    applyMatrix4(t) {
      const e = this.attributes.position;
      void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
      const n = this.attributes.normal;
      if (void 0 !== n) {
        const e = (new ct).getNormalMatrix(t);
        n.applyNormalMatrix(e), n.needsUpdate = !0
      }
      const r = this.attributes.tangent;
      return void 0 !== r && (r.transformDirection(t), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
    }

    rotateX(t) {
      return $e.makeRotationX(t), this.applyMatrix4($e), this
    }

    rotateY(t) {
      return $e.makeRotationY(t), this.applyMatrix4($e), this
    }

    rotateZ(t) {
      return $e.makeRotationZ(t), this.applyMatrix4($e), this
    }

    translate(t, e, n) {
      return $e.makeTranslation(t, e, n), this.applyMatrix4($e), this
    }

    scale(t, e, n) {
      return $e.makeScale(t, e, n), this.applyMatrix4($e), this
    }

    lookAt(t) {
      return tn.lookAt(t), tn.updateMatrix(), this.applyMatrix4(tn.matrix), this
    }

    center() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(en).negate(), this.translate(en.x, en.y, en.z), this
    }

    setFromPoints(t) {
      const e = [];
      for (let n = 0, r = t.length; n < r; n++) {
        const r = t[n];
        e.push(r.x, r.y, r.z || 0)
      }
      return this.setAttribute("position", new Je(e, 3)), this
    }

    computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new bt);
      const t = this.attributes.position, e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new gt(-1 / 0, -1 / 0, -1 / 0), new gt(1 / 0, 1 / 0, 1 / 0));
      if (void 0 !== t) {
        if (this.boundingBox.setFromBufferAttribute(t), e) for (let n = 0, r = e.length; n < r; n++) {
          const t = e[n];
          nn.setFromBufferAttribute(t), this.morphTargetsRelative ? (on.addVectors(this.boundingBox.min, nn.min), this.boundingBox.expandByPoint(on), on.addVectors(this.boundingBox.max, nn.max), this.boundingBox.expandByPoint(on)) : (this.boundingBox.expandByPoint(nn.min), this.boundingBox.expandByPoint(nn.max))
        }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }

    computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new It);
      const t = this.attributes.position, e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new gt, 1 / 0);
      if (t) {
        const n = this.boundingSphere.center;
        if (nn.setFromBufferAttribute(t), e) for (let t = 0, i = e.length; t < i; t++) {
          const n = e[t];
          rn.setFromBufferAttribute(n), this.morphTargetsRelative ? (on.addVectors(nn.min, rn.min), nn.expandByPoint(on), on.addVectors(nn.max, rn.max), nn.expandByPoint(on)) : (nn.expandByPoint(rn.min), nn.expandByPoint(rn.max))
        }
        nn.getCenter(n);
        let r = 0;
        for (let e = 0, i = t.count; e < i; e++) on.fromBufferAttribute(t, e), r = Math.max(r, n.distanceToSquared(on));
        if (e) for (let i = 0, o = e.length; i < o; i++) {
          const o = e[i], s = this.morphTargetsRelative;
          for (let e = 0, i = o.count; e < i; e++) on.fromBufferAttribute(o, e), s && (en.fromBufferAttribute(t, e), on.add(en)), r = Math.max(r, n.distanceToSquared(on))
        }
        this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
      }
    }

    computeFaceNormals() {
    }

    computeTangents() {
      const t = this.index, e = this.attributes;
      if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      const n = t.array, r = e.position.array, i = e.normal.array, o = e.uv.array, s = r.length / 3;
      void 0 === e.tangent && this.setAttribute("tangent", new qe(new Float32Array(4 * s), 4));
      const a = e.tangent.array, c = [], l = [];
      for (let E = 0; E < s; E++) c[E] = new gt, l[E] = new gt;
      const u = new gt, h = new gt, f = new gt, d = new at, p = new at, m = new at, v = new gt, g = new gt;

      function y(t, e, n) {
        u.fromArray(r, 3 * t), h.fromArray(r, 3 * e), f.fromArray(r, 3 * n), d.fromArray(o, 2 * t), p.fromArray(o, 2 * e), m.fromArray(o, 2 * n), h.sub(u), f.sub(u), p.sub(d), m.sub(d);
        const i = 1 / (p.x * m.y - m.x * p.y);
        isFinite(i) && (v.copy(h).multiplyScalar(m.y).addScaledVector(f, -p.y).multiplyScalar(i), g.copy(f).multiplyScalar(p.x).addScaledVector(h, -m.x).multiplyScalar(i), c[t].add(v), c[e].add(v), c[n].add(v), l[t].add(g), l[e].add(g), l[n].add(g))
      }

      let _ = this.groups;
      0 === _.length && (_ = [{start: 0, count: n.length}]);
      for (let E = 0, T = _.length; E < T; ++E) {
        const t = _[E], e = t.start;
        for (let r = e, i = e + t.count; r < i; r += 3) y(n[r + 0], n[r + 1], n[r + 2])
      }
      const b = new gt, x = new gt, w = new gt, S = new gt;

      function M(t) {
        w.fromArray(i, 3 * t), S.copy(w);
        const e = c[t];
        b.copy(e), b.sub(w.multiplyScalar(w.dot(e))).normalize(), x.crossVectors(S, e);
        const n = x.dot(l[t]) < 0 ? -1 : 1;
        a[4 * t] = b.x, a[4 * t + 1] = b.y, a[4 * t + 2] = b.z, a[4 * t + 3] = n
      }

      for (let E = 0, T = _.length; E < T; ++E) {
        const t = _[E], e = t.start;
        for (let r = e, i = e + t.count; r < i; r += 3) M(n[r + 0]), M(n[r + 1]), M(n[r + 2])
      }
    }

    computeVertexNormals() {
      const t = this.index, e = this.getAttribute("position");
      if (void 0 !== e) {
        let n = this.getAttribute("normal");
        if (void 0 === n) n = new qe(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n); else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
        const r = new gt, i = new gt, o = new gt, s = new gt, a = new gt, c = new gt, l = new gt, u = new gt;
        if (t) for (let h = 0, f = t.count; h < f; h += 3) {
          const f = t.getX(h + 0), d = t.getX(h + 1), p = t.getX(h + 2);
          r.fromBufferAttribute(e, f), i.fromBufferAttribute(e, d), o.fromBufferAttribute(e, p), l.subVectors(o, i), u.subVectors(r, i), l.cross(u), s.fromBufferAttribute(n, f), a.fromBufferAttribute(n, d), c.fromBufferAttribute(n, p), s.add(l), a.add(l), c.add(l), n.setXYZ(f, s.x, s.y, s.z), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(p, c.x, c.y, c.z)
        } else for (let t = 0, h = e.count; t < h; t += 3) r.fromBufferAttribute(e, t + 0), i.fromBufferAttribute(e, t + 1), o.fromBufferAttribute(e, t + 2), l.subVectors(o, i), u.subVectors(r, i), l.cross(u), n.setXYZ(t + 0, l.x, l.y, l.z), n.setXYZ(t + 1, l.x, l.y, l.z), n.setXYZ(t + 2, l.x, l.y, l.z);
        this.normalizeNormals(), n.needsUpdate = !0
      }
    }

    merge(t, e) {
      if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
      void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
      const n = this.attributes;
      for (const r in n) {
        if (void 0 === t.attributes[r]) continue;
        const i = n[r].array, o = t.attributes[r], s = o.array, a = o.itemSize * e,
          c = Math.min(s.length, i.length - a);
        for (let t = 0, e = a; t < c; t++, e++) i[e] = s[t]
      }
      return this
    }

    normalizeNormals() {
      const t = this.attributes.normal;
      for (let e = 0, n = t.count; e < n; e++) on.fromBufferAttribute(t, e), on.normalize(), t.setXYZ(e, on.x, on.y, on.z)
    }

    toNonIndexed() {
      function t(t, e) {
        const n = t.array, r = t.itemSize, i = t.normalized, o = new n.constructor(e.length * r);
        let s = 0, a = 0;
        for (let c = 0, l = e.length; c < l; c++) {
          s = e[c] * r;
          for (let t = 0; t < r; t++) o[a++] = n[s++]
        }
        return new qe(o, r, i)
      }

      if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
      const e = new sn, n = this.index.array, r = this.attributes;
      for (const s in r) {
        const i = t(r[s], n);
        e.setAttribute(s, i)
      }
      const i = this.morphAttributes;
      for (const s in i) {
        const r = [], o = i[s];
        for (let e = 0, i = o.length; e < i; e++) {
          const i = t(o[e], n);
          r.push(i)
        }
        e.morphAttributes[s] = r
      }
      e.morphTargetsRelative = this.morphTargetsRelative;
      const o = this.groups;
      for (let s = 0, a = o.length; s < a; s++) {
        const t = o[s];
        e.addGroup(t.start, t.count, t.materialIndex)
      }
      return e
    }

    toJSON() {
      const t = {metadata: {version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON"}};
      if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
        const e = this.parameters;
        for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
        return t
      }
      t.data = {attributes: {}};
      const e = this.index;
      null !== e && (t.data.index = {type: e.array.constructor.name, array: Array.prototype.slice.call(e.array)});
      const n = this.attributes;
      for (const a in n) {
        const e = n[a];
        t.data.attributes[a] = e.toJSON(t.data)
      }
      const r = {};
      let i = !1;
      for (const a in this.morphAttributes) {
        const e = this.morphAttributes[a], n = [];
        for (let r = 0, i = e.length; r < i; r++) {
          const i = e[r];
          n.push(i.toJSON(t.data))
        }
        n.length > 0 && (r[a] = n, i = !0)
      }
      i && (t.data.morphAttributes = r, t.data.morphTargetsRelative = this.morphTargetsRelative);
      const o = this.groups;
      o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
      const s = this.boundingSphere;
      return null !== s && (t.data.boundingSphere = {center: s.center.toArray(), radius: s.radius}), t
    }

    clone() {
      return (new sn).copy(this)
    }

    copy(t) {
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
      const e = {};
      this.name = t.name;
      const n = t.index;
      null !== n && this.setIndex(n.clone(e));
      const r = t.attributes;
      for (const c in r) {
        const t = r[c];
        this.setAttribute(c, t.clone(e))
      }
      const i = t.morphAttributes;
      for (const c in i) {
        const t = [], n = i[c];
        for (let r = 0, i = n.length; r < i; r++) t.push(n[r].clone(e));
        this.morphAttributes[c] = t
      }
      this.morphTargetsRelative = t.morphTargetsRelative;
      const o = t.groups;
      for (let c = 0, l = o.length; c < l; c++) {
        const t = o[c];
        this.addGroup(t.start, t.count, t.materialIndex)
      }
      const s = t.boundingBox;
      null !== s && (this.boundingBox = s.clone());
      const a = t.boundingSphere;
      return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
    }

    dispose() {
      this.dispatchEvent({type: "dispose"})
    }
  }

  sn.prototype.isBufferGeometry = !0;
  const an = new Yt, cn = new qt, ln = new It, un = new gt, hn = new gt, fn = new gt, dn = new gt, pn = new gt,
    mn = new gt, vn = new gt, gn = new gt, yn = new gt, _n = new at, bn = new at, xn = new at, wn = new gt, Sn = new gt;

  class Mn extends _e {
    constructor(t = new sn, e = new Ve) {
      super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
    }

    copy(t) {
      return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
    }

    updateMorphTargets() {
      const t = this.geometry;
      if (t.isBufferGeometry) {
        const e = t.morphAttributes, n = Object.keys(e);
        if (n.length > 0) {
          const t = e[n[0]];
          if (void 0 !== t) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e].name || String(e);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
            }
          }
        }
      } else {
        const e = t.morphTargets;
        void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
      }
    }

    raycast(t, e) {
      const n = this.geometry, r = this.material, i = this.matrixWorld;
      if (void 0 === r) return;
      if (null === n.boundingSphere && n.computeBoundingSphere(), ln.copy(n.boundingSphere), ln.applyMatrix4(i), !1 === t.ray.intersectsSphere(ln)) return;
      if (an.copy(i).invert(), cn.copy(t.ray).applyMatrix4(an), null !== n.boundingBox && !1 === cn.intersectsBox(n.boundingBox)) return;
      let o;
      if (n.isBufferGeometry) {
        const i = n.index, s = n.attributes.position, a = n.morphAttributes.position, c = n.morphTargetsRelative,
          l = n.attributes.uv, u = n.attributes.uv2, h = n.groups, f = n.drawRange;
        if (null !== i) if (Array.isArray(r)) for (let n = 0, d = h.length; n < d; n++) {
          const d = h[n], p = r[d.materialIndex];
          for (let n = Math.max(d.start, f.start), r = Math.min(d.start + d.count, f.start + f.count); n < r; n += 3) {
            const r = i.getX(n), h = i.getX(n + 1), f = i.getX(n + 2);
            o = En(this, p, t, cn, s, a, c, l, u, r, h, f), o && (o.faceIndex = Math.floor(n / 3), o.face.materialIndex = d.materialIndex, e.push(o))
          }
        } else {
          for (let n = Math.max(0, f.start), h = Math.min(i.count, f.start + f.count); n < h; n += 3) {
            const h = i.getX(n), f = i.getX(n + 1), d = i.getX(n + 2);
            o = En(this, r, t, cn, s, a, c, l, u, h, f, d), o && (o.faceIndex = Math.floor(n / 3), e.push(o))
          }
        } else if (void 0 !== s) if (Array.isArray(r)) for (let n = 0, d = h.length; n < d; n++) {
          const i = h[n], d = r[i.materialIndex];
          for (let n = Math.max(i.start, f.start), r = Math.min(i.start + i.count, f.start + f.count); n < r; n += 3) {
            o = En(this, d, t, cn, s, a, c, l, u, n, n + 1, n + 2), o && (o.faceIndex = Math.floor(n / 3), o.face.materialIndex = i.materialIndex, e.push(o))
          }
        } else {
          for (let n = Math.max(0, f.start), i = Math.min(s.count, f.start + f.count); n < i; n += 3) {
            o = En(this, r, t, cn, s, a, c, l, u, n, n + 1, n + 2), o && (o.faceIndex = Math.floor(n / 3), e.push(o))
          }
        }
      } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
    }
  }

  function En(t, e, n, r, i, a, c, l, u, h, f, d) {
    un.fromBufferAttribute(i, h), hn.fromBufferAttribute(i, f), fn.fromBufferAttribute(i, d);
    const p = t.morphTargetInfluences;
    if (e.morphTargets && a && p) {
      vn.set(0, 0, 0), gn.set(0, 0, 0), yn.set(0, 0, 0);
      for (let t = 0, e = a.length; t < e; t++) {
        const e = p[t], n = a[t];
        0 !== e && (dn.fromBufferAttribute(n, h), pn.fromBufferAttribute(n, f), mn.fromBufferAttribute(n, d), c ? (vn.addScaledVector(dn, e), gn.addScaledVector(pn, e), yn.addScaledVector(mn, e)) : (vn.addScaledVector(dn.sub(un), e), gn.addScaledVector(pn.sub(hn), e), yn.addScaledVector(mn.sub(fn), e)))
      }
      un.add(vn), hn.add(gn), fn.add(yn)
    }
    t.isSkinnedMesh && e.skinning && (t.boneTransform(h, un), t.boneTransform(f, hn), t.boneTransform(d, fn));
    const m = function (t, e, n, r, i, a, c, l) {
      let u;
      if (u = e.side === o ? r.intersectTriangle(c, a, i, !0, l) : r.intersectTriangle(i, a, c, e.side !== s, l), null === u) return null;
      Sn.copy(l), Sn.applyMatrix4(t.matrixWorld);
      const h = n.ray.origin.distanceTo(Sn);
      return h < n.near || h > n.far ? null : {distance: h, point: Sn.clone(), object: t}
    }(t, e, n, r, un, hn, fn, wn);
    if (m) {
      l && (_n.fromBufferAttribute(l, h), bn.fromBufferAttribute(l, f), xn.fromBufferAttribute(l, d), m.uv = ke.getUV(wn, un, hn, fn, _n, bn, xn, new at)), u && (_n.fromBufferAttribute(u, h), bn.fromBufferAttribute(u, f), xn.fromBufferAttribute(u, d), m.uv2 = ke.getUV(wn, un, hn, fn, _n, bn, xn, new at));
      const t = {a: h, b: f, c: d, normal: new gt, materialIndex: 0};
      ke.getNormal(un, hn, fn, t.normal), m.face = t
    }
    return m
  }

  Mn.prototype.isMesh = !0;

  class Tn extends sn {
    constructor(t = 1, e = 1, n = 1, r = 1, i = 1, o = 1) {
      super(), this.type = "BoxGeometry", this.parameters = {
        width: t,
        height: e,
        depth: n,
        widthSegments: r,
        heightSegments: i,
        depthSegments: o
      };
      const s = this;
      r = Math.floor(r), i = Math.floor(i), o = Math.floor(o);
      const a = [], c = [], l = [], u = [];
      let h = 0, f = 0;

      function d(t, e, n, r, i, o, d, p, m, v, g) {
        const y = o / m, _ = d / v, b = o / 2, x = d / 2, w = p / 2, S = m + 1, M = v + 1;
        let E = 0, T = 0;
        const O = new gt;
        for (let s = 0; s < M; s++) {
          const o = s * _ - x;
          for (let a = 0; a < S; a++) {
            const h = a * y - b;
            O[t] = h * r, O[e] = o * i, O[n] = w, c.push(O.x, O.y, O.z), O[t] = 0, O[e] = 0, O[n] = p > 0 ? 1 : -1, l.push(O.x, O.y, O.z), u.push(a / m), u.push(1 - s / v), E += 1
          }
        }
        for (let s = 0; s < v; s++) for (let t = 0; t < m; t++) {
          const e = h + t + S * s, n = h + t + S * (s + 1), r = h + (t + 1) + S * (s + 1), i = h + (t + 1) + S * s;
          a.push(e, n, i), a.push(n, r, i), T += 6
        }
        s.addGroup(f, T, g), f += T, h += E
      }

      d("z", "y", "x", -1, -1, n, e, t, o, i, 0), d("z", "y", "x", 1, -1, n, e, -t, o, i, 1), d("x", "z", "y", 1, 1, t, n, e, r, o, 2), d("x", "z", "y", 1, -1, t, n, -e, r, o, 3), d("x", "y", "z", 1, -1, t, e, n, r, i, 4), d("x", "y", "z", -1, -1, t, e, -n, r, i, 5), this.setIndex(a), this.setAttribute("position", new Je(c, 3)), this.setAttribute("normal", new Je(l, 3)), this.setAttribute("uv", new Je(u, 2))
    }
  }

  function On(t) {
    const e = {};
    for (const n in t) {
      e[n] = {};
      for (const r in t[n]) {
        const i = t[n][r];
        i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? e[n][r] = i.clone() : Array.isArray(i) ? e[n][r] = i.slice() : e[n][r] = i
      }
    }
    return e
  }

  function Hn(t) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
      const r = On(t[n]);
      for (const t in r) e[t] = r[t]
    }
    return e
  }

  const An = {clone: On, merge: Hn};

  class Pn extends Ne {
    constructor(t) {
      super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1
      }, this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0]
      }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
    }

    copy(t) {
      return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = On(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
    }

    toJSON(t) {
      const e = super.toJSON(t);
      e.glslVersion = this.glslVersion, e.uniforms = {};
      for (const r in this.uniforms) {
        const n = this.uniforms[r].value;
        n && n.isTexture ? e.uniforms[r] = {
          type: "t",
          value: n.toJSON(t).uuid
        } : n && n.isColor ? e.uniforms[r] = {
          type: "c",
          value: n.getHex()
        } : n && n.isVector2 ? e.uniforms[r] = {
          type: "v2",
          value: n.toArray()
        } : n && n.isVector3 ? e.uniforms[r] = {
          type: "v3",
          value: n.toArray()
        } : n && n.isVector4 ? e.uniforms[r] = {
          type: "v4",
          value: n.toArray()
        } : n && n.isMatrix3 ? e.uniforms[r] = {
          type: "m3",
          value: n.toArray()
        } : n && n.isMatrix4 ? e.uniforms[r] = {type: "m4", value: n.toArray()} : e.uniforms[r] = {value: n}
      }
      Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
      const n = {};
      for (const r in this.extensions) !0 === this.extensions[r] && (n[r] = !0);
      return Object.keys(n).length > 0 && (e.extensions = n), e
    }
  }

  Pn.prototype.isShaderMaterial = !0;

  class Rn extends _e {
    constructor() {
      super(), this.type = "Camera", this.matrixWorldInverse = new Yt, this.projectionMatrix = new Yt, this.projectionMatrixInverse = new Yt
    }

    copy(t, e) {
      return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
    }

    getWorldDirection(t) {
      void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new gt), this.updateWorldMatrix(!0, !1);
      const e = this.matrixWorld.elements;
      return t.set(-e[8], -e[9], -e[10]).normalize()
    }

    updateMatrixWorld(t) {
      super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }

    updateWorldMatrix(t, e) {
      super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }

    clone() {
      return (new this.constructor).copy(this)
    }
  }

  Rn.prototype.isCamera = !0;

  class Ln extends Rn {
    constructor(t = 50, e = 1, n = .1, r = 2e3) {
      super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }

    copy(t, e) {
      return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
    }

    setFocalLength(t) {
      const e = .5 * this.getFilmHeight() / t;
      this.fov = 2 * Q * Math.atan(e), this.updateProjectionMatrix()
    }

    getFocalLength() {
      const t = Math.tan(.5 * K * this.fov);
      return .5 * this.getFilmHeight() / t
    }

    getEffectiveFOV() {
      return 2 * Q * Math.atan(Math.tan(.5 * K * this.fov) / this.zoom)
    }

    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1)
    }

    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1)
    }

    setViewOffset(t, e, n, r, i, o) {
      this.aspect = t / e, null === this.view && (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
    }

    clearViewOffset() {
      null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
    }

    updateProjectionMatrix() {
      const t = this.near;
      let e = t * Math.tan(.5 * K * this.fov) / this.zoom, n = 2 * e, r = this.aspect * n, i = -.5 * r;
      const o = this.view;
      if (null !== this.view && this.view.enabled) {
        const t = o.fullWidth, s = o.fullHeight;
        i += o.offsetX * r / t, e -= o.offsetY * n / s, r *= o.width / t, n *= o.height / s
      }
      const s = this.filmOffset;
      0 !== s && (i += t * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }

    toJSON(t) {
      const e = super.toJSON(t);
      return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
    }
  }

  Ln.prototype.isPerspectiveCamera = !0;
  const Cn = 90;

  class kn extends _e {
    constructor(t, e, n) {
      if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      this.renderTarget = n;
      const r = new Ln(Cn, 1, t, e);
      r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new gt(1, 0, 0)), this.add(r);
      const i = new Ln(Cn, 1, t, e);
      i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new gt(-1, 0, 0)), this.add(i);
      const o = new Ln(Cn, 1, t, e);
      o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new gt(0, 1, 0)), this.add(o);
      const s = new Ln(Cn, 1, t, e);
      s.layers = this.layers, s.up.set(0, 0, -1), s.lookAt(new gt(0, -1, 0)), this.add(s);
      const a = new Ln(Cn, 1, t, e);
      a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new gt(0, 0, 1)), this.add(a);
      const c = new Ln(Cn, 1, t, e);
      c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new gt(0, 0, -1)), this.add(c)
    }

    update(t, e) {
      null === this.parent && this.updateMatrixWorld();
      const n = this.renderTarget, [r, i, o, s, a, c] = this.children, l = t.xr.enabled, u = t.getRenderTarget();
      t.xr.enabled = !1;
      const h = n.texture.generateMipmaps;
      n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, r), t.setRenderTarget(n, 1), t.render(e, i), t.setRenderTarget(n, 2), t.render(e, o), t.setRenderTarget(n, 3), t.render(e, s), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = h, t.setRenderTarget(n, 5), t.render(e, c), t.setRenderTarget(u), t.xr.enabled = l
    }
  }

  class Dn extends ft {
    constructor(t, e, n, r, i, o, s, a, c, l) {
      super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : u, n, r, i, o, s = void 0 !== s ? s : H, a, c, l), this._needsFlipEnvMap = !0, this.flipY = !1
    }

    get images() {
      return this.image
    }

    set images(t) {
      this.image = t
    }
  }

  Dn.prototype.isCubeTexture = !0;

  class Nn extends mt {
    constructor(t, e, n) {
      Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new Dn(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : b, this.texture._needsFlipEnvMap = !1
    }

    fromEquirectangularTexture(t, e) {
      this.texture.type = e.type, this.texture.format = A, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
      const n = {
        uniforms: {tEquirect: {value: null}},
        vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
        fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
      }, r = new Tn(5, 5, 5), i = new Pn({
        name: "CubemapFromEquirect",
        uniforms: On(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: o,
        blending: 0
      });
      i.uniforms.tEquirect.value = e;
      const s = new Mn(r, i), a = e.minFilter;
      e.minFilter === x && (e.minFilter = b);
      return new kn(1, 10, this).update(t, s), e.minFilter = a, s.geometry.dispose(), s.material.dispose(), this
    }

    clear(t, e, n, r) {
      const i = t.getRenderTarget();
      for (let o = 0; o < 6; o++) t.setRenderTarget(this, o), t.clear(e, n, r);
      t.setRenderTarget(i)
    }
  }

  Nn.prototype.isWebGLCubeRenderTarget = !0;

  class zn extends ft {
    constructor(t, e, n, r, i, o, s, a, c, l, u, h) {
      super(null, o, s, a, c, l, r, i, u, h), this.image = {
        data: t || null,
        width: e || 1,
        height: n || 1
      }, this.magFilter = void 0 !== c ? c : g, this.minFilter = void 0 !== l ? l : g, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
    }
  }

  zn.prototype.isDataTexture = !0;
  const jn = new It, In = new gt;

  class Bn {
    constructor(t = new Se, e = new Se, n = new Se, r = new Se, i = new Se, o = new Se) {
      this.planes = [t, e, n, r, i, o]
    }

    set(t, e, n, r, i, o) {
      const s = this.planes;
      return s[0].copy(t), s[1].copy(e), s[2].copy(n), s[3].copy(r), s[4].copy(i), s[5].copy(o), this
    }

    copy(t) {
      const e = this.planes;
      for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
      return this
    }

    setFromProjectionMatrix(t) {
      const e = this.planes, n = t.elements, r = n[0], i = n[1], o = n[2], s = n[3], a = n[4], c = n[5], l = n[6],
        u = n[7], h = n[8], f = n[9], d = n[10], p = n[11], m = n[12], v = n[13], g = n[14], y = n[15];
      return e[0].setComponents(s - r, u - a, p - h, y - m).normalize(), e[1].setComponents(s + r, u + a, p + h, y + m).normalize(), e[2].setComponents(s + i, u + c, p + f, y + v).normalize(), e[3].setComponents(s - i, u - c, p - f, y - v).normalize(), e[4].setComponents(s - o, u - l, p - d, y - g).normalize(), e[5].setComponents(s + o, u + l, p + d, y + g).normalize(), this
    }

    intersectsObject(t) {
      const e = t.geometry;
      return null === e.boundingSphere && e.computeBoundingSphere(), jn.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(jn)
    }

    intersectsSprite(t) {
      return jn.center.set(0, 0, 0), jn.radius = .7071067811865476, jn.applyMatrix4(t.matrixWorld), this.intersectsSphere(jn)
    }

    intersectsSphere(t) {
      const e = this.planes, n = t.center, r = -t.radius;
      for (let i = 0; i < 6; i++) {
        if (e[i].distanceToPoint(n) < r) return !1
      }
      return !0
    }

    intersectsBox(t) {
      const e = this.planes;
      for (let n = 0; n < 6; n++) {
        const r = e[n];
        if (In.x = r.normal.x > 0 ? t.max.x : t.min.x, In.y = r.normal.y > 0 ? t.max.y : t.min.y, In.z = r.normal.z > 0 ? t.max.z : t.min.z, r.distanceToPoint(In) < 0) return !1
      }
      return !0
    }

    containsPoint(t) {
      const e = this.planes;
      for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
      return !0
    }

    clone() {
      return (new this.constructor).copy(this)
    }
  }

  function Fn() {
    let t = null, e = !1, n = null, r = null;

    function i(e, o) {
      n(e, o), r = t.requestAnimationFrame(i)
    }

    return {
      start: function () {
        !0 !== e && null !== n && (r = t.requestAnimationFrame(i), e = !0)
      }, stop: function () {
        t.cancelAnimationFrame(r), e = !1
      }, setAnimationLoop: function (t) {
        n = t
      }, setContext: function (e) {
        t = e
      }
    }
  }

  function Un(t, e) {
    const n = e.isWebGL2, r = new WeakMap;
    return {
      get: function (t) {
        return t.isInterleavedBufferAttribute && (t = t.data), r.get(t)
      }, remove: function (e) {
        e.isInterleavedBufferAttribute && (e = e.data);
        const n = r.get(e);
        n && (t.deleteBuffer(n.buffer), r.delete(e))
      }, update: function (e, i) {
        if (e.isGLBufferAttribute) {
          const t = r.get(e);
          return void((!t || t.version < e.version) && r.set(e, {
            buffer: e.buffer,
            type: e.type,
            bytesPerElement: e.elementSize,
            version: e.version
          }))
        }
        e.isInterleavedBufferAttribute && (e = e.data);
        const o = r.get(e);
        void 0 === o ? r.set(e, function (e, r) {
          const i = e.array, o = e.usage, s = t.createBuffer();
          t.bindBuffer(r, s), t.bufferData(r, i, o), e.onUploadCallback();
          let a = 5126;
          return i instanceof Float32Array ? a = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : i instanceof Int16Array ? a = 5122 : i instanceof Uint32Array ? a = 5125 : i instanceof Int32Array ? a = 5124 : i instanceof Int8Array ? a = 5120 : i instanceof Uint8Array && (a = 5121), {
            buffer: s,
            type: a,
            bytesPerElement: i.BYTES_PER_ELEMENT,
            version: e.version
          }
        }(e, i)) : o.version < e.version && (!function (e, r, i) {
          const o = r.array, s = r.updateRange;
          t.bindBuffer(i, e), -1 === s.count ? t.bufferSubData(i, 0, o) : (n ? t.bufferSubData(i, s.offset * o.BYTES_PER_ELEMENT, o, s.offset, s.count) : t.bufferSubData(i, s.offset * o.BYTES_PER_ELEMENT, o.subarray(s.offset, s.offset + s.count)), s.count = -1)
        }(o.buffer, e, i), o.version = e.version)
      }
    }
  }

  class Gn extends sn {
    constructor(t = 1, e = 1, n = 1, r = 1) {
      super(), this.type = "PlaneGeometry", this.parameters = {
        width: t,
        height: e,
        widthSegments: n,
        heightSegments: r
      };
      const i = t / 2, o = e / 2, s = Math.floor(n), a = Math.floor(r), c = s + 1, l = a + 1, u = t / s, h = e / a,
        f = [], d = [], p = [], m = [];
      for (let v = 0; v < l; v++) {
        const t = v * h - o;
        for (let e = 0; e < c; e++) {
          const n = e * u - i;
          d.push(n, -t, 0), p.push(0, 0, 1), m.push(e / s), m.push(1 - v / a)
        }
      }
      for (let v = 0; v < a; v++) for (let t = 0; t < s; t++) {
        const e = t + c * v, n = t + c * (v + 1), r = t + 1 + c * (v + 1), i = t + 1 + c * v;
        f.push(e, n, i), f.push(n, r, i)
      }
      this.setIndex(f), this.setAttribute("position", new Je(d, 3)), this.setAttribute("normal", new Je(p, 3)), this.setAttribute("uv", new Je(m, 2))
    }
  }

  const Vn = {
    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
    alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
    begin_vertex: "vec3 transformed = vec3( position );",
    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
    bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
    color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
    color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
    color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
    color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
    fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
    lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
    lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
    map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
    normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
    clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
    transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
    transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
    uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
    uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
    normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
  }, Wn = {
    common: {
      diffuse: {value: new Ge(15658734)},
      opacity: {value: 1},
      map: {value: null},
      uvTransform: {value: new ct},
      uv2Transform: {value: new ct},
      alphaMap: {value: null}
    },
    specularmap: {specularMap: {value: null}},
    envmap: {
      envMap: {value: null},
      flipEnvMap: {value: -1},
      reflectivity: {value: 1},
      refractionRatio: {value: .98},
      maxMipLevel: {value: 0}
    },
    aomap: {aoMap: {value: null}, aoMapIntensity: {value: 1}},
    lightmap: {lightMap: {value: null}, lightMapIntensity: {value: 1}},
    emissivemap: {emissiveMap: {value: null}},
    bumpmap: {bumpMap: {value: null}, bumpScale: {value: 1}},
    normalmap: {normalMap: {value: null}, normalScale: {value: new at(1, 1)}},
    displacementmap: {displacementMap: {value: null}, displacementScale: {value: 1}, displacementBias: {value: 0}},
    roughnessmap: {roughnessMap: {value: null}},
    metalnessmap: {metalnessMap: {value: null}},
    gradientmap: {gradientMap: {value: null}},
    fog: {fogDensity: {value: 25e-5}, fogNear: {value: 1}, fogFar: {value: 2e3}, fogColor: {value: new Ge(16777215)}},
    lights: {
      ambientLightColor: {value: []},
      lightProbe: {value: []},
      directionalLights: {value: [], properties: {direction: {}, color: {}}},
      directionalLightShadows: {
        value: [],
        properties: {shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}}
      },
      directionalShadowMap: {value: []},
      directionalShadowMatrix: {value: []},
      spotLights: {
        value: [],
        properties: {color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}}
      },
      spotLightShadows: {
        value: [],
        properties: {shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}}
      },
      spotShadowMap: {value: []},
      spotShadowMatrix: {value: []},
      pointLights: {value: [], properties: {color: {}, position: {}, decay: {}, distance: {}}},
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        }
      },
      pointShadowMap: {value: []},
      pointShadowMatrix: {value: []},
      hemisphereLights: {value: [], properties: {direction: {}, skyColor: {}, groundColor: {}}},
      rectAreaLights: {value: [], properties: {color: {}, position: {}, width: {}, height: {}}},
      ltc_1: {value: null},
      ltc_2: {value: null}
    },
    points: {
      diffuse: {value: new Ge(15658734)},
      opacity: {value: 1},
      size: {value: 1},
      scale: {value: 1},
      map: {value: null},
      alphaMap: {value: null},
      uvTransform: {value: new ct}
    },
    sprite: {
      diffuse: {value: new Ge(15658734)},
      opacity: {value: 1},
      center: {value: new at(.5, .5)},
      rotation: {value: 0},
      map: {value: null},
      alphaMap: {value: null},
      uvTransform: {value: new ct}
    }
  }, Xn = {
    basic: {
      uniforms: Hn([Wn.common, Wn.specularmap, Wn.envmap, Wn.aomap, Wn.lightmap, Wn.fog]),
      vertexShader: Vn.meshbasic_vert,
      fragmentShader: Vn.meshbasic_frag
    },
    lambert: {
      uniforms: Hn([Wn.common, Wn.specularmap, Wn.envmap, Wn.aomap, Wn.lightmap, Wn.emissivemap, Wn.fog, Wn.lights, {emissive: {value: new Ge(0)}}]),
      vertexShader: Vn.meshlambert_vert,
      fragmentShader: Vn.meshlambert_frag
    },
    phong: {
      uniforms: Hn([Wn.common, Wn.specularmap, Wn.envmap, Wn.aomap, Wn.lightmap, Wn.emissivemap, Wn.bumpmap, Wn.normalmap, Wn.displacementmap, Wn.fog, Wn.lights, {
        emissive: {value: new Ge(0)},
        specular: {value: new Ge(1118481)},
        shininess: {value: 30}
      }]), vertexShader: Vn.meshphong_vert, fragmentShader: Vn.meshphong_frag
    },
    standard: {
      uniforms: Hn([Wn.common, Wn.envmap, Wn.aomap, Wn.lightmap, Wn.emissivemap, Wn.bumpmap, Wn.normalmap, Wn.displacementmap, Wn.roughnessmap, Wn.metalnessmap, Wn.fog, Wn.lights, {
        emissive: {value: new Ge(0)},
        roughness: {value: 1},
        metalness: {value: 0},
        envMapIntensity: {value: 1}
      }]), vertexShader: Vn.meshphysical_vert, fragmentShader: Vn.meshphysical_frag
    },
    toon: {
      uniforms: Hn([Wn.common, Wn.aomap, Wn.lightmap, Wn.emissivemap, Wn.bumpmap, Wn.normalmap, Wn.displacementmap, Wn.gradientmap, Wn.fog, Wn.lights, {emissive: {value: new Ge(0)}}]),
      vertexShader: Vn.meshtoon_vert,
      fragmentShader: Vn.meshtoon_frag
    },
    matcap: {
      uniforms: Hn([Wn.common, Wn.bumpmap, Wn.normalmap, Wn.displacementmap, Wn.fog, {matcap: {value: null}}]),
      vertexShader: Vn.meshmatcap_vert,
      fragmentShader: Vn.meshmatcap_frag
    },
    points: {uniforms: Hn([Wn.points, Wn.fog]), vertexShader: Vn.points_vert, fragmentShader: Vn.points_frag},
    dashed: {
      uniforms: Hn([Wn.common, Wn.fog, {scale: {value: 1}, dashSize: {value: 1}, totalSize: {value: 2}}]),
      vertexShader: Vn.linedashed_vert,
      fragmentShader: Vn.linedashed_frag
    },
    depth: {uniforms: Hn([Wn.common, Wn.displacementmap]), vertexShader: Vn.depth_vert, fragmentShader: Vn.depth_frag},
    normal: {
      uniforms: Hn([Wn.common, Wn.bumpmap, Wn.normalmap, Wn.displacementmap, {opacity: {value: 1}}]),
      vertexShader: Vn.normal_vert,
      fragmentShader: Vn.normal_frag
    },
    sprite: {uniforms: Hn([Wn.sprite, Wn.fog]), vertexShader: Vn.sprite_vert, fragmentShader: Vn.sprite_frag},
    background: {
      uniforms: {uvTransform: {value: new ct}, t2D: {value: null}},
      vertexShader: Vn.background_vert,
      fragmentShader: Vn.background_frag
    },
    cube: {uniforms: Hn([Wn.envmap, {opacity: {value: 1}}]), vertexShader: Vn.cube_vert, fragmentShader: Vn.cube_frag},
    equirect: {uniforms: {tEquirect: {value: null}}, vertexShader: Vn.equirect_vert, fragmentShader: Vn.equirect_frag},
    distanceRGBA: {
      uniforms: Hn([Wn.common, Wn.displacementmap, {
        referencePosition: {value: new gt},
        nearDistance: {value: 1},
        farDistance: {value: 1e3}
      }]), vertexShader: Vn.distanceRGBA_vert, fragmentShader: Vn.distanceRGBA_frag
    },
    shadow: {
      uniforms: Hn([Wn.lights, Wn.fog, {color: {value: new Ge(0)}, opacity: {value: 1}}]),
      vertexShader: Vn.shadow_vert,
      fragmentShader: Vn.shadow_frag
    }
  };

  function qn(t, e, n, r, i) {
    const s = new Ge(0);
    let a, c, l = 0, u = null, h = 0, d = null;

    function p(t, e) {
      n.buffers.color.setClear(t.r, t.g, t.b, e, i)
    }

    return {
      getClearColor: function () {
        return s
      }, setClearColor: function (t, e = 1) {
        s.set(t), l = e, p(s, l)
      }, getClearAlpha: function () {
        return l
      }, setClearAlpha: function (t) {
        l = t, p(s, l)
      }, render: function (n, i, m, v) {
        let g = !0 === i.isScene ? i.background : null;
        g && g.isTexture && (g = e.get(g));
        const y = t.xr, _ = y.getSession && y.getSession();
        _ && "additive" === _.environmentBlendMode && (g = null), null === g ? p(s, l) : g && g.isColor && (p(g, 1), v = !0), (t.autoClear || v) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), g && (g.isCubeTexture || g.mapping === f) ? (void 0 === c && (c = new Mn(new Tn(1, 1, 1), new Pn({
          name: "BackgroundCubeMaterial",
          uniforms: On(Xn.cube.uniforms),
          vertexShader: Xn.cube.vertexShader,
          fragmentShader: Xn.cube.fragmentShader,
          side: o,
          depthTest: !1,
          depthWrite: !1,
          fog: !1
        })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function (t, e, n) {
          this.matrixWorld.copyPosition(n.matrixWorld)
        }, Object.defineProperty(c.material, "envMap", {
          get: function () {
            return this.uniforms.envMap.value
          }
        }), r.update(c)), c.material.uniforms.envMap.value = g, c.material.uniforms.flipEnvMap.value = g.isCubeTexture && g._needsFlipEnvMap ? -1 : 1, u === g && h === g.version && d === t.toneMapping || (c.material.needsUpdate = !0, u = g, h = g.version, d = t.toneMapping), n.unshift(c, c.geometry, c.material, 0, 0, null)) : g && g.isTexture && (void 0 === a && (a = new Mn(new Gn(2, 2), new Pn({
          name: "BackgroundMaterial",
          uniforms: On(Xn.background.uniforms),
          vertexShader: Xn.background.vertexShader,
          fragmentShader: Xn.background.fragmentShader,
          side: 0,
          depthTest: !1,
          depthWrite: !1,
          fog: !1
        })), a.geometry.deleteAttribute("normal"), Object.defineProperty(a.material, "map", {
          get: function () {
            return this.uniforms.t2D.value
          }
        }), r.update(a)), a.material.uniforms.t2D.value = g, !0 === g.matrixAutoUpdate && g.updateMatrix(), a.material.uniforms.uvTransform.value.copy(g.matrix), u === g && h === g.version && d === t.toneMapping || (a.material.needsUpdate = !0, u = g, h = g.version, d = t.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null))
      }
    }
  }

  function Yn(t, e, n, r) {
    const i = t.getParameter(34921), o = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
      s = r.isWebGL2 || null !== o, a = {}, c = f(null);
    let l = c;

    function u(e) {
      return r.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e)
    }

    function h(e) {
      return r.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e)
    }

    function f(t) {
      const e = [], n = [], r = [];
      for (let o = 0; o < i; o++) e[o] = 0, n[o] = 0, r[o] = 0;
      return {
        geometry: null,
        program: null,
        wireframe: !1,
        newAttributes: e,
        enabledAttributes: n,
        attributeDivisors: r,
        object: t,
        attributes: {},
        index: null
      }
    }

    function d() {
      const t = l.newAttributes;
      for (let e = 0, n = t.length; e < n; e++) t[e] = 0
    }

    function p(t) {
      m(t, 0)
    }

    function m(n, i) {
      const o = l.newAttributes, s = l.enabledAttributes, a = l.attributeDivisors;
      if (o[n] = 1, 0 === s[n] && (t.enableVertexAttribArray(n), s[n] = 1), a[n] !== i) {
        (r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), a[n] = i
      }
    }

    function v() {
      const e = l.newAttributes, n = l.enabledAttributes;
      for (let r = 0, i = n.length; r < i; r++) n[r] !== e[r] && (t.disableVertexAttribArray(r), n[r] = 0)
    }

    function g(e, n, i, o, s, a) {
      !0 !== r.isWebGL2 || 5124 !== i && 5125 !== i ? t.vertexAttribPointer(e, n, i, o, s, a) : t.vertexAttribIPointer(e, n, i, s, a)
    }

    function y() {
      _(), l !== c && (l = c, u(l.object))
    }

    function _() {
      c.geometry = null, c.program = null, c.wireframe = !1
    }

    return {
      setup: function (i, c, h, y, _) {
        let b = !1;
        if (s) {
          const e = function (e, n, i) {
            const s = !0 === i.wireframe;
            let c = a[e.id];
            void 0 === c && (c = {}, a[e.id] = c);
            let l = c[n.id];
            void 0 === l && (l = {}, c[n.id] = l);
            let u = l[s];
            void 0 === u && (u = f(r.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()), l[s] = u);
            return u
          }(y, h, c);
          l !== e && (l = e, u(l.object)), b = function (t, e) {
            const n = l.attributes, r = t.attributes;
            let i = 0;
            for (const o in r) {
              const t = n[o], e = r[o];
              if (void 0 === t) return !0;
              if (t.attribute !== e) return !0;
              if (t.data !== e.data) return !0;
              i++
            }
            return l.attributesNum !== i || l.index !== e
          }(y, _), b && function (t, e) {
            const n = {}, r = t.attributes;
            let i = 0;
            for (const o in r) {
              const t = r[o], e = {};
              e.attribute = t, t.data && (e.data = t.data), n[o] = e, i++
            }
            l.attributes = n, l.attributesNum = i, l.index = e
          }(y, _)
        } else {
          const t = !0 === c.wireframe;
          l.geometry === y.id && l.program === h.id && l.wireframe === t || (l.geometry = y.id, l.program = h.id, l.wireframe = t, b = !0)
        }
        !0 === i.isInstancedMesh && (b = !0), null !== _ && n.update(_, 34963), b && (!function (i, o, s, a) {
          if (!1 === r.isWebGL2 && (i.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
          d();
          const c = a.attributes, l = s.getAttributes(), u = o.defaultAttributeValues;
          for (const e in l) {
            const r = l[e];
            if (r >= 0) {
              const o = c[e];
              if (void 0 !== o) {
                const e = o.normalized, i = o.itemSize, s = n.get(o);
                if (void 0 === s) continue;
                const c = s.buffer, l = s.type, u = s.bytesPerElement;
                if (o.isInterleavedBufferAttribute) {
                  const n = o.data, s = n.stride, h = o.offset;
                  n && n.isInstancedInterleavedBuffer ? (m(r, n.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)) : p(r), t.bindBuffer(34962, c), g(r, i, l, e, s * u, h * u)
                } else o.isInstancedBufferAttribute ? (m(r, o.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count)) : p(r), t.bindBuffer(34962, c), g(r, i, l, e, 0, 0)
              } else if ("instanceMatrix" === e) {
                const e = n.get(i.instanceMatrix);
                if (void 0 === e) continue;
                const o = e.buffer, s = e.type;
                m(r + 0, 1), m(r + 1, 1), m(r + 2, 1), m(r + 3, 1), t.bindBuffer(34962, o), t.vertexAttribPointer(r + 0, 4, s, !1, 64, 0), t.vertexAttribPointer(r + 1, 4, s, !1, 64, 16), t.vertexAttribPointer(r + 2, 4, s, !1, 64, 32), t.vertexAttribPointer(r + 3, 4, s, !1, 64, 48)
              } else if ("instanceColor" === e) {
                const e = n.get(i.instanceColor);
                if (void 0 === e) continue;
                const o = e.buffer, s = e.type;
                m(r, 1), t.bindBuffer(34962, o), t.vertexAttribPointer(r, 3, s, !1, 12, 0)
              } else if (void 0 !== u) {
                const n = u[e];
                if (void 0 !== n) switch (n.length) {
                  case 2:
                    t.vertexAttrib2fv(r, n);
                    break;
                  case 3:
                    t.vertexAttrib3fv(r, n);
                    break;
                  case 4:
                    t.vertexAttrib4fv(r, n);
                    break;
                  default:
                    t.vertexAttrib1fv(r, n)
                }
              }
            }
          }
          v()
        }(i, c, h, y), null !== _ && t.bindBuffer(34963, n.get(_).buffer))
      }, reset: y, resetDefaultState: _, dispose: function () {
        y();
        for (const t in a) {
          const e = a[t];
          for (const t in e) {
            const n = e[t];
            for (const t in n) h(n[t].object), delete n[t];
            delete e[t]
          }
          delete a[t]
        }
      }, releaseStatesOfGeometry: function (t) {
        if (void 0 === a[t.id]) return;
        const e = a[t.id];
        for (const n in e) {
          const t = e[n];
          for (const e in t) h(t[e].object), delete t[e];
          delete e[n]
        }
        delete a[t.id]
      }, releaseStatesOfProgram: function (t) {
        for (const e in a) {
          const n = a[e];
          if (void 0 === n[t.id]) continue;
          const r = n[t.id];
          for (const t in r) h(r[t].object), delete r[t];
          delete n[t.id]
        }
      }, initAttributes: d, enableAttribute: p, disableUnusedAttributes: v
    }
  }

  function Zn(t, e, n, r) {
    const i = r.isWebGL2;
    let o;
    this.setMode = function (t) {
      o = t
    }, this.render = function (e, r) {
      t.drawArrays(o, e, r), n.update(r, o, 1)
    }, this.renderInstances = function (r, s, a) {
      if (0 === a) return;
      let c, l;
      if (i) c = t, l = "drawArraysInstanced"; else if (c = e.get("ANGLE_instanced_arrays"), l = "drawArraysInstancedANGLE", null === c) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      c[l](o, r, s, a), n.update(s, o, a)
    }
  }

  function Jn(t, e, n) {
    let r;

    function i(e) {
      if ("highp" === e) {
        if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
        e = "mediump"
      }
      return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
    }

    const o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
    let s = void 0 !== n.precision ? n.precision : "highp";
    const a = i(s);
    a !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."), s = a);
    const c = !0 === n.logarithmicDepthBuffer, l = t.getParameter(34930), u = t.getParameter(35660),
      h = t.getParameter(3379), f = t.getParameter(34076), d = t.getParameter(34921), p = t.getParameter(36347),
      m = t.getParameter(36348), v = t.getParameter(36349), g = u > 0, y = o || e.has("OES_texture_float");
    return {
      isWebGL2: o,
      getMaxAnisotropy: function () {
        if (void 0 !== r) return r;
        if (!0 === e.has("EXT_texture_filter_anisotropic")) {
          const n = e.get("EXT_texture_filter_anisotropic");
          r = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else r = 0;
        return r
      },
      getMaxPrecision: i,
      precision: s,
      logarithmicDepthBuffer: c,
      maxTextures: l,
      maxVertexTextures: u,
      maxTextureSize: h,
      maxCubemapSize: f,
      maxAttributes: d,
      maxVertexUniforms: p,
      maxVaryings: m,
      maxFragmentUniforms: v,
      vertexTextures: g,
      floatFragmentTextures: y,
      floatVertexTextures: g && y,
      maxSamples: o ? t.getParameter(36183) : 0
    }
  }

  function Kn(t) {
    const e = this;
    let n = null, r = 0, i = !1, o = !1;
    const s = new Se, a = new ct, c = {value: null, needsUpdate: !1};

    function l() {
      c.value !== n && (c.value = n, c.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0
    }

    function u(t, n, r, i) {
      const o = null !== t ? t.length : 0;
      let l = null;
      if (0 !== o) {
        if (l = c.value, !0 !== i || null === l) {
          const e = r + 4 * o, i = n.matrixWorldInverse;
          a.getNormalMatrix(i), (null === l || l.length < e) && (l = new Float32Array(e));
          for (let n = 0, c = r; n !== o; ++n, c += 4) s.copy(t[n]).applyMatrix4(i, a), s.normal.toArray(l, c), l[c + 3] = s.constant
        }
        c.value = l, c.needsUpdate = !0
      }
      return e.numPlanes = o, e.numIntersection = 0, l
    }

    this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e, o) {
      const s = 0 !== t.length || e || 0 !== r || i;
      return i = e, n = u(t, o, 0), r = t.length, s
    }, this.beginShadows = function () {
      o = !0, u(null)
    }, this.endShadows = function () {
      o = !1, l()
    }, this.setState = function (e, s, a) {
      const h = e.clippingPlanes, f = e.clipIntersection, d = e.clipShadows, p = t.get(e);
      if (!i || null === h || 0 === h.length || o && !d) o ? u(null) : l(); else {
        const t = o ? 0 : r, e = 4 * t;
        let i = p.clippingState || null;
        c.value = i, i = u(h, s, e, a);
        for (let r = 0; r !== e; ++r) i[r] = n[r];
        p.clippingState = i, this.numIntersection = f ? this.numPlanes : 0, this.numPlanes += t
      }
    }
  }

  function Qn(t) {
    let e = new WeakMap;

    function n(t, e) {
      return 303 === e ? t.mapping = u : 304 === e && (t.mapping = h), t
    }

    function r(t) {
      const n = t.target;
      n.removeEventListener("dispose", r);
      const i = e.get(n);
      void 0 !== i && (e.delete(n), i.dispose())
    }

    return {
      get: function (i) {
        if (i && i.isTexture) {
          const o = i.mapping;
          if (303 === o || 304 === o) {
            if (e.has(i)) {
              return n(e.get(i).texture, i.mapping)
            }
            {
              const o = i.image;
              if (o && o.height > 0) {
                const s = t.getRenderTarget(), a = new Nn(o.height / 2);
                return a.fromEquirectangularTexture(t, i), e.set(i, a), t.setRenderTarget(s), i.addEventListener("dispose", r), n(a.texture, i.mapping)
              }
              return null
            }
          }
        }
        return i
      }, dispose: function () {
        e = new WeakMap
      }
    }
  }

  function $n(t) {
    const e = {};

    function n(n) {
      if (void 0 !== e[n]) return e[n];
      let r;
      switch (n) {
        case"WEBGL_depth_texture":
          r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case"EXT_texture_filter_anisotropic":
          r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case"WEBGL_compressed_texture_s3tc":
          r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case"WEBGL_compressed_texture_pvrtc":
          r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          r = t.getExtension(n)
      }
      return e[n] = r, r
    }

    return {
      has: function (t) {
        return null !== n(t)
      }, init: function (t) {
        t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float")
      }, get: function (t) {
        const e = n(t);
        return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
      }
    }
  }

  function tr(t, e, n, r) {
    const i = {}, o = new WeakMap;

    function s(t) {
      const a = t.target;
      null !== a.index && e.remove(a.index);
      for (const n in a.attributes) e.remove(a.attributes[n]);
      a.removeEventListener("dispose", s), delete i[a.id];
      const c = o.get(a);
      c && (e.remove(c), o.delete(a)), r.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
    }

    function a(t) {
      const n = [], r = t.index, i = t.attributes.position;
      let s = 0;
      if (null !== r) {
        const t = r.array;
        s = r.version;
        for (let e = 0, r = t.length; e < r; e += 3) {
          const r = t[e + 0], i = t[e + 1], o = t[e + 2];
          n.push(r, i, i, o, o, r)
        }
      } else {
        const t = i.array;
        s = i.version;
        for (let e = 0, r = t.length / 3 - 1; e < r; e += 3) {
          const t = e + 0, r = e + 1, i = e + 2;
          n.push(t, r, r, i, i, t)
        }
      }
      const a = new (Ke(n) > 65535 ? Ze : Ye)(n, 1);
      a.version = s;
      const c = o.get(t);
      c && e.remove(c), o.set(t, a)
    }

    return {
      get: function (t, e) {
        return !0 === i[e.id] || (e.addEventListener("dispose", s), i[e.id] = !0, n.memory.geometries++), e
      }, update: function (t) {
        const n = t.attributes;
        for (const i in n) e.update(n[i], 34962);
        const r = t.morphAttributes;
        for (const i in r) {
          const t = r[i];
          for (let n = 0, r = t.length; n < r; n++) e.update(t[n], 34962)
        }
      }, getWireframeAttribute: function (t) {
        const e = o.get(t);
        if (e) {
          const n = t.index;
          null !== n && e.version < n.version && a(t)
        } else a(t);
        return o.get(t)
      }
    }
  }

  function er(t, e, n, r) {
    const i = r.isWebGL2;
    let o, s, a;
    this.setMode = function (t) {
      o = t
    }, this.setIndex = function (t) {
      s = t.type, a = t.bytesPerElement
    }, this.render = function (e, r) {
      t.drawElements(o, r, s, e * a), n.update(r, o, 1)
    }, this.renderInstances = function (r, c, l) {
      if (0 === l) return;
      let u, h;
      if (i) u = t, h = "drawElementsInstanced"; else if (u = e.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === u) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      u[h](o, c, s, r * a, l), n.update(c, o, l)
    }
  }

  function nr() {
    const t = {frame: 0, calls: 0, triangles: 0, points: 0, lines: 0};
    return {
      memory: {geometries: 0, textures: 0}, render: t, programs: null, autoReset: !0, reset: function () {
        t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
      }, update: function (e, n, r) {
        switch (t.calls++, n) {
          case 4:
            t.triangles += r * (e / 3);
            break;
          case 1:
            t.lines += r * (e / 2);
            break;
          case 3:
            t.lines += r * (e - 1);
            break;
          case 2:
            t.lines += r * e;
            break;
          case 0:
            t.points += r * e;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", n)
        }
      }
    }
  }

  function rr(t, e) {
    return t[0] - e[0]
  }

  function ir(t, e) {
    return Math.abs(e[1]) - Math.abs(t[1])
  }

  function or(t) {
    const e = {}, n = new Float32Array(8), r = [];
    for (let i = 0; i < 8; i++) r[i] = [i, 0];
    return {
      update: function (i, o, s, a) {
        const c = i.morphTargetInfluences, l = void 0 === c ? 0 : c.length;
        let u = e[o.id];
        if (void 0 === u) {
          u = [];
          for (let t = 0; t < l; t++) u[t] = [t, 0];
          e[o.id] = u
        }
        for (let t = 0; t < l; t++) {
          const e = u[t];
          e[0] = t, e[1] = c[t]
        }
        u.sort(ir);
        for (let t = 0; t < 8; t++) t < l && u[t][1] ? (r[t][0] = u[t][0], r[t][1] = u[t][1]) : (r[t][0] = Number.MAX_SAFE_INTEGER, r[t][1] = 0);
        r.sort(rr);
        const h = s.morphTargets && o.morphAttributes.position, f = s.morphNormals && o.morphAttributes.normal;
        let d = 0;
        for (let t = 0; t < 8; t++) {
          const e = r[t], i = e[0], s = e[1];
          i !== Number.MAX_SAFE_INTEGER && s ? (h && o.getAttribute("morphTarget" + t) !== h[i] && o.setAttribute("morphTarget" + t, h[i]), f && o.getAttribute("morphNormal" + t) !== f[i] && o.setAttribute("morphNormal" + t, f[i]), n[t] = s, d += s) : (h && !0 === o.hasAttribute("morphTarget" + t) && o.deleteAttribute("morphTarget" + t), f && !0 === o.hasAttribute("morphNormal" + t) && o.deleteAttribute("morphNormal" + t), n[t] = 0)
        }
        const p = o.morphTargetsRelative ? 1 : 1 - d;
        a.getUniforms().setValue(t, "morphTargetBaseInfluence", p), a.getUniforms().setValue(t, "morphTargetInfluences", n)
      }
    }
  }

  function sr(t, e, n, r) {
    let i = new WeakMap;

    function o(t) {
      const e = t.target;
      e.removeEventListener("dispose", o), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
    }

    return {
      update: function (t) {
        const s = r.render.frame, a = t.geometry, c = e.get(t, a);
        return i.get(c) !== s && (e.update(c), i.set(c, s)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", o) && t.addEventListener("dispose", o), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), c
      }, dispose: function () {
        i = new WeakMap
      }
    }
  }

  Xn.physical = {
    uniforms: Hn([Xn.standard.uniforms, {
      clearcoat: {value: 0},
      clearcoatMap: {value: null},
      clearcoatRoughness: {value: 0},
      clearcoatRoughnessMap: {value: null},
      clearcoatNormalScale: {value: new at(1, 1)},
      clearcoatNormalMap: {value: null},
      sheen: {value: new Ge(0)},
      transmission: {value: 0},
      transmissionMap: {value: null}
    }]), vertexShader: Vn.meshphysical_vert, fragmentShader: Vn.meshphysical_frag
  };

  class ar extends ft {
    constructor(t = null, e = 1, n = 1, r = 1) {
      super(null), this.image = {
        data: t,
        width: e,
        height: n,
        depth: r
      }, this.magFilter = g, this.minFilter = g, this.wrapR = m, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
    }
  }

  ar.prototype.isDataTexture2DArray = !0;

  class cr extends ft {
    constructor(t = null, e = 1, n = 1, r = 1) {
      super(null), this.image = {
        data: t,
        width: e,
        height: n,
        depth: r
      }, this.magFilter = g, this.minFilter = g, this.wrapR = m, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
    }
  }

  cr.prototype.isDataTexture3D = !0;
  const lr = new ft, ur = new ar, hr = new cr, fr = new Dn, dr = [], pr = [], mr = new Float32Array(16),
    vr = new Float32Array(9), gr = new Float32Array(4);

  function yr(t, e, n) {
    const r = t[0];
    if (r <= 0 || r > 0) return t;
    const i = e * n;
    let o = dr[i];
    if (void 0 === o && (o = new Float32Array(i), dr[i] = o), 0 !== e) {
      r.toArray(o, 0);
      for (let r = 1, i = 0; r !== e; ++r) i += n, t[r].toArray(o, i)
    }
    return o
  }

  function _r(t, e) {
    if (t.length !== e.length) return !1;
    for (let n = 0, r = t.length; n < r; n++) if (t[n] !== e[n]) return !1;
    return !0
  }

  function br(t, e) {
    for (let n = 0, r = e.length; n < r; n++) t[n] = e[n]
  }

  function xr(t, e) {
    let n = pr[e];
    void 0 === n && (n = new Int32Array(e), pr[e] = n);
    for (let r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit();
    return n
  }

  function wr(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
  }

  function Sr(t, e) {
    const n = this.cache;
    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y); else {
      if (_r(n, e)) return;
      t.uniform2fv(this.addr, e), br(n, e)
    }
  }

  function Mr(t, e) {
    const n = this.cache;
    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z); else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b); else {
      if (_r(n, e)) return;
      t.uniform3fv(this.addr, e), br(n, e)
    }
  }

  function Er(t, e) {
    const n = this.cache;
    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w); else {
      if (_r(n, e)) return;
      t.uniform4fv(this.addr, e), br(n, e)
    }
  }

  function Tr(t, e) {
    const n = this.cache, r = e.elements;
    if (void 0 === r) {
      if (_r(n, e)) return;
      t.uniformMatrix2fv(this.addr, !1, e), br(n, e)
    } else {
      if (_r(n, r)) return;
      gr.set(r), t.uniformMatrix2fv(this.addr, !1, gr), br(n, r)
    }
  }

  function Or(t, e) {
    const n = this.cache, r = e.elements;
    if (void 0 === r) {
      if (_r(n, e)) return;
      t.uniformMatrix3fv(this.addr, !1, e), br(n, e)
    } else {
      if (_r(n, r)) return;
      vr.set(r), t.uniformMatrix3fv(this.addr, !1, vr), br(n, r)
    }
  }

  function Hr(t, e) {
    const n = this.cache, r = e.elements;
    if (void 0 === r) {
      if (_r(n, e)) return;
      t.uniformMatrix4fv(this.addr, !1, e), br(n, e)
    } else {
      if (_r(n, r)) return;
      mr.set(r), t.uniformMatrix4fv(this.addr, !1, mr), br(n, r)
    }
  }

  function Ar(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
  }

  function Pr(t, e) {
    const n = this.cache;
    _r(n, e) || (t.uniform2iv(this.addr, e), br(n, e))
  }

  function Rr(t, e) {
    const n = this.cache;
    _r(n, e) || (t.uniform3iv(this.addr, e), br(n, e))
  }

  function Lr(t, e) {
    const n = this.cache;
    _r(n, e) || (t.uniform4iv(this.addr, e), br(n, e))
  }

  function Cr(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
  }

  function kr(t, e) {
    const n = this.cache;
    _r(n, e) || (t.uniform2uiv(this.addr, e), br(n, e))
  }

  function Dr(t, e) {
    const n = this.cache;
    _r(n, e) || (t.uniform3uiv(this.addr, e), br(n, e))
  }

  function Nr(t, e) {
    const n = this.cache;
    _r(n, e) || (t.uniform4uiv(this.addr, e), br(n, e))
  }

  function zr(t, e, n) {
    const r = this.cache, i = n.allocateTextureUnit();
    r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(e || lr, i)
  }

  function jr(t, e, n) {
    const r = this.cache, i = n.allocateTextureUnit();
    r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(e || hr, i)
  }

  function Ir(t, e, n) {
    const r = this.cache, i = n.allocateTextureUnit();
    r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(e || fr, i)
  }

  function Br(t, e, n) {
    const r = this.cache, i = n.allocateTextureUnit();
    r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(e || ur, i)
  }

  function Fr(t, e) {
    t.uniform1fv(this.addr, e)
  }

  function Ur(t, e) {
    const n = yr(e, this.size, 2);
    t.uniform2fv(this.addr, n)
  }

  function Gr(t, e) {
    const n = yr(e, this.size, 3);
    t.uniform3fv(this.addr, n)
  }

  function Vr(t, e) {
    const n = yr(e, this.size, 4);
    t.uniform4fv(this.addr, n)
  }

  function Wr(t, e) {
    const n = yr(e, this.size, 4);
    t.uniformMatrix2fv(this.addr, !1, n)
  }

  function Xr(t, e) {
    const n = yr(e, this.size, 9);
    t.uniformMatrix3fv(this.addr, !1, n)
  }

  function qr(t, e) {
    const n = yr(e, this.size, 16);
    t.uniformMatrix4fv(this.addr, !1, n)
  }

  function Yr(t, e) {
    t.uniform1iv(this.addr, e)
  }

  function Zr(t, e) {
    t.uniform2iv(this.addr, e)
  }

  function Jr(t, e) {
    t.uniform3iv(this.addr, e)
  }

  function Kr(t, e) {
    t.uniform4iv(this.addr, e)
  }

  function Qr(t, e) {
    t.uniform1uiv(this.addr, e)
  }

  function $r(t, e) {
    t.uniform2uiv(this.addr, e)
  }

  function ti(t, e) {
    t.uniform3uiv(this.addr, e)
  }

  function ei(t, e) {
    t.uniform4uiv(this.addr, e)
  }

  function ni(t, e, n) {
    const r = e.length, i = xr(n, r);
    t.uniform1iv(this.addr, i);
    for (let o = 0; o !== r; ++o) n.safeSetTexture2D(e[o] || lr, i[o])
  }

  function ri(t, e, n) {
    const r = e.length, i = xr(n, r);
    t.uniform1iv(this.addr, i);
    for (let o = 0; o !== r; ++o) n.safeSetTextureCube(e[o] || fr, i[o])
  }

  function ii(t, e, n) {
    this.id = t, this.addr = n, this.cache = [], this.setValue = function (t) {
      switch (t) {
        case 5126:
          return wr;
        case 35664:
          return Sr;
        case 35665:
          return Mr;
        case 35666:
          return Er;
        case 35674:
          return Tr;
        case 35675:
          return Or;
        case 35676:
          return Hr;
        case 5124:
        case 35670:
          return Ar;
        case 35667:
        case 35671:
          return Pr;
        case 35668:
        case 35672:
          return Rr;
        case 35669:
        case 35673:
          return Lr;
        case 5125:
          return Cr;
        case 36294:
          return kr;
        case 36295:
          return Dr;
        case 36296:
          return Nr;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return zr;
        case 35679:
        case 36299:
        case 36307:
          return jr;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return Ir;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return Br
      }
    }(e.type)
  }

  function oi(t, e, n) {
    this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function (t) {
      switch (t) {
        case 5126:
          return Fr;
        case 35664:
          return Ur;
        case 35665:
          return Gr;
        case 35666:
          return Vr;
        case 35674:
          return Wr;
        case 35675:
          return Xr;
        case 35676:
          return qr;
        case 5124:
        case 35670:
          return Yr;
        case 35667:
        case 35671:
          return Zr;
        case 35668:
        case 35672:
          return Jr;
        case 35669:
        case 35673:
          return Kr;
        case 5125:
          return Qr;
        case 36294:
          return $r;
        case 36295:
          return ti;
        case 36296:
          return ei;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return ni;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return ri
      }
    }(e.type)
  }

  function si(t) {
    this.id = t, this.seq = [], this.map = {}
  }

  oi.prototype.updateCache = function (t) {
    const e = this.cache;
    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), br(e, t)
  }, si.prototype.setValue = function (t, e, n) {
    const r = this.seq;
    for (let i = 0, o = r.length; i !== o; ++i) {
      const o = r[i];
      o.setValue(t, e[o.id], n)
    }
  };
  const ai = /(\w+)(\])?(\[|\.)?/g;

  function ci(t, e) {
    t.seq.push(e), t.map[e.id] = e
  }

  function li(t, e, n) {
    const r = t.name, i = r.length;
    for (ai.lastIndex = 0; ;) {
      const o = ai.exec(r), s = ai.lastIndex;
      let a = o[1];
      const c = "]" === o[2], l = o[3];
      if (c && (a |= 0), void 0 === l || "[" === l && s + 2 === i) {
        ci(n, void 0 === l ? new ii(a, t, e) : new oi(a, t, e));
        break
      }
      {
        let t = n.map[a];
        void 0 === t && (t = new si(a), ci(n, t)), n = t
      }
    }
  }

  function ui(t, e) {
    this.seq = [], this.map = {};
    const n = t.getProgramParameter(e, 35718);
    for (let r = 0; r < n; ++r) {
      const n = t.getActiveUniform(e, r);
      li(n, t.getUniformLocation(e, n.name), this)
    }
  }

  function hi(t, e, n) {
    const r = t.createShader(e);
    return t.shaderSource(r, n), t.compileShader(r), r
  }

  ui.prototype.setValue = function (t, e, n, r) {
    const i = this.map[e];
    void 0 !== i && i.setValue(t, n, r)
  }, ui.prototype.setOptional = function (t, e, n) {
    const r = e[n];
    void 0 !== r && this.setValue(t, n, r)
  }, ui.upload = function (t, e, n, r) {
    for (let i = 0, o = e.length; i !== o; ++i) {
      const o = e[i], s = n[o.id];
      !1 !== s.needsUpdate && o.setValue(t, s.value, r)
    }
  }, ui.seqWithValue = function (t, e) {
    const n = [];
    for (let r = 0, i = t.length; r !== i; ++r) {
      const i = t[r];
      i.id in e && n.push(i)
    }
    return n
  };
  let fi = 0;

  function di(t) {
    switch (t) {
      case B:
        return ["Linear", "( value )"];
      case F:
        return ["sRGB", "( value )"];
      case G:
        return ["RGBE", "( value )"];
      case 3004:
        return ["RGBM", "( value, 7.0 )"];
      case 3005:
        return ["RGBM", "( value, 16.0 )"];
      case 3006:
        return ["RGBD", "( value, 256.0 )"];
      case U:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      case 3003:
        return ["LogLuv", "( value )"];
      default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
    }
  }

  function pi(t, e, n) {
    const r = t.getShaderParameter(e, 35713), i = t.getShaderInfoLog(e).trim();
    if (r && "" === i) return "";
    return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + i + function (t) {
      const e = t.split("\n");
      for (let n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n];
      return e.join("\n")
    }(t.getShaderSource(e))
  }

  function mi(t, e) {
    const n = di(e);
    return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
  }

  function vi(t, e) {
    const n = di(e);
    return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
  }

  function gi(t, e) {
    let n;
    switch (e) {
      case 1:
        n = "Linear";
        break;
      case 2:
        n = "Reinhard";
        break;
      case 3:
        n = "OptimizedCineon";
        break;
      case 4:
        n = "ACESFilmic";
        break;
      case 5:
        n = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
    }
    return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
  }

  function yi(t) {
    return "" !== t
  }

  function _i(t, e) {
    return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
  }

  function bi(t, e) {
    return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
  }

  const xi = /^[ \t]*#include +<([\w\d./]+)>/gm;

  function wi(t) {
    return t.replace(xi, Si)
  }

  function Si(t, e) {
    const n = Vn[e];
    if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
    return wi(n)
  }

  const Mi = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
    Ei = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

  function Ti(t) {
    return t.replace(Ei, Hi).replace(Mi, Oi)
  }

  function Oi(t, e, n, r) {
    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Hi(t, e, n, r)
  }

  function Hi(t, e, n, r) {
    let i = "";
    for (let o = parseInt(e); o < parseInt(n); o++) i += r.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
    return i
  }

  function Ai(t) {
    let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
    return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
  }

  function Pi(t, e, n, r) {
    const i = t.getContext(), o = n.defines;
    let s = n.vertexShader, a = n.fragmentShader;
    const c = function (t) {
      let e = "SHADOWMAP_TYPE_BASIC";
      return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
    }(n), l = function (t) {
      let e = "ENVMAP_TYPE_CUBE";
      if (t.envMap) switch (t.envMapMode) {
        case u:
        case h:
          e = "ENVMAP_TYPE_CUBE";
          break;
        case f:
        case d:
          e = "ENVMAP_TYPE_CUBE_UV"
      }
      return e
    }(n), p = function (t) {
      let e = "ENVMAP_MODE_REFLECTION";
      if (t.envMap) switch (t.envMapMode) {
        case h:
        case d:
          e = "ENVMAP_MODE_REFRACTION"
      }
      return e
    }(n), m = function (t) {
      let e = "ENVMAP_BLENDING_NONE";
      if (t.envMap) switch (t.combine) {
        case 0:
          e = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case 1:
          e = "ENVMAP_BLENDING_MIX";
          break;
        case 2:
          e = "ENVMAP_BLENDING_ADD"
      }
      return e
    }(n), v = t.gammaFactor > 0 ? t.gammaFactor : 1, g = n.isWebGL2 ? "" : function (t) {
      return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(yi).join("\n")
    }(n), y = function (t) {
      const e = [];
      for (const n in t) {
        const r = t[n];
        !1 !== r && e.push("#define " + n + " " + r)
      }
      return e.join("\n")
    }(o), _ = i.createProgram();
    let b, x, w = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
    n.isRawShaderMaterial ? (b = [y].filter(yi).join("\n"), b.length > 0 && (b += "\n"), x = [g, y].filter(yi).join("\n"), x.length > 0 && (x += "\n")) : (b = [Ai(n), "#define SHADER_NAME " + n.shaderName, y, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + v, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(yi).join("\n"), x = [g, Ai(n), "#define SHADER_NAME " + n.shaderName, y, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + v, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + l : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Vn.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? gi("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", Vn.encodings_pars_fragment, n.map ? mi("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? mi("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? mi("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? mi("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? mi("lightMapTexelToLinear", n.lightMapEncoding) : "", vi("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(yi).join("\n")), s = wi(s), s = _i(s, n), s = bi(s, n), a = wi(a), a = _i(a, n), a = bi(a, n), s = Ti(s), a = Ti(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (w = "#version 300 es\n", b = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + b, x = ["#define varying in", n.glslVersion === q ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === q ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + x);
    const S = w + x + a, M = hi(i, 35633, w + b + s), E = hi(i, 35632, S);
    if (i.attachShader(_, M), i.attachShader(_, E), void 0 !== n.index0AttributeName ? i.bindAttribLocation(_, 0, n.index0AttributeName) : !0 === n.morphTargets && i.bindAttribLocation(_, 0, "position"), i.linkProgram(_), t.debug.checkShaderErrors) {
      const t = i.getProgramInfoLog(_).trim(), e = i.getShaderInfoLog(M).trim(), n = i.getShaderInfoLog(E).trim();
      let r = !0, o = !0;
      if (!1 === i.getProgramParameter(_, 35714)) {
        r = !1;
        const e = pi(i, M, "vertex"), n = pi(i, E, "fragment");
        console.error("THREE.WebGLProgram: shader error: ", i.getError(), "35715", i.getProgramParameter(_, 35715), "gl.getProgramInfoLog", t, e, n)
      } else "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== n || (o = !1);
      o && (this.diagnostics = {
        runnable: r,
        programLog: t,
        vertexShader: {log: e, prefix: b},
        fragmentShader: {log: n, prefix: x}
      })
    }
    let T, O;
    return i.deleteShader(M), i.deleteShader(E), this.getUniforms = function () {
      return void 0 === T && (T = new ui(i, _)), T
    }, this.getAttributes = function () {
      return void 0 === O && (O = function (t, e) {
        const n = {}, r = t.getProgramParameter(e, 35721);
        for (let i = 0; i < r; i++) {
          const r = t.getActiveAttrib(e, i).name;
          n[r] = t.getAttribLocation(e, r)
        }
        return n
      }(i, _)), O
    }, this.destroy = function () {
      r.releaseStatesOfProgram(this), i.deleteProgram(_), this.program = void 0
    }, this.name = n.shaderName, this.id = fi++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = M, this.fragmentShader = E, this
  }

  function Ri(t, e, n, r, i, a) {
    const c = [], l = r.isWebGL2, u = r.logarithmicDepthBuffer, h = r.floatVertexTextures, p = r.maxVertexUniforms,
      m = r.vertexTextures;
    let v = r.precision;
    const g = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
      },
      y = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];

    function _(t) {
      let e;
      return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = B, e
    }

    return {
      getParameters: function (i, c, y, b, x) {
        const w = b.fog, S = i.isMeshStandardMaterial ? b.environment : null, M = e.get(i.envMap || S), E = g[i.type],
          T = x.isSkinnedMesh ? function (t) {
            const e = t.skeleton.bones;
            if (h) return 1024;
            {
              const t = p, n = Math.floor((t - 20) / 4), r = Math.min(n, e.length);
              return r < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + r + "."), 0) : r
            }
          }(x) : 0;
        let O, H;
        if (null !== i.precision && (v = r.getMaxPrecision(i.precision), v !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", v, "instead.")), E) {
          const t = Xn[E];
          O = t.vertexShader, H = t.fragmentShader
        } else O = i.vertexShader, H = i.fragmentShader;
        const A = t.getRenderTarget();
        return {
          isWebGL2: l,
          shaderID: E,
          shaderName: i.type,
          vertexShader: O,
          fragmentShader: H,
          defines: i.defines,
          isRawShaderMaterial: !0 === i.isRawShaderMaterial,
          glslVersion: i.glslVersion,
          precision: v,
          instancing: !0 === x.isInstancedMesh,
          instancingColor: !0 === x.isInstancedMesh && null !== x.instanceColor,
          supportsVertexTextures: m,
          outputEncoding: null !== A ? _(A.texture) : t.outputEncoding,
          map: !!i.map,
          mapEncoding: _(i.map),
          matcap: !!i.matcap,
          matcapEncoding: _(i.matcap),
          envMap: !!M,
          envMapMode: M && M.mapping,
          envMapEncoding: _(M),
          envMapCubeUV: !!M && (M.mapping === f || M.mapping === d),
          lightMap: !!i.lightMap,
          lightMapEncoding: _(i.lightMap),
          aoMap: !!i.aoMap,
          emissiveMap: !!i.emissiveMap,
          emissiveMapEncoding: _(i.emissiveMap),
          bumpMap: !!i.bumpMap,
          normalMap: !!i.normalMap,
          objectSpaceNormalMap: 1 === i.normalMapType,
          tangentSpaceNormalMap: 0 === i.normalMapType,
          clearcoatMap: !!i.clearcoatMap,
          clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
          clearcoatNormalMap: !!i.clearcoatNormalMap,
          displacementMap: !!i.displacementMap,
          roughnessMap: !!i.roughnessMap,
          metalnessMap: !!i.metalnessMap,
          specularMap: !!i.specularMap,
          alphaMap: !!i.alphaMap,
          gradientMap: !!i.gradientMap,
          sheen: !!i.sheen,
          transmissionMap: !!i.transmissionMap,
          combine: i.combine,
          vertexTangents: i.normalMap && i.vertexTangents,
          vertexColors: i.vertexColors,
          vertexAlphas: !0 === i.vertexColors && x.geometry && x.geometry.attributes.color && 4 === x.geometry.attributes.color.itemSize,
          vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap || i.transmissionMap),
          uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || i.transmissionMap || !i.displacementMap),
          fog: !!w,
          useFog: i.fog,
          fogExp2: w && w.isFogExp2,
          flatShading: !!i.flatShading,
          sizeAttenuation: i.sizeAttenuation,
          logarithmicDepthBuffer: u,
          skinning: i.skinning && T > 0,
          maxBones: T,
          useVertexTexture: h,
          morphTargets: i.morphTargets,
          morphNormals: i.morphNormals,
          numDirLights: c.directional.length,
          numPointLights: c.point.length,
          numSpotLights: c.spot.length,
          numRectAreaLights: c.rectArea.length,
          numHemiLights: c.hemi.length,
          numDirLightShadows: c.directionalShadowMap.length,
          numPointLightShadows: c.pointShadowMap.length,
          numSpotLightShadows: c.spotShadowMap.length,
          numClippingPlanes: a.numPlanes,
          numClipIntersection: a.numIntersection,
          dithering: i.dithering,
          shadowMapEnabled: t.shadowMap.enabled && y.length > 0,
          shadowMapType: t.shadowMap.type,
          toneMapping: i.toneMapped ? t.toneMapping : 0,
          physicallyCorrectLights: t.physicallyCorrectLights,
          premultipliedAlpha: i.premultipliedAlpha,
          alphaTest: i.alphaTest,
          doubleSided: i.side === s,
          flipSided: i.side === o,
          depthPacking: void 0 !== i.depthPacking && i.depthPacking,
          index0AttributeName: i.index0AttributeName,
          extensionDerivatives: i.extensions && i.extensions.derivatives,
          extensionFragDepth: i.extensions && i.extensions.fragDepth,
          extensionDrawBuffers: i.extensions && i.extensions.drawBuffers,
          extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD,
          rendererExtensionFragDepth: l || n.has("EXT_frag_depth"),
          rendererExtensionDrawBuffers: l || n.has("WEBGL_draw_buffers"),
          rendererExtensionShaderTextureLod: l || n.has("EXT_shader_texture_lod"),
          customProgramCacheKey: i.customProgramCacheKey()
        }
      }, getProgramCacheKey: function (e) {
        const n = [];
        if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines) for (const t in e.defines) n.push(t), n.push(e.defines[t]);
        if (!1 === e.isRawShaderMaterial) {
          for (let t = 0; t < y.length; t++) n.push(e[y[t]]);
          n.push(t.outputEncoding), n.push(t.gammaFactor)
        }
        return n.push(e.customProgramCacheKey), n.join()
      }, getUniforms: function (t) {
        const e = g[t.type];
        let n;
        if (e) {
          const t = Xn[e];
          n = An.clone(t.uniforms)
        } else n = t.uniforms;
        return n
      }, acquireProgram: function (e, n) {
        let r;
        for (let t = 0, i = c.length; t < i; t++) {
          const e = c[t];
          if (e.cacheKey === n) {
            r = e, ++r.usedTimes;
            break
          }
        }
        return void 0 === r && (r = new Pi(t, n, e, i), c.push(r)), r
      }, releaseProgram: function (t) {
        if (0 == --t.usedTimes) {
          const e = c.indexOf(t);
          c[e] = c[c.length - 1], c.pop(), t.destroy()
        }
      }, programs: c
    }
  }

  function Li() {
    let t = new WeakMap;
    return {
      get: function (e) {
        let n = t.get(e);
        return void 0 === n && (n = {}, t.set(e, n)), n
      }, remove: function (e) {
        t.delete(e)
      }, update: function (e, n, r) {
        t.get(e)[n] = r
      }, dispose: function () {
        t = new WeakMap
      }
    }
  }

  function Ci(t, e) {
    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
  }

  function ki(t, e) {
    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
  }

  function Di(t) {
    const e = [];
    let n = 0;
    const r = [], i = [], o = {id: -1};

    function s(r, i, s, a, c, l) {
      let u = e[n];
      const h = t.get(s);
      return void 0 === u ? (u = {
        id: r.id,
        object: r,
        geometry: i,
        material: s,
        program: h.program || o,
        groupOrder: a,
        renderOrder: r.renderOrder,
        z: c,
        group: l
      }, e[n] = u) : (u.id = r.id, u.object = r, u.geometry = i, u.material = s, u.program = h.program || o, u.groupOrder = a, u.renderOrder = r.renderOrder, u.z = c, u.group = l), n++, u
    }

    return {
      opaque: r, transparent: i, init: function () {
        n = 0, r.length = 0, i.length = 0
      }, push: function (t, e, n, o, a, c) {
        const l = s(t, e, n, o, a, c);
        (!0 === n.transparent ? i : r).push(l)
      }, unshift: function (t, e, n, o, a, c) {
        const l = s(t, e, n, o, a, c);
        (!0 === n.transparent ? i : r).unshift(l)
      }, finish: function () {
        for (let t = n, r = e.length; t < r; t++) {
          const n = e[t];
          if (null === n.id) break;
          n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
        }
      }, sort: function (t, e) {
        r.length > 1 && r.sort(t || Ci), i.length > 1 && i.sort(e || ki)
      }
    }
  }

  function Ni(t) {
    let e = new WeakMap;
    return {
      get: function (n, r) {
        let i;
        return !1 === e.has(n) ? (i = new Di(t), e.set(n, [i])) : r >= e.get(n).length ? (i = new Di(t), e.get(n).push(i)) : i = e.get(n)[r], i
      }, dispose: function () {
        e = new WeakMap
      }
    }
  }

  function zi() {
    const t = {};
    return {
      get: function (e) {
        if (void 0 !== t[e.id]) return t[e.id];
        let n;
        switch (e.type) {
          case"DirectionalLight":
            n = {direction: new gt, color: new Ge};
            break;
          case"SpotLight":
            n = {position: new gt, direction: new gt, color: new Ge, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0};
            break;
          case"PointLight":
            n = {position: new gt, color: new Ge, distance: 0, decay: 0};
            break;
          case"HemisphereLight":
            n = {direction: new gt, skyColor: new Ge, groundColor: new Ge};
            break;
          case"RectAreaLight":
            n = {color: new Ge, position: new gt, halfWidth: new gt, halfHeight: new gt}
        }
        return t[e.id] = n, n
      }
    }
  }

  let ji = 0;

  function Ii(t, e) {
    return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
  }

  function Bi(t, e) {
    const n = new zi, r = function () {
      const t = {};
      return {
        get: function (e) {
          if (void 0 !== t[e.id]) return t[e.id];
          let n;
          switch (e.type) {
            case"DirectionalLight":
            case"SpotLight":
              n = {shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new at};
              break;
            case"PointLight":
              n = {
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new at,
                shadowCameraNear: 1,
                shadowCameraFar: 1e3
              }
          }
          return t[e.id] = n, n
        }
      }
    }(), i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadow: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: []
    };
    for (let c = 0; c < 9; c++) i.probe.push(new gt);
    const o = new gt, s = new Yt, a = new Yt;
    return {
      setup: function (o) {
        let s = 0, a = 0, c = 0;
        for (let t = 0; t < 9; t++) i.probe[t].set(0, 0, 0);
        let l = 0, u = 0, h = 0, f = 0, d = 0, p = 0, m = 0, v = 0;
        o.sort(Ii);
        for (let t = 0, e = o.length; t < e; t++) {
          const e = o[t], g = e.color, y = e.intensity, _ = e.distance,
            b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
          if (e.isAmbientLight) s += g.r * y, a += g.g * y, c += g.b * y; else if (e.isLightProbe) for (let t = 0; t < 9; t++) i.probe[t].addScaledVector(e.sh.coefficients[t], y); else if (e.isDirectionalLight) {
            const t = n.get(e);
            if (t.color.copy(e.color).multiplyScalar(e.intensity), e.castShadow) {
              const t = e.shadow, n = r.get(e);
              n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, i.directionalShadow[l] = n, i.directionalShadowMap[l] = b, i.directionalShadowMatrix[l] = e.shadow.matrix, p++
            }
            i.directional[l] = t, l++
          } else if (e.isSpotLight) {
            const t = n.get(e);
            if (t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(g).multiplyScalar(y), t.distance = _, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) {
              const t = e.shadow, n = r.get(e);
              n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, i.spotShadow[h] = n, i.spotShadowMap[h] = b, i.spotShadowMatrix[h] = e.shadow.matrix, v++
            }
            i.spot[h] = t, h++
          } else if (e.isRectAreaLight) {
            const t = n.get(e);
            t.color.copy(g).multiplyScalar(y), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), i.rectArea[f] = t, f++
          } else if (e.isPointLight) {
            const t = n.get(e);
            if (t.color.copy(e.color).multiplyScalar(e.intensity), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
              const t = e.shadow, n = r.get(e);
              n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, i.pointShadow[u] = n, i.pointShadowMap[u] = b, i.pointShadowMatrix[u] = e.shadow.matrix, m++
            }
            i.point[u] = t, u++
          } else if (e.isHemisphereLight) {
            const t = n.get(e);
            t.skyColor.copy(e.color).multiplyScalar(y), t.groundColor.copy(e.groundColor).multiplyScalar(y), i.hemi[d] = t, d++
          }
        }
        f > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = Wn.LTC_FLOAT_1, i.rectAreaLTC2 = Wn.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = Wn.LTC_HALF_1, i.rectAreaLTC2 = Wn.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = s, i.ambient[1] = a, i.ambient[2] = c;
        const g = i.hash;
        g.directionalLength === l && g.pointLength === u && g.spotLength === h && g.rectAreaLength === f && g.hemiLength === d && g.numDirectionalShadows === p && g.numPointShadows === m && g.numSpotShadows === v || (i.directional.length = l, i.spot.length = h, i.rectArea.length = f, i.point.length = u, i.hemi.length = d, i.directionalShadow.length = p, i.directionalShadowMap.length = p, i.pointShadow.length = m, i.pointShadowMap.length = m, i.spotShadow.length = v, i.spotShadowMap.length = v, i.directionalShadowMatrix.length = p, i.pointShadowMatrix.length = m, i.spotShadowMatrix.length = v, g.directionalLength = l, g.pointLength = u, g.spotLength = h, g.rectAreaLength = f, g.hemiLength = d, g.numDirectionalShadows = p, g.numPointShadows = m, g.numSpotShadows = v, i.version = ji++)
      }, setupView: function (t, e) {
        let n = 0, r = 0, c = 0, l = 0, u = 0;
        const h = e.matrixWorldInverse;
        for (let f = 0, d = t.length; f < d; f++) {
          const e = t[f];
          if (e.isDirectionalLight) {
            const t = i.directional[n];
            t.direction.setFromMatrixPosition(e.matrixWorld), o.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(o), t.direction.transformDirection(h), n++
          } else if (e.isSpotLight) {
            const t = i.spot[c];
            t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(h), t.direction.setFromMatrixPosition(e.matrixWorld), o.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(o), t.direction.transformDirection(h), c++
          } else if (e.isRectAreaLight) {
            const t = i.rectArea[l];
            t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(h), a.identity(), s.copy(e.matrixWorld), s.premultiply(h), a.extractRotation(s), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), l++
          } else if (e.isPointLight) {
            const t = i.point[r];
            t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(h), r++
          } else if (e.isHemisphereLight) {
            const t = i.hemi[u];
            t.direction.setFromMatrixPosition(e.matrixWorld), t.direction.transformDirection(h), t.direction.normalize(), u++
          }
        }
      }, state: i
    }
  }

  function Fi(t, e) {
    const n = new Bi(t, e), r = [], i = [];
    return {
      init: function () {
        r.length = 0, i.length = 0
      }, state: {lightsArray: r, shadowsArray: i, lights: n}, setupLights: function () {
        n.setup(r)
      }, setupLightsView: function (t) {
        n.setupView(r, t)
      }, pushLight: function (t) {
        r.push(t)
      }, pushShadow: function (t) {
        i.push(t)
      }
    }
  }

  function Ui(t, e) {
    let n = new WeakMap;
    return {
      get: function (r, i = 0) {
        let o;
        return !1 === n.has(r) ? (o = new Fi(t, e), n.set(r, [o])) : i >= n.get(r).length ? (o = new Fi(t, e), n.get(r).push(o)) : o = n.get(r)[i], o
      }, dispose: function () {
        n = new WeakMap
      }
    }
  }

  class Gi extends Ne {
    constructor(t) {
      super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
    }

    copy(t) {
      return super.copy(t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
    }
  }

  Gi.prototype.isMeshDepthMaterial = !0;

  class Vi extends Ne {
    constructor(t) {
      super(), this.type = "MeshDistanceMaterial", this.referencePosition = new gt, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
    }

    copy(t) {
      return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
    }
  }

  Vi.prototype.isMeshDistanceMaterial = !0;

  function Wi(t, e, n) {
    let r = new Bn;
    const i = new at, a = new at, c = new pt, l = [], u = [], h = {}, f = n.maxTextureSize, d = {0: o, 1: 0, 2: s},
      p = new Pn({
        defines: {SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8},
        uniforms: {shadow_pass: {value: null}, resolution: {value: new at}, radius: {value: 4}},
        vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
        fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
      }), m = p.clone();
    m.defines.HORIZONTAL_PASS = 1;
    const v = new sn;
    v.setAttribute("position", new qe(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
    const y = new Mn(v, p), _ = this;

    function x(n, r) {
      const i = e.update(y);
      p.uniforms.shadow_pass.value = n.map.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(r, null, i, p, y, null), m.uniforms.shadow_pass.value = n.mapPass.texture, m.uniforms.resolution.value = n.mapSize, m.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(r, null, i, m, y, null)
    }

    function w(t, e, n) {
      const r = t << 0 | e << 1 | n << 2;
      let i = l[r];
      return void 0 === i && (i = new Gi({depthPacking: 3201, morphTargets: t, skinning: e}), l[r] = i), i
    }

    function S(t, e, n) {
      const r = t << 0 | e << 1 | n << 2;
      let i = u[r];
      return void 0 === i && (i = new Vi({morphTargets: t, skinning: e}), u[r] = i), i
    }

    function M(e, n, r, i, o, s, a) {
      let c = null, l = w, u = e.customDepthMaterial;
      if (!0 === i.isPointLight && (l = S, u = e.customDistanceMaterial), void 0 === u) {
        let t = !1;
        !0 === r.morphTargets && (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);
        let i = !1;
        !0 === e.isSkinnedMesh && (!0 === r.skinning ? i = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e));
        c = l(t, i, !0 === e.isInstancedMesh)
      } else c = u;
      if (t.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length) {
        const t = c.uuid, e = r.uuid;
        let n = h[t];
        void 0 === n && (n = {}, h[t] = n);
        let i = n[e];
        void 0 === i && (i = c.clone(), n[e] = i), c = i
      }
      return c.visible = r.visible, c.wireframe = r.wireframe, c.side = 3 === a ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : d[r.side], c.clipShadows = r.clipShadows, c.clippingPlanes = r.clippingPlanes, c.clipIntersection = r.clipIntersection, c.wireframeLinewidth = r.wireframeLinewidth, c.linewidth = r.linewidth, !0 === i.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(i.matrixWorld), c.nearDistance = o, c.farDistance = s), c
    }

    function E(n, i, o, s, a) {
      if (!1 === n.visible) return;
      if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === a) && (!n.frustumCulled || r.intersectsObject(n))) {
        n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
        const r = e.update(n), i = n.material;
        if (Array.isArray(i)) {
          const e = r.groups;
          for (let c = 0, l = e.length; c < l; c++) {
            const l = e[c], u = i[l.materialIndex];
            if (u && u.visible) {
              const e = M(n, r, u, s, o.near, o.far, a);
              t.renderBufferDirect(o, null, r, e, n, l)
            }
          }
        } else if (i.visible) {
          const e = M(n, r, i, s, o.near, o.far, a);
          t.renderBufferDirect(o, null, r, e, n, null)
        }
      }
      const c = n.children;
      for (let t = 0, e = c.length; t < e; t++) E(c[t], i, o, s, a)
    }

    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (e, n, o) {
      if (!1 === _.enabled) return;
      if (!1 === _.autoUpdate && !1 === _.needsUpdate) return;
      if (0 === e.length) return;
      const s = t.getRenderTarget(), l = t.getActiveCubeFace(), u = t.getActiveMipmapLevel(), h = t.state;
      h.setBlending(0), h.buffers.color.setClear(1, 1, 1, 1), h.buffers.depth.setTest(!0), h.setScissorTest(!1);
      for (let d = 0, p = e.length; d < p; d++) {
        const s = e[d], l = s.shadow;
        if (void 0 === l) {
          console.warn("THREE.WebGLShadowMap:", s, "has no shadow.");
          continue
        }
        if (!1 === l.autoUpdate && !1 === l.needsUpdate) continue;
        i.copy(l.mapSize);
        const u = l.getFrameExtents();
        if (i.multiply(u), a.copy(l.mapSize), (i.x > f || i.y > f) && (i.x > f && (a.x = Math.floor(f / u.x), i.x = a.x * u.x, l.mapSize.x = a.x), i.y > f && (a.y = Math.floor(f / u.y), i.y = a.y * u.y, l.mapSize.y = a.y)), null === l.map && !l.isPointLightShadow && 3 === this.type) {
          const t = {minFilter: b, magFilter: b, format: A};
          l.map = new mt(i.x, i.y, t), l.map.texture.name = s.name + ".shadowMap", l.mapPass = new mt(i.x, i.y, t), l.camera.updateProjectionMatrix()
        }
        if (null === l.map) {
          const t = {minFilter: g, magFilter: g, format: A};
          l.map = new mt(i.x, i.y, t), l.map.texture.name = s.name + ".shadowMap", l.camera.updateProjectionMatrix()
        }
        t.setRenderTarget(l.map), t.clear();
        const p = l.getViewportCount();
        for (let t = 0; t < p; t++) {
          const e = l.getViewport(t);
          c.set(a.x * e.x, a.y * e.y, a.x * e.z, a.y * e.w), h.viewport(c), l.updateMatrices(s, t), r = l.getFrustum(), E(n, o, l.camera, s, this.type)
        }
        l.isPointLightShadow || 3 !== this.type || x(l, o), l.needsUpdate = !1
      }
      _.needsUpdate = !1, t.setRenderTarget(s, l, u)
    }
  }

  function Xi(t, e, n) {
    const r = n.isWebGL2;
    const i = new function () {
      let e = !1;
      const n = new pt;
      let r = null;
      const i = new pt(0, 0, 0, 0);
      return {
        setMask: function (n) {
          r === n || e || (t.colorMask(n, n, n, n), r = n)
        }, setLocked: function (t) {
          e = t
        }, setClear: function (e, r, o, s, a) {
          !0 === a && (e *= s, r *= s, o *= s), n.set(e, r, o, s), !1 === i.equals(n) && (t.clearColor(e, r, o, s), i.copy(n))
        }, reset: function () {
          e = !1, r = null, i.set(-1, 0, 0, 0)
        }
      }
    }, l = new function () {
      let e = !1, n = null, r = null, i = null;
      return {
        setTest: function (t) {
          t ? I(2929) : B(2929)
        }, setMask: function (r) {
          n === r || e || (t.depthMask(r), n = r)
        }, setFunc: function (e) {
          if (r !== e) {
            if (e) switch (e) {
              case 0:
                t.depthFunc(512);
                break;
              case 1:
                t.depthFunc(519);
                break;
              case 2:
                t.depthFunc(513);
                break;
              default:
                t.depthFunc(515);
                break;
              case 4:
                t.depthFunc(514);
                break;
              case 5:
                t.depthFunc(518);
                break;
              case 6:
                t.depthFunc(516);
                break;
              case 7:
                t.depthFunc(517)
            } else t.depthFunc(515);
            r = e
          }
        }, setLocked: function (t) {
          e = t
        }, setClear: function (e) {
          i !== e && (t.clearDepth(e), i = e)
        }, reset: function () {
          e = !1, n = null, r = null, i = null
        }
      }
    }, u = new function () {
      let e = !1, n = null, r = null, i = null, o = null, s = null, a = null, c = null, l = null;
      return {
        setTest: function (t) {
          e || (t ? I(2960) : B(2960))
        }, setMask: function (r) {
          n === r || e || (t.stencilMask(r), n = r)
        }, setFunc: function (e, n, s) {
          r === e && i === n && o === s || (t.stencilFunc(e, n, s), r = e, i = n, o = s)
        }, setOp: function (e, n, r) {
          s === e && a === n && c === r || (t.stencilOp(e, n, r), s = e, a = n, c = r)
        }, setLocked: function (t) {
          e = t
        }, setClear: function (e) {
          l !== e && (t.clearStencil(e), l = e)
        }, reset: function () {
          e = !1, n = null, r = null, i = null, o = null, s = null, a = null, c = null, l = null
        }
      }
    };
    let h = {}, f = null, d = {}, p = null, m = !1, v = null, g = null, y = null, _ = null, b = null, x = null,
      w = null, S = !1, M = null, E = null, T = null, O = null, H = null;
    const A = t.getParameter(35661);
    let P = !1, R = 0;
    const L = t.getParameter(7938);
    -1 !== L.indexOf("WebGL") ? (R = parseFloat(/^WebGL (\d)/.exec(L)[1]), P = R >= 1) : -1 !== L.indexOf("OpenGL ES") && (R = parseFloat(/^OpenGL ES (\d)/.exec(L)[1]), P = R >= 2);
    let C = null, k = {};
    const D = new pt(0, 0, t.canvas.width, t.canvas.height), N = new pt(0, 0, t.canvas.width, t.canvas.height);

    function z(e, n, r) {
      const i = new Uint8Array(4), o = t.createTexture();
      t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
      for (let s = 0; s < r; s++) t.texImage2D(n + s, 0, 6408, 1, 1, 0, 6408, 5121, i);
      return o
    }

    const j = {};

    function I(e) {
      !0 !== h[e] && (t.enable(e), h[e] = !0)
    }

    function B(e) {
      !1 !== h[e] && (t.disable(e), h[e] = !1)
    }

    j[3553] = z(3553, 3553, 1), j[34067] = z(34067, 34069, 6), i.setClear(0, 0, 0, 1), l.setClear(1), u.setClear(0), I(2929), l.setFunc(3), V(!1), W(1), I(2884), G(0);
    const F = {[c]: 32774, 101: 32778, 102: 32779};
    if (r) F[103] = 32775, F[104] = 32776; else {
      const t = e.get("EXT_blend_minmax");
      null !== t && (F[103] = t.MIN_EXT, F[104] = t.MAX_EXT)
    }
    const U = {
      200: 0,
      201: 1,
      202: 768,
      204: 770,
      210: 776,
      208: 774,
      206: 772,
      203: 769,
      205: 771,
      209: 775,
      207: 773
    };

    function G(e, n, r, i, o, s, l, u) {
      if (0 !== e) {
        if (!1 === m && (I(3042), m = !0), 5 === e) o = o || n, s = s || r, l = l || i, n === g && o === b || (t.blendEquationSeparate(F[n], F[o]), g = n, b = o), r === y && i === _ && s === x && l === w || (t.blendFuncSeparate(U[r], U[i], U[s], U[l]), y = r, _ = i, x = s, w = l), v = e, S = null; else if (e !== v || u !== S) {
          if (g === c && b === c || (t.blendEquation(32774), g = c, b = c), u) switch (e) {
            case 1:
              t.blendFuncSeparate(1, 771, 1, 771);
              break;
            case a:
              t.blendFunc(1, 1);
              break;
            case 3:
              t.blendFuncSeparate(0, 0, 769, 771);
              break;
            case 4:
              t.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", e)
          } else switch (e) {
            case 1:
              t.blendFuncSeparate(770, 771, 1, 771);
              break;
            case a:
              t.blendFunc(770, 1);
              break;
            case 3:
              t.blendFunc(0, 769);
              break;
            case 4:
              t.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", e)
          }
          y = null, _ = null, x = null, w = null, v = e, S = u
        }
      } else !0 === m && (B(3042), m = !1)
    }

    function V(e) {
      M !== e && (e ? t.frontFace(2304) : t.frontFace(2305), M = e)
    }

    function W(e) {
      0 !== e ? (I(2884), e !== E && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : B(2884), E = e
    }

    function X(e, n, r) {
      e ? (I(32823), O === n && H === r || (t.polygonOffset(n, r), O = n, H = r)) : B(32823)
    }

    function q(e) {
      void 0 === e && (e = 33984 + A - 1), C !== e && (t.activeTexture(e), C = e)
    }

    return {
      buffers: {color: i, depth: l, stencil: u}, enable: I, disable: B, bindFramebuffer: function (e, n) {
        null === n && null !== f && (n = f), d[e] !== n && (t.bindFramebuffer(e, n), d[e] = n, r && (36009 === e && (d[36160] = n), 36160 === e && (d[36009] = n)))
      }, bindXRFramebuffer: function (e) {
        e !== f && (t.bindFramebuffer(36160, e), f = e)
      }, useProgram: function (e) {
        return p !== e && (t.useProgram(e), p = e, !0)
      }, setBlending: G, setMaterial: function (t, e) {
        t.side === s ? B(2884) : I(2884);
        let n = t.side === o;
        e && (n = !n), V(n), 1 === t.blending && !1 === t.transparent ? G(0) : G(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), l.setFunc(t.depthFunc), l.setTest(t.depthTest), l.setMask(t.depthWrite), i.setMask(t.colorWrite);
        const r = t.stencilWrite;
        u.setTest(r), r && (u.setMask(t.stencilWriteMask), u.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), u.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), X(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? I(32926) : B(32926)
      }, setFlipSided: V, setCullFace: W, setLineWidth: function (e) {
        e !== T && (P && t.lineWidth(e), T = e)
      }, setPolygonOffset: X, setScissorTest: function (t) {
        t ? I(3089) : B(3089)
      }, activeTexture: q, bindTexture: function (e, n) {
        null === C && q();
        let r = k[C];
        void 0 === r && (r = {
          type: void 0,
          texture: void 0
        }, k[C] = r), r.type === e && r.texture === n || (t.bindTexture(e, n || j[e]), r.type = e, r.texture = n)
      }, unbindTexture: function () {
        const e = k[C];
        void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
      }, compressedTexImage2D: function () {
        try {
          t.compressedTexImage2D.apply(t, arguments)
        } catch (e) {
          console.error("THREE.WebGLState:", e)
        }
      }, texImage2D: function () {
        try {
          t.texImage2D.apply(t, arguments)
        } catch (e) {
          console.error("THREE.WebGLState:", e)
        }
      }, texImage3D: function () {
        try {
          t.texImage3D.apply(t, arguments)
        } catch (e) {
          console.error("THREE.WebGLState:", e)
        }
      }, scissor: function (e) {
        !1 === D.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), D.copy(e))
      }, viewport: function (e) {
        !1 === N.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), N.copy(e))
      }, reset: function () {
        t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === r && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), h = {}, C = null, k = {}, f = null, d = {}, p = null, m = !1, v = null, g = null, y = null, _ = null, b = null, x = null, w = null, S = !1, M = null, E = null, T = null, O = null, H = null, D.set(0, 0, t.canvas.width, t.canvas.height), N.set(0, 0, t.canvas.width, t.canvas.height), i.reset(), l.reset(), u.reset()
      }
    }
  }

  function qi(t, e, n, r, i, o, s) {
    const a = i.isWebGL2, c = i.maxTextures, l = i.maxCubemapSize, u = i.maxTextureSize, h = i.maxSamples,
      f = new WeakMap;
    let d, w = !1;
    try {
      w = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
    } catch (et) {
    }

    function P(t, e) {
      return w ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
    }

    function C(t, e, n, r) {
      let i = 1;
      if ((t.width > r || t.height > r) && (i = r / Math.max(t.width, t.height)), i < 1 || !0 === e) {
        if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
          const r = e ? ot : Math.floor, o = r(i * t.width), s = r(i * t.height);
          void 0 === d && (d = P(o, s));
          const a = n ? P(o, s) : d;
          a.width = o, a.height = s;
          return a.getContext("2d").drawImage(t, 0, 0, o, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + o + "x" + s + ")."), a
        }
        return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
      }
      return t
    }

    function k(t) {
      return rt(t.width) && rt(t.height)
    }

    function D(t, e) {
      return t.generateMipmaps && e && t.minFilter !== g && t.minFilter !== b
    }

    function N(e, n, i, o) {
      t.generateMipmap(e);
      r.get(n).__maxMipLevel = Math.log2(Math.max(i, o))
    }

    function z(n, r, i) {
      if (!1 === a) return r;
      if (null !== n) {
        if (void 0 !== t[n]) return t[n];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
      }
      let o = r;
      return 6403 === r && (5126 === i && (o = 33326), 5131 === i && (o = 33325), 5121 === i && (o = 33321)), 6407 === r && (5126 === i && (o = 34837), 5131 === i && (o = 34843), 5121 === i && (o = 32849)), 6408 === r && (5126 === i && (o = 34836), 5131 === i && (o = 34842), 5121 === i && (o = 32856)), 33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"), o
    }

    function j(t) {
      return t === g || t === y || t === _ ? 9728 : 9729
    }

    function I(e) {
      const n = e.target;
      n.removeEventListener("dispose", I), function (e) {
        const n = r.get(e);
        if (void 0 === n.__webglInit) return;
        t.deleteTexture(n.__webglTexture), r.remove(e)
      }(n), n.isVideoTexture && f.delete(n), s.memory.textures--
    }

    function B(e) {
      const n = e.target;
      n.removeEventListener("dispose", B), function (e) {
        const n = e.texture, i = r.get(e), o = r.get(n);
        if (!e) return;
        void 0 !== o.__webglTexture && t.deleteTexture(o.__webglTexture);
        e.depthTexture && e.depthTexture.dispose();
        if (e.isWebGLCubeRenderTarget) for (let r = 0; r < 6; r++) t.deleteFramebuffer(i.__webglFramebuffer[r]), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[r]); else t.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer), i.__webglMultisampledFramebuffer && t.deleteFramebuffer(i.__webglMultisampledFramebuffer), i.__webglColorRenderbuffer && t.deleteRenderbuffer(i.__webglColorRenderbuffer), i.__webglDepthRenderbuffer && t.deleteRenderbuffer(i.__webglDepthRenderbuffer);
        r.remove(n), r.remove(e)
      }(n), s.memory.textures--
    }

    let F = 0;

    function U(t, e) {
      const i = r.get(t);
      if (t.isVideoTexture && function (t) {
        const e = s.render.frame;
        f.get(t) !== e && (f.set(t, e), t.update())
      }(t), t.version > 0 && i.__version !== t.version) {
        const n = t.image;
        if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else {
          if (!1 !== n.complete) return void Y(i, t, e);
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
        }
      }
      n.activeTexture(33984 + e), n.bindTexture(3553, i.__webglTexture)
    }

    function G(e, i) {
      const s = r.get(e);
      e.version > 0 && s.__version !== e.version ? function (e, r, i) {
        if (6 !== r.image.length) return;
        q(e, r), n.activeTexture(33984 + i), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0);
        const s = r && (r.isCompressedTexture || r.image[0].isCompressedTexture),
          c = r.image[0] && r.image[0].isDataTexture, u = [];
        for (let t = 0; t < 6; t++) u[t] = s || c ? c ? r.image[t].image : r.image[t] : C(r.image[t], !1, !0, l);
        const h = u[0], f = k(h) || a, d = o.convert(r.format), p = o.convert(r.type), m = z(r.internalFormat, d, p);
        let v;
        if (X(34067, r, f), s) {
          for (let t = 0; t < 6; t++) {
            v = u[t].mipmaps;
            for (let e = 0; e < v.length; e++) {
              const i = v[e];
              r.format !== A && r.format !== H ? null !== d ? n.compressedTexImage2D(34069 + t, e, m, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, e, m, i.width, i.height, 0, d, p, i.data)
            }
          }
          e.__maxMipLevel = v.length - 1
        } else {
          v = r.mipmaps;
          for (let t = 0; t < 6; t++) if (c) {
            n.texImage2D(34069 + t, 0, m, u[t].width, u[t].height, 0, d, p, u[t].data);
            for (let e = 0; e < v.length; e++) {
              const r = v[e].image[t].image;
              n.texImage2D(34069 + t, e + 1, m, r.width, r.height, 0, d, p, r.data)
            }
          } else {
            n.texImage2D(34069 + t, 0, m, d, p, u[t]);
            for (let e = 0; e < v.length; e++) {
              const r = v[e];
              n.texImage2D(34069 + t, e + 1, m, d, p, r.image[t])
            }
          }
          e.__maxMipLevel = v.length
        }
        D(r, f) && N(34067, r, h.width, h.height);
        e.__version = r.version, r.onUpdate && r.onUpdate(r)
      }(s, e, i) : (n.activeTexture(33984 + i), n.bindTexture(34067, s.__webglTexture))
    }

    const V = {[p]: 10497, [m]: 33071, [v]: 33648},
      W = {[g]: 9728, [y]: 9984, [_]: 9986, [b]: 9729, 1007: 9985, [x]: 9987};

    function X(n, o, s) {
      if (s ? (t.texParameteri(n, 10242, V[o.wrapS]), t.texParameteri(n, 10243, V[o.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, V[o.wrapR]), t.texParameteri(n, 10240, W[o.magFilter]), t.texParameteri(n, 10241, W[o.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), o.wrapS === m && o.wrapT === m || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, j(o.magFilter)), t.texParameteri(n, 10241, j(o.minFilter)), o.minFilter !== g && o.minFilter !== b && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
        const s = e.get("EXT_texture_filter_anisotropic");
        if (o.type === E && !1 === e.has("OES_texture_float_linear")) return;
        if (!1 === a && o.type === T && !1 === e.has("OES_texture_half_float_linear")) return;
        (o.anisotropy > 1 || r.get(o).__currentAnisotropy) && (t.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, i.getMaxAnisotropy())), r.get(o).__currentAnisotropy = o.anisotropy)
      }
    }

    function q(e, n) {
      void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", I), e.__webglTexture = t.createTexture(), s.memory.textures++)
    }

    function Y(e, r, i) {
      let s = 3553;
      r.isDataTexture2DArray && (s = 35866), r.isDataTexture3D && (s = 32879), q(e, r), n.activeTexture(33984 + i), n.bindTexture(s, e.__webglTexture), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0);
      const c = function (t) {
        return !a && (t.wrapS !== m || t.wrapT !== m || t.minFilter !== g && t.minFilter !== b)
      }(r) && !1 === k(r.image), l = C(r.image, c, !1, u), h = k(l) || a, f = o.convert(r.format);
      let d, p = o.convert(r.type), v = z(r.internalFormat, f, p);
      X(s, r, h);
      const y = r.mipmaps;
      if (r.isDepthTexture) v = 6402, a ? v = r.type === E ? 36012 : r.type === M ? 33190 : r.type === O ? 35056 : 33189 : r.type === E && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === R && 6402 === v && r.type !== S && r.type !== M && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = S, p = o.convert(r.type)), r.format === L && 6402 === v && (v = 34041, r.type !== O && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = O, p = o.convert(r.type))), n.texImage2D(3553, 0, v, l.width, l.height, 0, f, p, null); else if (r.isDataTexture) if (y.length > 0 && h) {
        for (let t = 0, e = y.length; t < e; t++) d = y[t], n.texImage2D(3553, t, v, d.width, d.height, 0, f, p, d.data);
        r.generateMipmaps = !1, e.__maxMipLevel = y.length - 1
      } else n.texImage2D(3553, 0, v, l.width, l.height, 0, f, p, l.data), e.__maxMipLevel = 0; else if (r.isCompressedTexture) {
        for (let t = 0, e = y.length; t < e; t++) d = y[t], r.format !== A && r.format !== H ? null !== f ? n.compressedTexImage2D(3553, t, v, d.width, d.height, 0, d.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, v, d.width, d.height, 0, f, p, d.data);
        e.__maxMipLevel = y.length - 1
      } else if (r.isDataTexture2DArray) n.texImage3D(35866, 0, v, l.width, l.height, l.depth, 0, f, p, l.data), e.__maxMipLevel = 0; else if (r.isDataTexture3D) n.texImage3D(32879, 0, v, l.width, l.height, l.depth, 0, f, p, l.data), e.__maxMipLevel = 0; else if (y.length > 0 && h) {
        for (let t = 0, e = y.length; t < e; t++) d = y[t], n.texImage2D(3553, t, v, f, p, d);
        r.generateMipmaps = !1, e.__maxMipLevel = y.length - 1
      } else n.texImage2D(3553, 0, v, f, p, l), e.__maxMipLevel = 0;
      D(r, h) && N(s, r, l.width, l.height), e.__version = r.version, r.onUpdate && r.onUpdate(r)
    }

    function Z(e, i, s, a) {
      const c = i.texture, l = o.convert(c.format), u = o.convert(c.type), h = z(c.internalFormat, l, u);
      32879 === a || 35866 === a ? n.texImage3D(a, 0, h, i.width, i.height, i.depth, 0, l, u, null) : n.texImage2D(a, 0, h, i.width, i.height, 0, l, u, null), n.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, s, a, r.get(c).__webglTexture, 0), n.bindFramebuffer(36160, null)
    }

    function J(e, n, r) {
      if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
        let i = 33189;
        if (r) {
          const e = n.depthTexture;
          e && e.isDepthTexture && (e.type === E ? i = 36012 : e.type === M && (i = 33190));
          const r = Q(n);
          t.renderbufferStorageMultisample(36161, r, i, n.width, n.height)
        } else t.renderbufferStorage(36161, i, n.width, n.height);
        t.framebufferRenderbuffer(36160, 36096, 36161, e)
      } else if (n.depthBuffer && n.stencilBuffer) {
        if (r) {
          const e = Q(n);
          t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height)
        } else t.renderbufferStorage(36161, 34041, n.width, n.height);
        t.framebufferRenderbuffer(36160, 33306, 36161, e)
      } else {
        const e = n.texture, i = o.convert(e.format), s = o.convert(e.type), a = z(e.internalFormat, i, s);
        if (r) {
          const e = Q(n);
          t.renderbufferStorageMultisample(36161, e, a, n.width, n.height)
        } else t.renderbufferStorage(36161, a, n.width, n.height)
      }
      t.bindRenderbuffer(36161, null)
    }

    function K(e) {
      const i = r.get(e), o = !0 === e.isWebGLCubeRenderTarget;
      if (e.depthTexture) {
        if (o) throw new Error("target.depthTexture not supported in Cube render targets");
        !function (e, i) {
          if (i && i.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
          if (n.bindFramebuffer(36160, e), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), U(i.depthTexture, 0);
          const o = r.get(i.depthTexture).__webglTexture;
          if (i.depthTexture.format === R) t.framebufferTexture2D(36160, 36096, 3553, o, 0); else {
            if (i.depthTexture.format !== L) throw new Error("Unknown depthTexture format");
            t.framebufferTexture2D(36160, 33306, 3553, o, 0)
          }
        }(i.__webglFramebuffer, e)
      } else if (o) {
        i.__webglDepthbuffer = [];
        for (let r = 0; r < 6; r++) n.bindFramebuffer(36160, i.__webglFramebuffer[r]), i.__webglDepthbuffer[r] = t.createRenderbuffer(), J(i.__webglDepthbuffer[r], e, !1)
      } else n.bindFramebuffer(36160, i.__webglFramebuffer), i.__webglDepthbuffer = t.createRenderbuffer(), J(i.__webglDepthbuffer, e, !1);
      n.bindFramebuffer(36160, null)
    }

    function Q(t) {
      return a && t.isWebGLMultisampleRenderTarget ? Math.min(h, t.samples) : 0
    }

    let $ = !1, tt = !1;
    this.allocateTextureUnit = function () {
      const t = F;
      return t >= c && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + c), F += 1, t
    }, this.resetTextureUnits = function () {
      F = 0
    }, this.setTexture2D = U, this.setTexture2DArray = function (t, e) {
      const i = r.get(t);
      t.version > 0 && i.__version !== t.version ? Y(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, i.__webglTexture))
    }, this.setTexture3D = function (t, e) {
      const i = r.get(t);
      t.version > 0 && i.__version !== t.version ? Y(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, i.__webglTexture))
    }, this.setTextureCube = G, this.setupRenderTarget = function (e) {
      const i = e.texture, c = r.get(e), l = r.get(i);
      e.addEventListener("dispose", B), l.__webglTexture = t.createTexture(), l.__version = i.version, s.memory.textures++;
      const u = !0 === e.isWebGLCubeRenderTarget, h = !0 === e.isWebGLMultisampleRenderTarget,
        f = i.isDataTexture3D || i.isDataTexture2DArray, d = k(e) || a;
      if (!a || i.format !== H || i.type !== E && i.type !== T || (i.format = A, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), u) {
        c.__webglFramebuffer = [];
        for (let e = 0; e < 6; e++) c.__webglFramebuffer[e] = t.createFramebuffer()
      } else if (c.__webglFramebuffer = t.createFramebuffer(), h) if (a) {
        c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
        const r = o.convert(i.format), s = o.convert(i.type), a = z(i.internalFormat, r, s), l = Q(e);
        t.renderbufferStorageMultisample(36161, l, a, e.width, e.height), n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), J(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null)
      } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      if (u) {
        n.bindTexture(34067, l.__webglTexture), X(34067, i, d);
        for (let t = 0; t < 6; t++) Z(c.__webglFramebuffer[t], e, 36064, 34069 + t);
        D(i, d) && N(34067, i, e.width, e.height), n.bindTexture(34067, null)
      } else {
        let t = 3553;
        if (f) if (a) {
          t = i.isDataTexture3D ? 32879 : 35866
        } else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
        n.bindTexture(t, l.__webglTexture), X(t, i, d), Z(c.__webglFramebuffer, e, 36064, t), D(i, d) && N(3553, i, e.width, e.height), n.bindTexture(3553, null)
      }
      e.depthBuffer && K(e)
    }, this.updateRenderTargetMipmap = function (t) {
      const e = t.texture;
      if (D(e, k(t) || a)) {
        const i = t.isWebGLCubeRenderTarget ? 34067 : 3553, o = r.get(e).__webglTexture;
        n.bindTexture(i, o), N(i, e, t.width, t.height), n.bindTexture(i, null)
      }
    }, this.updateMultisampleRenderTarget = function (e) {
      if (e.isWebGLMultisampleRenderTarget) if (a) {
        const i = e.width, o = e.height;
        let s = 16384;
        e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024);
        const a = r.get(e);
        n.bindFramebuffer(36008, a.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, a.__webglFramebuffer), t.blitFramebuffer(0, 0, i, o, 0, 0, i, o, s, 9728), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, a.__webglMultisampledFramebuffer)
      } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
    }, this.safeSetTexture2D = function (t, e) {
      t && t.isWebGLRenderTarget && (!1 === $ && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), $ = !0), t = t.texture), U(t, e)
    }, this.safeSetTextureCube = function (t, e) {
      t && t.isWebGLCubeRenderTarget && (!1 === tt && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), tt = !0), t = t.texture), G(t, e)
    }
  }

  function Yi(t, e, n) {
    const r = n.isWebGL2;
    return {
      convert: function (t) {
        let n;
        if (t === w) return 5121;
        if (1017 === t) return 32819;
        if (1018 === t) return 32820;
        if (1019 === t) return 33635;
        if (1010 === t) return 5120;
        if (1011 === t) return 5122;
        if (t === S) return 5123;
        if (1013 === t) return 5124;
        if (t === M) return 5125;
        if (t === E) return 5126;
        if (t === T) return r ? 5131 : (n = e.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null);
        if (1021 === t) return 6406;
        if (t === H) return 6407;
        if (t === A) return 6408;
        if (1024 === t) return 6409;
        if (1025 === t) return 6410;
        if (t === R) return 6402;
        if (t === L) return 34041;
        if (1028 === t) return 6403;
        if (1029 === t) return 36244;
        if (1030 === t) return 33319;
        if (1031 === t) return 33320;
        if (1032 === t) return 36248;
        if (1033 === t) return 36249;
        if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
          if (n = e.get("WEBGL_compressed_texture_s3tc"), null === n) return null;
          if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
        }
        if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
          if (n = e.get("WEBGL_compressed_texture_pvrtc"), null === n) return null;
          if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
        }
        if (36196 === t) return n = e.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
        if ((37492 === t || 37496 === t) && (n = e.get("WEBGL_compressed_texture_etc"), null !== n)) {
          if (37492 === t) return n.COMPRESSED_RGB8_ETC2;
          if (37496 === t) return n.COMPRESSED_RGBA8_ETC2_EAC
        }
        return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? (n = e.get("WEBGL_compressed_texture_astc"), null !== n ? t : null) : 36492 === t ? (n = e.get("EXT_texture_compression_bptc"), null !== n ? t : null) : t === O ? r ? 34042 : (n = e.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
      }
    }
  }

  class Zi extends Ln {
    constructor(t = []) {
      super(), this.cameras = t
    }
  }

  Zi.prototype.isArrayCamera = !0;

  class Ji extends _e {
    constructor() {
      super(), this.type = "Group"
    }
  }

  Ji.prototype.isGroup = !0;
  const Ki = {type: "move"};

  class Qi {
    constructor() {
      this._targetRay = null, this._grip = null, this._hand = null
    }

    getHandSpace() {
      return null === this._hand && (this._hand = new Ji, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {pinching: !1}), this._hand
    }

    getTargetRaySpace() {
      return null === this._targetRay && (this._targetRay = new Ji, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new gt, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new gt), this._targetRay
    }

    getGripSpace() {
      return null === this._grip && (this._grip = new Ji, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new gt, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new gt), this._grip
    }

    dispatchEvent(t) {
      return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
    }

    disconnect(t) {
      return this.dispatchEvent({
        type: "disconnected",
        data: t
      }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
    }

    update(t, e, n) {
      let r = null, i = null, o = null;
      const s = this._targetRay, a = this._grip, c = this._hand;
      if (t && "visible-blurred" !== e.session.visibilityState) if (null !== s && (r = e.getPose(t.targetRaySpace, n), null !== r && (s.matrix.fromArray(r.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), r.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(r.linearVelocity)) : s.hasLinearVelocity = !1, r.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(r.angularVelocity)) : s.hasAngularVelocity = !1, this.dispatchEvent(Ki))), c && t.hand) {
        o = !0;
        for (const o of t.hand.values()) {
          const t = e.getJointPose(o, n);
          if (void 0 === c.joints[o.jointName]) {
            const t = new Ji;
            t.matrixAutoUpdate = !1, t.visible = !1, c.joints[o.jointName] = t, c.add(t)
          }
          const r = c.joints[o.jointName];
          null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = t.radius), r.visible = null !== t
        }
        const r = c.joints["index-finger-tip"], i = c.joints["thumb-tip"], s = r.position.distanceTo(i.position),
          a = .02, l = .005;
        c.inputState.pinching && s > a + l ? (c.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: t.handedness,
          target: this
        })) : !c.inputState.pinching && s <= a - l && (c.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: t.handedness,
          target: this
        }))
      } else null !== a && t.gripSpace && (i = e.getPose(t.gripSpace, n), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1));
      return null !== s && (s.visible = null !== r), null !== a && (a.visible = null !== i), null !== c && (c.visible = null !== o), this
    }
  }

  class $i extends Y {
    constructor(t, e) {
      super();
      const n = this, r = t.state;
      let i = null, o = 1, s = null, a = "local-floor", c = null;
      const l = [], u = new Map, h = new Ln;
      h.layers.enable(1), h.viewport = new pt;
      const f = new Ln;
      f.layers.enable(2), f.viewport = new pt;
      const d = [h, f], p = new Zi;
      p.layers.enable(1), p.layers.enable(2);
      let m = null, v = null;

      function g(t) {
        const e = u.get(t.inputSource);
        e && e.dispatchEvent({type: t.type, data: t.inputSource})
      }

      function y() {
        u.forEach((function (t, e) {
          t.disconnect(e)
        })), u.clear(), m = null, v = null, r.bindXRFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), M.stop(), n.isPresenting = !1, n.dispatchEvent({type: "sessionend"})
      }

      function _(t) {
        const e = i.inputSources;
        for (let n = 0; n < l.length; n++) u.set(e[n], l[n]);
        for (let n = 0; n < t.removed.length; n++) {
          const e = t.removed[n], r = u.get(e);
          r && (r.dispatchEvent({type: "disconnected", data: e}), u.delete(e))
        }
        for (let n = 0; n < t.added.length; n++) {
          const e = t.added[n], r = u.get(e);
          r && r.dispatchEvent({type: "connected", data: e})
        }
      }

      this.enabled = !1, this.isPresenting = !1, this.getController = function (t) {
        let e = l[t];
        return void 0 === e && (e = new Qi, l[t] = e), e.getTargetRaySpace()
      }, this.getControllerGrip = function (t) {
        let e = l[t];
        return void 0 === e && (e = new Qi, l[t] = e), e.getGripSpace()
      }, this.getHand = function (t) {
        let e = l[t];
        return void 0 === e && (e = new Qi, l[t] = e), e.getHandSpace()
      }, this.setFramebufferScaleFactor = function (t) {
        o = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
      }, this.setReferenceSpaceType = function (t) {
        a = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
      }, this.getReferenceSpace = function () {
        return s
      }, this.getSession = function () {
        return i
      }, this.setSession = async function (t) {
        if (i = t, null !== i) {
          i.addEventListener("select", g), i.addEventListener("selectstart", g), i.addEventListener("selectend", g), i.addEventListener("squeeze", g), i.addEventListener("squeezestart", g), i.addEventListener("squeezeend", g), i.addEventListener("end", y), i.addEventListener("inputsourceschange", _);
          const t = e.getContextAttributes();
          !0 !== t.xrCompatible && await e.makeXRCompatible();
          const r = {
            antialias: t.antialias,
            alpha: t.alpha,
            depth: t.depth,
            stencil: t.stencil,
            framebufferScaleFactor: o
          }, c = new XRWebGLLayer(i, e, r);
          i.updateRenderState({baseLayer: c}), s = await i.requestReferenceSpace(a), M.setContext(i), M.start(), n.isPresenting = !0, n.dispatchEvent({type: "sessionstart"})
        }
      };
      const b = new gt, x = new gt;

      function w(t, e) {
        null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
      }

      this.getCamera = function (t) {
        p.near = f.near = h.near = t.near, p.far = f.far = h.far = t.far, m === p.near && v === p.far || (i.updateRenderState({
          depthNear: p.near,
          depthFar: p.far
        }), m = p.near, v = p.far);
        const e = t.parent, n = p.cameras;
        w(p, e);
        for (let i = 0; i < n.length; i++) w(n[i], e);
        t.matrixWorld.copy(p.matrixWorld), t.matrix.copy(p.matrix), t.matrix.decompose(t.position, t.quaternion, t.scale);
        const r = t.children;
        for (let i = 0, o = r.length; i < o; i++) r[i].updateMatrixWorld(!0);
        return 2 === n.length ? function (t, e, n) {
          b.setFromMatrixPosition(e.matrixWorld), x.setFromMatrixPosition(n.matrixWorld);
          const r = b.distanceTo(x), i = e.projectionMatrix.elements, o = n.projectionMatrix.elements,
            s = i[14] / (i[10] - 1), a = i[14] / (i[10] + 1), c = (i[9] + 1) / i[5], l = (i[9] - 1) / i[5],
            u = (i[8] - 1) / i[0], h = (o[8] + 1) / o[0], f = s * u, d = s * h, p = r / (-u + h), m = p * -u;
          e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(p), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
          const v = s + p, g = a + p, y = f - m, _ = d + (r - m), w = c * a / g * v, S = l * a / g * v;
          t.projectionMatrix.makePerspective(y, _, w, S, v, g)
        }(p, h, f) : p.projectionMatrix.copy(h.projectionMatrix), p
      };
      let S = null;
      const M = new Fn;
      M.setAnimationLoop((function (t, e) {
        if (c = e.getViewerPose(s), null !== c) {
          const t = c.views, e = i.renderState.baseLayer;
          r.bindXRFramebuffer(e.framebuffer);
          let n = !1;
          t.length !== p.cameras.length && (p.cameras.length = 0, n = !0);
          for (let r = 0; r < t.length; r++) {
            const i = t[r], o = e.getViewport(i), s = d[r];
            s.matrix.fromArray(i.transform.matrix), s.projectionMatrix.fromArray(i.projectionMatrix), s.viewport.set(o.x, o.y, o.width, o.height), 0 === r && p.matrix.copy(s.matrix), !0 === n && p.cameras.push(s)
          }
        }
        const n = i.inputSources;
        for (let r = 0; r < l.length; r++) {
          const t = l[r], i = n[r];
          t.update(i, e, s)
        }
        S && S(t, e)
      })), this.setAnimationLoop = function (t) {
        S = t
      }, this.dispose = function () {
      }
    }
  }

  function to(t) {
    function e(e, n) {
      e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap);
      const r = t.get(n).envMap;
      if (r) {
        e.envMap.value = r, e.flipEnvMap.value = r.isCubeTexture && r._needsFlipEnvMap ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio;
        const i = t.get(r).__maxMipLevel;
        void 0 !== i && (e.maxMipLevel.value = i)
      }
      let i, o;
      n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? i = n.map : n.specularMap ? i = n.specularMap : n.displacementMap ? i = n.displacementMap : n.normalMap ? i = n.normalMap : n.bumpMap ? i = n.bumpMap : n.roughnessMap ? i = n.roughnessMap : n.metalnessMap ? i = n.metalnessMap : n.alphaMap ? i = n.alphaMap : n.emissiveMap ? i = n.emissiveMap : n.clearcoatMap ? i = n.clearcoatMap : n.clearcoatNormalMap ? i = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (i = n.clearcoatRoughnessMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix)), n.aoMap ? o = n.aoMap : n.lightMap && (o = n.lightMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), !0 === o.matrixAutoUpdate && o.updateMatrix(), e.uv2Transform.value.copy(o.matrix))
    }

    function n(e, n) {
      e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, n.side === o && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), n.side === o && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias);
      t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
    }

    return {
      refreshFogUniforms: function (t, e) {
        t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
      }, refreshMaterialUniforms: function (t, r, i, s) {
        r.isMeshBasicMaterial ? e(t, r) : r.isMeshLambertMaterial ? (e(t, r), function (t, e) {
          e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
        }(t, r)) : r.isMeshToonMaterial ? (e(t, r), function (t, e) {
          e.gradientMap && (t.gradientMap.value = e.gradientMap);
          e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
          e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === o && (t.bumpScale.value *= -1));
          e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === o && t.normalScale.value.negate());
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
        }(t, r)) : r.isMeshPhongMaterial ? (e(t, r), function (t, e) {
          t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
          e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === o && (t.bumpScale.value *= -1));
          e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === o && t.normalScale.value.negate());
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
        }(t, r)) : r.isMeshStandardMaterial ? (e(t, r), r.isMeshPhysicalMaterial ? function (t, e) {
          n(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen);
          e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
          e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
          e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === o && t.clearcoatNormalScale.value.negate());
          t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap)
        }(t, r) : n(t, r)) : r.isMeshMatcapMaterial ? (e(t, r), function (t, e) {
          e.matcap && (t.matcap.value = e.matcap);
          e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === o && (t.bumpScale.value *= -1));
          e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === o && t.normalScale.value.negate());
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
        }(t, r)) : r.isMeshDepthMaterial ? (e(t, r), function (t, e) {
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
        }(t, r)) : r.isMeshDistanceMaterial ? (e(t, r), function (t, e) {
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
          t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
        }(t, r)) : r.isMeshNormalMaterial ? (e(t, r), function (t, e) {
          e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === o && (t.bumpScale.value *= -1));
          e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === o && t.normalScale.value.negate());
          e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
        }(t, r)) : r.isLineBasicMaterial ? (function (t, e) {
          t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
        }(t, r), r.isLineDashedMaterial && function (t, e) {
          t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
        }(t, r)) : r.isPointsMaterial ? function (t, e, n, r) {
          t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * r, e.map && (t.map.value = e.map);
          e.alphaMap && (t.alphaMap.value = e.alphaMap);
          let i;
          e.map ? i = e.map : e.alphaMap && (i = e.alphaMap);
          void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix))
        }(t, r, i, s) : r.isSpriteMaterial ? function (t, e) {
          t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
          e.alphaMap && (t.alphaMap.value = e.alphaMap);
          let n;
          e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
          void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
        }(t, r) : r.isShadowMaterial ? (t.color.value.copy(r.color), t.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
      }
    }
  }

  function eo(t) {
    const e = void 0 !== (t = t || {}).canvas ? t.canvas : function () {
        const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
        return t.style.display = "block", t
      }(), n = void 0 !== t.context ? t.context : null, r = void 0 !== t.alpha && t.alpha,
      i = void 0 === t.depth || t.depth, o = void 0 === t.stencil || t.stencil,
      s = void 0 !== t.antialias && t.antialias, a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
      c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
      l = void 0 !== t.powerPreference ? t.powerPreference : "default",
      u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
    let h = null, f = null;
    const d = [], p = [];
    this.domElement = e, this.debug = {checkShaderErrors: !0}, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = B, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
    const m = this;
    let v = !1, g = 0, y = 0, _ = null, b = -1, x = null;
    const S = new pt, M = new pt;
    let O = null, H = e.width, P = e.height, R = 1, L = null, C = null;
    const k = new pt(0, 0, H, P), D = new pt(0, 0, H, P);
    let N = !1;
    const z = new Bn;
    let j = !1, I = !1;
    const F = new Yt, U = new gt,
      G = {background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0};

    function V() {
      return null === _ ? R : 1
    }

    let W, X, q, Y, Z, J, K, Q, $, tt, et, nt, rt, ot, st, ct, lt, ut, ht, ft, dt, mt, vt = n;

    function yt(t, n) {
      for (let r = 0; r < t.length; r++) {
        const i = t[r], o = e.getContext(i, n);
        if (null !== o) return o
      }
      return null
    }

    try {
      const t = {
        alpha: r,
        depth: i,
        stencil: o,
        antialias: s,
        premultipliedAlpha: a,
        preserveDrawingBuffer: c,
        powerPreference: l,
        failIfMajorPerformanceCaveat: u
      };
      if (e.addEventListener("webglcontextlost", xt, !1), e.addEventListener("webglcontextrestored", wt, !1), null === vt) {
        const e = ["webgl2", "webgl", "experimental-webgl"];
        if (!0 === m.isWebGL1Renderer && e.shift(), vt = yt(e, t), null === vt) throw yt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
      }
      void 0 === vt.getShaderPrecisionFormat && (vt.getShaderPrecisionFormat = function () {
        return {rangeMin: 1, rangeMax: 1, precision: 1}
      })
    } catch (kt) {
      throw console.error("THREE.WebGLRenderer: " + kt.message), kt
    }

    function _t() {
      W = new $n(vt), X = new Jn(vt, W, t), W.init(X), dt = new Yi(vt, W, X), q = new Xi(vt, W, X), Y = new nr(vt), Z = new Li, J = new qi(vt, W, q, Z, X, dt, Y), K = new Qn(m), Q = new Un(vt, X), mt = new Yn(vt, W, Q, X), $ = new tr(vt, Q, Y, mt), tt = new sr(vt, $, Q, Y), ut = new or(vt), st = new Kn(Z), et = new Ri(m, K, W, X, mt, st), nt = new to(Z), rt = new Ni(Z), ot = new Ui(W, X), lt = new qn(m, K, q, tt, a), ct = new Wi(m, tt, X), ht = new Zn(vt, W, Y, X), ft = new er(vt, W, Y, X), Y.programs = et.programs, m.capabilities = X, m.extensions = W, m.properties = Z, m.renderLists = rt, m.shadowMap = ct, m.state = q, m.info = Y
    }

    _t();
    const bt = new $i(m, vt);

    function xt(t) {
      t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), v = !0
    }

    function wt() {
      console.log("THREE.WebGLRenderer: Context Restored."), v = !1;
      const t = Y.autoReset, e = ct.enabled, n = ct.autoUpdate, r = ct.needsUpdate, i = ct.type;
      _t(), Y.autoReset = t, ct.enabled = e, ct.autoUpdate = n, ct.needsUpdate = r, ct.type = i
    }

    function St(t) {
      const e = t.target;
      e.removeEventListener("dispose", St), function (t) {
        (function (t) {
          const e = Z.get(t).programs;
          void 0 !== e && e.forEach((function (t) {
            et.releaseProgram(t)
          }))
        })(t), Z.remove(t)
      }(e)
    }

    this.xr = bt, this.getContext = function () {
      return vt
    }, this.getContextAttributes = function () {
      return vt.getContextAttributes()
    }, this.forceContextLoss = function () {
      const t = W.get("WEBGL_lose_context");
      t && t.loseContext()
    }, this.forceContextRestore = function () {
      const t = W.get("WEBGL_lose_context");
      t && t.restoreContext()
    }, this.getPixelRatio = function () {
      return R
    }, this.setPixelRatio = function (t) {
      void 0 !== t && (R = t, this.setSize(H, P, !1))
    }, this.getSize = function (t) {
      return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new at), t.set(H, P)
    }, this.setSize = function (t, n, r) {
      bt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (H = t, P = n, e.width = Math.floor(t * R), e.height = Math.floor(n * R), !1 !== r && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
    }, this.getDrawingBufferSize = function (t) {
      return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new at), t.set(H * R, P * R).floor()
    }, this.setDrawingBufferSize = function (t, n, r) {
      H = t, P = n, R = r, e.width = Math.floor(t * r), e.height = Math.floor(n * r), this.setViewport(0, 0, t, n)
    }, this.getCurrentViewport = function (t) {
      return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new pt), t.copy(S)
    }, this.getViewport = function (t) {
      return t.copy(k)
    }, this.setViewport = function (t, e, n, r) {
      t.isVector4 ? k.set(t.x, t.y, t.z, t.w) : k.set(t, e, n, r), q.viewport(S.copy(k).multiplyScalar(R).floor())
    }, this.getScissor = function (t) {
      return t.copy(D)
    }, this.setScissor = function (t, e, n, r) {
      t.isVector4 ? D.set(t.x, t.y, t.z, t.w) : D.set(t, e, n, r), q.scissor(M.copy(D).multiplyScalar(R).floor())
    }, this.getScissorTest = function () {
      return N
    }, this.setScissorTest = function (t) {
      q.setScissorTest(N = t)
    }, this.setOpaqueSort = function (t) {
      L = t
    }, this.setTransparentSort = function (t) {
      C = t
    }, this.getClearColor = function (t) {
      return void 0 === t && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"), t = new Ge), t.copy(lt.getClearColor())
    }, this.setClearColor = function () {
      lt.setClearColor.apply(lt, arguments)
    }, this.getClearAlpha = function () {
      return lt.getClearAlpha()
    }, this.setClearAlpha = function () {
      lt.setClearAlpha.apply(lt, arguments)
    }, this.clear = function (t, e, n) {
      let r = 0;
      (void 0 === t || t) && (r |= 16384), (void 0 === e || e) && (r |= 256), (void 0 === n || n) && (r |= 1024), vt.clear(r)
    }, this.clearColor = function () {
      this.clear(!0, !1, !1)
    }, this.clearDepth = function () {
      this.clear(!1, !0, !1)
    }, this.clearStencil = function () {
      this.clear(!1, !1, !0)
    }, this.dispose = function () {
      e.removeEventListener("webglcontextlost", xt, !1), e.removeEventListener("webglcontextrestored", wt, !1), rt.dispose(), ot.dispose(), Z.dispose(), K.dispose(), tt.dispose(), mt.dispose(), bt.dispose(), bt.removeEventListener("sessionstart", Et), bt.removeEventListener("sessionend", Tt), Ot.stop()
    }, this.renderBufferImmediate = function (t, e) {
      mt.initAttributes();
      const n = Z.get(t);
      t.hasPositions && !n.position && (n.position = vt.createBuffer()), t.hasNormals && !n.normal && (n.normal = vt.createBuffer()), t.hasUvs && !n.uv && (n.uv = vt.createBuffer()), t.hasColors && !n.color && (n.color = vt.createBuffer());
      const r = e.getAttributes();
      t.hasPositions && (vt.bindBuffer(34962, n.position), vt.bufferData(34962, t.positionArray, 35048), mt.enableAttribute(r.position), vt.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)), t.hasNormals && (vt.bindBuffer(34962, n.normal), vt.bufferData(34962, t.normalArray, 35048), mt.enableAttribute(r.normal), vt.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (vt.bindBuffer(34962, n.uv), vt.bufferData(34962, t.uvArray, 35048), mt.enableAttribute(r.uv), vt.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)), t.hasColors && (vt.bindBuffer(34962, n.color), vt.bufferData(34962, t.colorArray, 35048), mt.enableAttribute(r.color), vt.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)), mt.disableUnusedAttributes(), vt.drawArrays(4, 0, t.count), t.count = 0
    }, this.renderBufferDirect = function (t, e, n, r, i, o) {
      null === e && (e = G);
      const s = i.isMesh && i.matrixWorld.determinant() < 0, a = Ct(t, e, r, i);
      q.setMaterial(r, s);
      let c = n.index;
      const l = n.attributes.position;
      if (null === c) {
        if (void 0 === l || 0 === l.count) return
      } else if (0 === c.count) return;
      let u, h = 1;
      !0 === r.wireframe && (c = $.getWireframeAttribute(n), h = 2), (r.morphTargets || r.morphNormals) && ut.update(i, n, r, a), mt.setup(i, r, a, n, c);
      let f = ht;
      null !== c && (u = Q.get(c), f = ft, f.setIndex(u));
      const d = null !== c ? c.count : l.count, p = n.drawRange.start * h, m = n.drawRange.count * h,
        v = null !== o ? o.start * h : 0, g = null !== o ? o.count * h : 1 / 0, y = Math.max(p, v),
        _ = Math.min(d, p + m, v + g) - 1, b = Math.max(0, _ - y + 1);
      if (0 !== b) {
        if (i.isMesh) !0 === r.wireframe ? (q.setLineWidth(r.wireframeLinewidth * V()), f.setMode(1)) : f.setMode(4); else if (i.isLine) {
          let t = r.linewidth;
          void 0 === t && (t = 1), q.setLineWidth(t * V()), i.isLineSegments ? f.setMode(1) : i.isLineLoop ? f.setMode(2) : f.setMode(3)
        } else i.isPoints ? f.setMode(0) : i.isSprite && f.setMode(4);
        if (i.isInstancedMesh) f.renderInstances(y, b, i.count); else if (n.isInstancedBufferGeometry) {
          const t = Math.min(n.instanceCount, n._maxInstanceCount);
          f.renderInstances(y, b, t)
        } else f.render(y, b)
      }
    }, this.compile = function (t, e) {
      f = ot.get(t), f.init(), t.traverseVisible((function (t) {
        t.isLight && t.layers.test(e.layers) && (f.pushLight(t), t.castShadow && f.pushShadow(t))
      })), f.setupLights(), t.traverse((function (e) {
        const n = e.material;
        if (n) if (Array.isArray(n)) for (let r = 0; r < n.length; r++) {
          Rt(n[r], t, e)
        } else Rt(n, t, e)
      }))
    };
    let Mt = null;

    function Et() {
      Ot.stop()
    }

    function Tt() {
      Ot.start()
    }

    const Ot = new Fn;

    function Ht(t, e, n, r) {
      if (!1 === t.visible) return;
      if (t.layers.test(e.layers)) if (t.isGroup) n = t.renderOrder; else if (t.isLOD) !0 === t.autoUpdate && t.update(e); else if (t.isLight) f.pushLight(t), t.castShadow && f.pushShadow(t); else if (t.isSprite) {
        if (!t.frustumCulled || z.intersectsSprite(t)) {
          r && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(F);
          const e = tt.update(t), i = t.material;
          i.visible && h.push(t, e, i, n, U.z, null)
        }
      } else if (t.isImmediateRenderObject) r && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(F), h.push(t, null, t.material, n, U.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== Y.render.frame && (t.skeleton.update(), t.skeleton.frame = Y.render.frame), !t.frustumCulled || z.intersectsObject(t))) {
        r && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(F);
        const e = tt.update(t), i = t.material;
        if (Array.isArray(i)) {
          const r = e.groups;
          for (let o = 0, s = r.length; o < s; o++) {
            const s = r[o], a = i[s.materialIndex];
            a && a.visible && h.push(t, e, a, n, U.z, s)
          }
        } else i.visible && h.push(t, e, i, n, U.z, null)
      }
      const i = t.children;
      for (let o = 0, s = i.length; o < s; o++) Ht(i[o], e, n, r)
    }

    function At(t, e, n) {
      const r = !0 === e.isScene ? e.overrideMaterial : null;
      for (let i = 0, o = t.length; i < o; i++) {
        const o = t[i], s = o.object, a = o.geometry, c = null === r ? o.material : r, l = o.group;
        if (n.isArrayCamera) {
          const t = n.cameras;
          for (let n = 0, r = t.length; n < r; n++) {
            const r = t[n];
            s.layers.test(r.layers) && (q.viewport(S.copy(r.viewport)), f.setupLightsView(r), Pt(s, e, r, a, c, l))
          }
        } else Pt(s, e, n, a, c, l)
      }
    }

    function Pt(t, e, n, r, i, o) {
      if (t.onBeforeRender(m, e, n, r, i, o), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
        const r = Ct(n, e, i, t);
        q.setMaterial(i), mt.reset(), function (t, e) {
          t.render((function (t) {
            m.renderBufferImmediate(t, e)
          }))
        }(t, r)
      } else m.renderBufferDirect(n, e, r, i, t, o);
      t.onAfterRender(m, e, n, r, i, o)
    }

    function Rt(t, e, n) {
      !0 !== e.isScene && (e = G);
      const r = Z.get(t), i = f.state.lights, o = f.state.shadowsArray, s = i.state.version,
        a = et.getParameters(t, i.state, o, e, n), c = et.getProgramCacheKey(a);
      let l = r.programs;
      r.environment = t.isMeshStandardMaterial ? e.environment : null, r.fog = e.fog, r.envMap = K.get(t.envMap || r.environment), void 0 === l && (t.addEventListener("dispose", St), l = new Map, r.programs = l);
      let u = l.get(c);
      if (void 0 !== u) {
        if (r.currentProgram === u && r.lightsStateVersion === s) return Lt(t, a), u
      } else a.uniforms = et.getUniforms(t), t.onBuild(a, m), t.onBeforeCompile(a, m), u = et.acquireProgram(a, c), l.set(c, u), r.uniforms = a.uniforms;
      const h = r.uniforms;
      (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (h.clippingPlanes = st.uniform), Lt(t, a), r.needsLights = function (t) {
        return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
      }(t), r.lightsStateVersion = s, r.needsLights && (h.ambientLightColor.value = i.state.ambient, h.lightProbe.value = i.state.probe, h.directionalLights.value = i.state.directional, h.directionalLightShadows.value = i.state.directionalShadow, h.spotLights.value = i.state.spot, h.spotLightShadows.value = i.state.spotShadow, h.rectAreaLights.value = i.state.rectArea, h.ltc_1.value = i.state.rectAreaLTC1, h.ltc_2.value = i.state.rectAreaLTC2, h.pointLights.value = i.state.point, h.pointLightShadows.value = i.state.pointShadow, h.hemisphereLights.value = i.state.hemi, h.directionalShadowMap.value = i.state.directionalShadowMap, h.directionalShadowMatrix.value = i.state.directionalShadowMatrix, h.spotShadowMap.value = i.state.spotShadowMap, h.spotShadowMatrix.value = i.state.spotShadowMatrix, h.pointShadowMap.value = i.state.pointShadowMap, h.pointShadowMatrix.value = i.state.pointShadowMatrix);
      const d = u.getUniforms(), p = ui.seqWithValue(d.seq, h);
      return r.currentProgram = u, r.uniformsList = p, u
    }

    function Lt(t, e) {
      const n = Z.get(t);
      n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas
    }

    function Ct(t, e, n, r) {
      !0 !== e.isScene && (e = G), J.resetTextureUnits();
      const i = e.fog, o = n.isMeshStandardMaterial ? e.environment : null,
        s = null === _ ? m.outputEncoding : _.texture.encoding, a = K.get(n.envMap || o),
        c = !0 === n.vertexColors && r.geometry && r.geometry.attributes.color && 4 === r.geometry.attributes.color.itemSize,
        l = Z.get(n), u = f.state.lights;
      if (!0 === j && (!0 === I || t !== x)) {
        const e = t === x && n.id === b;
        st.setState(n, t, e)
      }
      let h = !1;
      n.version === l.__version ? l.needsLights && l.lightsStateVersion !== u.state.version || l.outputEncoding !== s || r.isInstancedMesh && !1 === l.instancing ? h = !0 : r.isInstancedMesh || !0 !== l.instancing ? l.envMap !== a || n.fog && l.fog !== i ? h = !0 : void 0 === l.numClippingPlanes || l.numClippingPlanes === st.numPlanes && l.numIntersection === st.numIntersection ? l.vertexAlphas !== c && (h = !0) : h = !0 : h = !0 : (h = !0, l.__version = n.version);
      let d = l.currentProgram;
      !0 === h && (d = Rt(n, e, r));
      let p = !1, v = !1, g = !1;
      const y = d.getUniforms(), w = l.uniforms;
      if (q.useProgram(d.program) && (p = !0, v = !0, g = !0), n.id !== b && (b = n.id, v = !0), p || x !== t) {
        if (y.setValue(vt, "projectionMatrix", t.projectionMatrix), X.logarithmicDepthBuffer && y.setValue(vt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), x !== t && (x = t, v = !0, g = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
          const e = y.map.cameraPosition;
          void 0 !== e && e.setValue(vt, U.setFromMatrixPosition(t.matrixWorld))
        }
        (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && y.setValue(vt, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && y.setValue(vt, "viewMatrix", t.matrixWorldInverse)
      }
      if (n.skinning) {
        y.setOptional(vt, r, "bindMatrix"), y.setOptional(vt, r, "bindMatrixInverse");
        const t = r.skeleton;
        if (t) {
          const e = t.bones;
          if (X.floatVertexTextures) {
            if (null === t.boneTexture) {
              let n = Math.sqrt(4 * e.length);
              n = it(n), n = Math.max(n, 4);
              const r = new Float32Array(n * n * 4);
              r.set(t.boneMatrices);
              const i = new zn(r, n, n, A, E);
              t.boneMatrices = r, t.boneTexture = i, t.boneTextureSize = n
            }
            y.setValue(vt, "boneTexture", t.boneTexture, J), y.setValue(vt, "boneTextureSize", t.boneTextureSize)
          } else y.setOptional(vt, t, "boneMatrices")
        }
      }
      var S, M;
      return (v || l.receiveShadow !== r.receiveShadow) && (l.receiveShadow = r.receiveShadow, y.setValue(vt, "receiveShadow", r.receiveShadow)), v && (y.setValue(vt, "toneMappingExposure", m.toneMappingExposure), l.needsLights && (M = g, (S = w).ambientLightColor.needsUpdate = M, S.lightProbe.needsUpdate = M, S.directionalLights.needsUpdate = M, S.directionalLightShadows.needsUpdate = M, S.pointLights.needsUpdate = M, S.pointLightShadows.needsUpdate = M, S.spotLights.needsUpdate = M, S.spotLightShadows.needsUpdate = M, S.rectAreaLights.needsUpdate = M, S.hemisphereLights.needsUpdate = M), i && n.fog && nt.refreshFogUniforms(w, i), nt.refreshMaterialUniforms(w, n, R, P), ui.upload(vt, l.uniformsList, w, J)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (ui.upload(vt, l.uniformsList, w, J), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && y.setValue(vt, "center", r.center), y.setValue(vt, "modelViewMatrix", r.modelViewMatrix), y.setValue(vt, "normalMatrix", r.normalMatrix), y.setValue(vt, "modelMatrix", r.matrixWorld), d
    }

    Ot.setAnimationLoop((function (t) {
      Mt && Mt(t)
    })), "undefined" != typeof window && Ot.setContext(window), this.setAnimationLoop = function (t) {
      Mt = t, bt.setAnimationLoop(t), null === t ? Ot.stop() : Ot.start()
    }, bt.addEventListener("sessionstart", Et), bt.addEventListener("sessionend", Tt), this.render = function (t, e) {
      let n, r;
      if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), r = arguments[3]), void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      if (!0 === v) return;
      !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === bt.enabled && !0 === bt.isPresenting && (e = bt.getCamera(e)), !0 === t.isScene && t.onBeforeRender(m, t, e, n || _), f = ot.get(t, p.length), f.init(), p.push(f), F.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), z.setFromProjectionMatrix(F), I = this.localClippingEnabled, j = st.init(this.clippingPlanes, I, e), h = rt.get(t, d.length), h.init(), d.push(h), Ht(t, e, 0, m.sortObjects), h.finish(), !0 === m.sortObjects && h.sort(L, C), !0 === j && st.beginShadows();
      const i = f.state.shadowsArray;
      ct.render(i, t, e), f.setupLights(), f.setupLightsView(e), !0 === j && st.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), lt.render(h, t, e, r);
      const o = h.opaque, s = h.transparent;
      o.length > 0 && At(o, t, e), s.length > 0 && At(s, t, e), null !== _ && (J.updateRenderTargetMipmap(_), J.updateMultisampleRenderTarget(_)), !0 === t.isScene && t.onAfterRender(m, t, e), q.buffers.depth.setTest(!0), q.buffers.depth.setMask(!0), q.buffers.color.setMask(!0), q.setPolygonOffset(!1), mt.resetDefaultState(), b = -1, x = null, p.pop(), f = p.length > 0 ? p[p.length - 1] : null, d.pop(), h = d.length > 0 ? d[d.length - 1] : null
    }, this.getActiveCubeFace = function () {
      return g
    }, this.getActiveMipmapLevel = function () {
      return y
    }, this.getRenderTarget = function () {
      return _
    }, this.setRenderTarget = function (t, e = 0, n = 0) {
      _ = t, g = e, y = n, t && void 0 === Z.get(t).__webglFramebuffer && J.setupRenderTarget(t);
      let r = null, i = !1, o = !1;
      if (t) {
        const n = t.texture;
        (n.isDataTexture3D || n.isDataTexture2DArray) && (o = !0);
        const s = Z.get(t).__webglFramebuffer;
        t.isWebGLCubeRenderTarget ? (r = s[e], i = !0) : r = t.isWebGLMultisampleRenderTarget ? Z.get(t).__webglMultisampledFramebuffer : s, S.copy(t.viewport), M.copy(t.scissor), O = t.scissorTest
      } else S.copy(k).multiplyScalar(R).floor(), M.copy(D).multiplyScalar(R).floor(), O = N;
      if (q.bindFramebuffer(36160, r), q.viewport(S), q.scissor(M), q.setScissorTest(O), i) {
        const r = Z.get(t.texture);
        vt.framebufferTexture2D(36160, 36064, 34069 + e, r.__webglTexture, n)
      } else if (o) {
        const r = Z.get(t.texture), i = e || 0;
        vt.framebufferTextureLayer(36160, 36064, r.__webglTexture, n || 0, i)
      }
    }, this.readRenderTargetPixels = function (t, e, n, r, i, o, s) {
      if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let a = Z.get(t).__webglFramebuffer;
      if (t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a) {
        q.bindFramebuffer(36160, a);
        try {
          const s = t.texture, a = s.format, c = s.type;
          if (a !== A && dt.convert(a) !== vt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          const l = c === T && (W.has("EXT_color_buffer_half_float") || X.isWebGL2 && W.has("EXT_color_buffer_float"));
          if (!(c === w || dt.convert(c) === vt.getParameter(35738) || c === E && (X.isWebGL2 || W.has("OES_texture_float") || W.has("WEBGL_color_buffer_float")) || l)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          36053 === vt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - r && n >= 0 && n <= t.height - i && vt.readPixels(e, n, r, i, dt.convert(a), dt.convert(c), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
        } finally {
          const t = null !== _ ? Z.get(_).__webglFramebuffer : null;
          q.bindFramebuffer(36160, t)
        }
      }
    }, this.copyFramebufferToTexture = function (t, e, n = 0) {
      const r = Math.pow(2, -n), i = Math.floor(e.image.width * r), o = Math.floor(e.image.height * r),
        s = dt.convert(e.format);
      J.setTexture2D(e, 0), vt.copyTexImage2D(3553, n, s, t.x, t.y, i, o, 0), q.unbindTexture()
    }, this.copyTextureToTexture = function (t, e, n, r = 0) {
      const i = e.image.width, o = e.image.height, s = dt.convert(n.format), a = dt.convert(n.type);
      J.setTexture2D(n, 0), vt.pixelStorei(37440, n.flipY), vt.pixelStorei(37441, n.premultiplyAlpha), vt.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? vt.texSubImage2D(3553, r, t.x, t.y, i, o, s, a, e.image.data) : e.isCompressedTexture ? vt.compressedTexSubImage2D(3553, r, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : vt.texSubImage2D(3553, r, t.x, t.y, s, a, e.image), 0 === r && n.generateMipmaps && vt.generateMipmap(3553), q.unbindTexture()
    }, this.copyTextureToTexture3D = function (t, e, n, r, i = 0) {
      if (m.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      const {width: o, height: s, data: a} = n.image, c = dt.convert(r.format), l = dt.convert(r.type);
      let u;
      if (r.isDataTexture3D) J.setTexture3D(r, 0), u = 32879; else {
        if (!r.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        J.setTexture2DArray(r, 0), u = 35866
      }
      vt.pixelStorei(37440, r.flipY), vt.pixelStorei(37441, r.premultiplyAlpha), vt.pixelStorei(3317, r.unpackAlignment);
      const h = vt.getParameter(3314), f = vt.getParameter(32878), d = vt.getParameter(3316), p = vt.getParameter(3315),
        v = vt.getParameter(32877);
      vt.pixelStorei(3314, o), vt.pixelStorei(32878, s), vt.pixelStorei(3316, t.min.x), vt.pixelStorei(3315, t.min.y), vt.pixelStorei(32877, t.min.z), vt.texSubImage3D(u, i, e.x, e.y, e.z, t.max.x - t.min.x + 1, t.max.y - t.min.y + 1, t.max.z - t.min.z + 1, c, l, a), vt.pixelStorei(3314, h), vt.pixelStorei(32878, f), vt.pixelStorei(3316, d), vt.pixelStorei(3315, p), vt.pixelStorei(32877, v), 0 === i && r.generateMipmaps && vt.generateMipmap(u), q.unbindTexture()
    }, this.initTexture = function (t) {
      J.setTexture2D(t, 0), q.unbindTexture()
    }, this.resetState = function () {
      g = 0, y = 0, _ = null, q.reset(), mt.reset()
    }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}))
  }

  (class extends eo {
  }).prototype.isWebGL1Renderer = !0;

  class no {
    constructor(t, e = 25e-5) {
      this.name = "", this.color = new Ge(t), this.density = e
    }

    clone() {
      return new no(this.color, this.density)
    }

    toJSON() {
      return {type: "FogExp2", color: this.color.getHex(), density: this.density}
    }
  }

  no.prototype.isFogExp2 = !0;

  class ro {
    constructor(t, e = 1, n = 1e3) {
      this.name = "", this.color = new Ge(t), this.near = e, this.far = n
    }

    clone() {
      return new ro(this.color, this.near, this.far)
    }

    toJSON() {
      return {type: "Fog", color: this.color.getHex(), near: this.near, far: this.far}
    }
  }

  ro.prototype.isFog = !0;

  class io extends _e {
    constructor() {
      super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}))
    }

    copy(t, e) {
      return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
    }

    toJSON(t) {
      const e = super.toJSON(t);
      return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
    }
  }

  io.prototype.isScene = !0;

  class oo {
    constructor(t, e) {
      this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = W, this.updateRange = {
        offset: 0,
        count: -1
      }, this.version = 0, this.uuid = $(), this.onUploadCallback = function () {
      }
    }

    set needsUpdate(t) {
      !0 === t && this.version++
    }

    setUsage(t) {
      return this.usage = t, this
    }

    copy(t) {
      return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
    }

    copyAt(t, e, n) {
      t *= this.stride, n *= e.stride;
      for (let r = 0, i = this.stride; r < i; r++) this.array[t + r] = e.array[n + r];
      return this
    }

    set(t, e = 0) {
      return this.array.set(t, e), this
    }

    clone(t) {
      void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = $()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
      const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), n = new oo(e, this.stride);
      return n.setUsage(this.usage), n
    }

    onUpload(t) {
      return this.onUploadCallback = t, this
    }

    toJSON(t) {
      return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = $()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      }
    }
  }

  oo.prototype.isInterleavedBuffer = !0;
  const so = new gt;

  class ao {
    constructor(t, e, n, r) {
      this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === r
    }

    get count() {
      return this.data.count
    }

    get array() {
      return this.data.array
    }

    set needsUpdate(t) {
      this.data.needsUpdate = t
    }

    applyMatrix4(t) {
      for (let e = 0, n = this.data.count; e < n; e++) so.x = this.getX(e), so.y = this.getY(e), so.z = this.getZ(e), so.applyMatrix4(t), this.setXYZ(e, so.x, so.y, so.z);
      return this
    }

    applyNormalMatrix(t) {
      for (let e = 0, n = this.count; e < n; e++) so.x = this.getX(e), so.y = this.getY(e), so.z = this.getZ(e), so.applyNormalMatrix(t), this.setXYZ(e, so.x, so.y, so.z);
      return this
    }

    transformDirection(t) {
      for (let e = 0, n = this.count; e < n; e++) so.x = this.getX(e), so.y = this.getY(e), so.z = this.getZ(e), so.transformDirection(t), this.setXYZ(e, so.x, so.y, so.z);
      return this
    }

    setX(t, e) {
      return this.data.array[t * this.data.stride + this.offset] = e, this
    }

    setY(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 1] = e, this
    }

    setZ(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 2] = e, this
    }

    setW(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 3] = e, this
    }

    getX(t) {
      return this.data.array[t * this.data.stride + this.offset]
    }

    getY(t) {
      return this.data.array[t * this.data.stride + this.offset + 1]
    }

    getZ(t) {
      return this.data.array[t * this.data.stride + this.offset + 2]
    }

    getW(t) {
      return this.data.array[t * this.data.stride + this.offset + 3]
    }

    setXY(t, e, n) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
    }

    setXYZ(t, e, n, r) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this
    }

    setXYZW(t, e, n, r, i) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = i, this
    }

    clone(t) {
      if (void 0 === t) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
        const t = [];
        for (let e = 0; e < this.count; e++) {
          const n = e * this.data.stride + this.offset;
          for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
        }
        return new qe(new this.array.constructor(t), this.itemSize, this.normalized)
      }
      return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new ao(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
    }

    toJSON(t) {
      if (void 0 === t) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
        const t = [];
        for (let e = 0; e < this.count; e++) {
          const n = e * this.data.stride + this.offset;
          for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
        }
        return {itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized}
      }
      return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      }
    }
  }

  ao.prototype.isInterleavedBufferAttribute = !0;

  class co extends Ne {
    constructor(t) {
      super(), this.type = "SpriteMaterial", this.color = new Ge(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
    }

    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
    }
  }

  let lo;
  co.prototype.isSpriteMaterial = !0;
  const uo = new gt, ho = new gt, fo = new gt, po = new at, mo = new at, vo = new Yt, go = new gt, yo = new gt,
    _o = new gt, bo = new at, xo = new at, wo = new at;

  class So extends _e {
    constructor(t) {
      if (super(), this.type = "Sprite", void 0 === lo) {
        lo = new sn;
        const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
          e = new oo(t, 5);
        lo.setIndex([0, 1, 2, 0, 2, 3]), lo.setAttribute("position", new ao(e, 3, 0, !1)), lo.setAttribute("uv", new ao(e, 2, 3, !1))
      }
      this.geometry = lo, this.material = void 0 !== t ? t : new co, this.center = new at(.5, .5)
    }

    raycast(t, e) {
      null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), ho.setFromMatrixScale(this.matrixWorld), vo.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), fo.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && ho.multiplyScalar(-fo.z);
      const n = this.material.rotation;
      let r, i;
      0 !== n && (i = Math.cos(n), r = Math.sin(n));
      const o = this.center;
      Mo(go.set(-.5, -.5, 0), fo, o, ho, r, i), Mo(yo.set(.5, -.5, 0), fo, o, ho, r, i), Mo(_o.set(.5, .5, 0), fo, o, ho, r, i), bo.set(0, 0), xo.set(1, 0), wo.set(1, 1);
      let s = t.ray.intersectTriangle(go, yo, _o, !1, uo);
      if (null === s && (Mo(yo.set(-.5, .5, 0), fo, o, ho, r, i), xo.set(0, 1), s = t.ray.intersectTriangle(go, _o, yo, !1, uo), null === s)) return;
      const a = t.ray.origin.distanceTo(uo);
      a < t.near || a > t.far || e.push({
        distance: a,
        point: uo.clone(),
        uv: ke.getUV(uo, go, yo, _o, bo, xo, wo, new at),
        face: null,
        object: this
      })
    }

    copy(t) {
      return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
    }
  }

  function Mo(t, e, n, r, i, o) {
    po.subVectors(t, n).addScalar(.5).multiply(r), void 0 !== i ? (mo.x = o * po.x - i * po.y, mo.y = i * po.x + o * po.y) : mo.copy(po), t.copy(e), t.x += mo.x, t.y += mo.y, t.applyMatrix4(vo)
  }

  So.prototype.isSprite = !0;
  const Eo = new gt, To = new pt, Oo = new pt, Ho = new gt, Ao = new Yt;

  class Po extends Mn {
    constructor(t, e) {
      super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Yt, this.bindMatrixInverse = new Yt
    }

    copy(t) {
      return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
    }

    bind(t, e) {
      this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
    }

    pose() {
      this.skeleton.pose()
    }

    normalizeSkinWeights() {
      const t = new pt, e = this.geometry.attributes.skinWeight;
      for (let n = 0, r = e.count; n < r; n++) {
        t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
        const r = 1 / t.manhattanLength();
        r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
      }
    }

    updateMatrixWorld(t) {
      super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }

    boneTransform(t, e) {
      const n = this.skeleton, r = this.geometry;
      To.fromBufferAttribute(r.attributes.skinIndex, t), Oo.fromBufferAttribute(r.attributes.skinWeight, t), Eo.fromBufferAttribute(r.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
      for (let i = 0; i < 4; i++) {
        const t = Oo.getComponent(i);
        if (0 !== t) {
          const r = To.getComponent(i);
          Ao.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(Ho.copy(Eo).applyMatrix4(Ao), t)
        }
      }
      return e.applyMatrix4(this.bindMatrixInverse)
    }
  }

  Po.prototype.isSkinnedMesh = !0;

  class Ro extends _e {
    constructor() {
      super(), this.type = "Bone"
    }
  }

  Ro.prototype.isBone = !0;
  const Lo = new Yt, Co = new Yt, ko = [], Do = new Mn;

  class No extends Mn {
    constructor(t, e, n) {
      super(t, e), this.instanceMatrix = new qe(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
    }

    copy(t) {
      return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this
    }

    getColorAt(t, e) {
      e.fromArray(this.instanceColor.array, 3 * t)
    }

    getMatrixAt(t, e) {
      e.fromArray(this.instanceMatrix.array, 16 * t)
    }

    raycast(t, e) {
      const n = this.matrixWorld, r = this.count;
      if (Do.geometry = this.geometry, Do.material = this.material, void 0 !== Do.material) for (let i = 0; i < r; i++) {
        this.getMatrixAt(i, Lo), Co.multiplyMatrices(n, Lo), Do.matrixWorld = Co, Do.raycast(t, ko);
        for (let t = 0, n = ko.length; t < n; t++) {
          const n = ko[t];
          n.instanceId = i, n.object = this, e.push(n)
        }
        ko.length = 0
      }
    }

    setColorAt(t, e) {
      null === this.instanceColor && (this.instanceColor = new qe(new Float32Array(3 * this.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
    }

    setMatrixAt(t, e) {
      e.toArray(this.instanceMatrix.array, 16 * t)
    }

    updateMorphTargets() {
    }

    dispose() {
      this.dispatchEvent({type: "dispose"})
    }
  }

  No.prototype.isInstancedMesh = !0;

  class zo extends Ne {
    constructor(t) {
      super(), this.type = "LineBasicMaterial", this.color = new Ge(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t)
    }

    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this
    }
  }

  zo.prototype.isLineBasicMaterial = !0;
  const jo = new gt, Io = new gt, Bo = new Yt, Fo = new qt, Uo = new It;

  class Go extends _e {
    constructor(t = new sn, e = new zo) {
      super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
    }

    copy(t) {
      return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
    }

    computeLineDistances() {
      const t = this.geometry;
      if (t.isBufferGeometry) if (null === t.index) {
        const e = t.attributes.position, n = [0];
        for (let t = 1, r = e.count; t < r; t++) jo.fromBufferAttribute(e, t - 1), Io.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += jo.distanceTo(Io);
        t.setAttribute("lineDistance", new Je(n, 1))
      } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return this
    }

    raycast(t, e) {
      const n = this.geometry, r = this.matrixWorld, i = t.params.Line.threshold, o = n.drawRange;
      if (null === n.boundingSphere && n.computeBoundingSphere(), Uo.copy(n.boundingSphere), Uo.applyMatrix4(r), Uo.radius += i, !1 === t.ray.intersectsSphere(Uo)) return;
      Bo.copy(r).invert(), Fo.copy(t.ray).applyMatrix4(Bo);
      const s = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = s * s, c = new gt, l = new gt, u = new gt,
        h = new gt, f = this.isLineSegments ? 2 : 1;
      if (n.isBufferGeometry) {
        const r = n.index, i = n.attributes.position;
        if (null !== r) {
          for (let n = Math.max(0, o.start), s = Math.min(r.count, o.start + o.count) - 1; n < s; n += f) {
            const o = r.getX(n), s = r.getX(n + 1);
            c.fromBufferAttribute(i, o), l.fromBufferAttribute(i, s);
            if (Fo.distanceSqToSegment(c, l, h, u) > a) continue;
            h.applyMatrix4(this.matrixWorld);
            const f = t.ray.origin.distanceTo(h);
            f < t.near || f > t.far || e.push({
              distance: f,
              point: u.clone().applyMatrix4(this.matrixWorld),
              index: n,
              face: null,
              faceIndex: null,
              object: this
            })
          }
        } else {
          for (let n = Math.max(0, o.start), r = Math.min(i.count, o.start + o.count) - 1; n < r; n += f) {
            c.fromBufferAttribute(i, n), l.fromBufferAttribute(i, n + 1);
            if (Fo.distanceSqToSegment(c, l, h, u) > a) continue;
            h.applyMatrix4(this.matrixWorld);
            const r = t.ray.origin.distanceTo(h);
            r < t.near || r > t.far || e.push({
              distance: r,
              point: u.clone().applyMatrix4(this.matrixWorld),
              index: n,
              face: null,
              faceIndex: null,
              object: this
            })
          }
        }
      } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
    }

    updateMorphTargets() {
      const t = this.geometry;
      if (t.isBufferGeometry) {
        const e = t.morphAttributes, n = Object.keys(e);
        if (n.length > 0) {
          const t = e[n[0]];
          if (void 0 !== t) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e].name || String(e);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
            }
          }
        }
      } else {
        const e = t.morphTargets;
        void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
      }
    }
  }

  Go.prototype.isLine = !0;
  const Vo = new gt, Wo = new gt;

  class Xo extends Go {
    constructor(t, e) {
      super(t, e), this.type = "LineSegments"
    }

    computeLineDistances() {
      const t = this.geometry;
      if (t.isBufferGeometry) if (null === t.index) {
        const e = t.attributes.position, n = [];
        for (let t = 0, r = e.count; t < r; t += 2) Vo.fromBufferAttribute(e, t), Wo.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + Vo.distanceTo(Wo);
        t.setAttribute("lineDistance", new Je(n, 1))
      } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return this
    }
  }

  Xo.prototype.isLineSegments = !0;

  class qo extends Go {
    constructor(t, e) {
      super(t, e), this.type = "LineLoop"
    }
  }

  qo.prototype.isLineLoop = !0;

  class Yo extends Ne {
    constructor(t) {
      super(), this.type = "PointsMaterial", this.color = new Ge(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t)
    }

    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
    }
  }

  Yo.prototype.isPointsMaterial = !0;
  const Zo = new Yt, Jo = new qt, Ko = new It, Qo = new gt;

  class $o extends _e {
    constructor(t = new sn, e = new Yo) {
      super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
    }

    copy(t) {
      return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
    }

    raycast(t, e) {
      const n = this.geometry, r = this.matrixWorld, i = t.params.Points.threshold, o = n.drawRange;
      if (null === n.boundingSphere && n.computeBoundingSphere(), Ko.copy(n.boundingSphere), Ko.applyMatrix4(r), Ko.radius += i, !1 === t.ray.intersectsSphere(Ko)) return;
      Zo.copy(r).invert(), Jo.copy(t.ray).applyMatrix4(Zo);
      const s = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = s * s;
      if (n.isBufferGeometry) {
        const i = n.index, s = n.attributes.position;
        if (null !== i) {
          for (let n = Math.max(0, o.start), c = Math.min(i.count, o.start + o.count); n < c; n++) {
            const o = i.getX(n);
            Qo.fromBufferAttribute(s, o), ts(Qo, o, a, r, t, e, this)
          }
        } else {
          for (let n = Math.max(0, o.start), i = Math.min(s.count, o.start + o.count); n < i; n++) Qo.fromBufferAttribute(s, n), ts(Qo, n, a, r, t, e, this)
        }
      } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
    }

    updateMorphTargets() {
      const t = this.geometry;
      if (t.isBufferGeometry) {
        const e = t.morphAttributes, n = Object.keys(e);
        if (n.length > 0) {
          const t = e[n[0]];
          if (void 0 !== t) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e].name || String(e);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
            }
          }
        }
      } else {
        const e = t.morphTargets;
        void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
      }
    }
  }

  function ts(t, e, n, r, i, o, s) {
    const a = Jo.distanceSqToPoint(t);
    if (a < n) {
      const n = new gt;
      Jo.closestPointToPoint(t, n), n.applyMatrix4(r);
      const c = i.ray.origin.distanceTo(n);
      if (c < i.near || c > i.far) return;
      o.push({distance: c, distanceToRay: Math.sqrt(a), point: n, index: e, face: null, object: s})
    }
  }

  $o.prototype.isPoints = !0;

  class es extends ft {
    constructor(t, e, n, r, i, o, s, a, c) {
      super(t, e, n, r, i, o, s, a, c), this.format = void 0 !== s ? s : H, this.minFilter = void 0 !== o ? o : b, this.magFilter = void 0 !== i ? i : b, this.generateMipmaps = !1;
      const l = this;
      "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() {
        l.needsUpdate = !0, t.requestVideoFrameCallback(e)
      }))
    }

    clone() {
      return new this.constructor(this.image).copy(this)
    }

    update() {
      const t = this.image;
      !1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
  }

  es.prototype.isVideoTexture = !0;

  class ns extends ft {
    constructor(t, e, n, r, i, o, s, a, c, l, u, h) {
      super(null, o, s, a, c, l, r, i, u, h), this.image = {
        width: e,
        height: n
      }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
    }
  }

  ns.prototype.isCompressedTexture = !0;

  class rs extends ft {
    constructor(t, e, n, r, i, o, s, a, c) {
      super(t, e, n, r, i, o, s, a, c), this.needsUpdate = !0
    }
  }

  rs.prototype.isCanvasTexture = !0;
  (class extends ft {
    constructor(t, e, n, r, i, o, s, a, c, l) {
      if ((l = void 0 !== l ? l : R) !== R && l !== L) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      void 0 === n && l === R && (n = S), void 0 === n && l === L && (n = O), super(null, r, i, o, s, a, l, n, c), this.image = {
        width: t,
        height: e
      }, this.magFilter = void 0 !== s ? s : g, this.minFilter = void 0 !== a ? a : g, this.flipY = !1, this.generateMipmaps = !1
    }
  }).prototype.isDepthTexture = !0;
  new gt, new gt, new gt, new ke;
  const is = function (t, e, n) {
    n = n || 2;
    const r = e && e.length, i = r ? e[0] * n : t.length;
    let o = os(t, 0, i, n, !0);
    const s = [];
    if (!o || o.next === o.prev) return s;
    let a, c, l, u, h, f, d;
    if (r && (o = function (t, e, n, r) {
      const i = [];
      let o, s, a, c, l;
      for (o = 0, s = e.length; o < s; o++) a = e[o] * r, c = o < s - 1 ? e[o + 1] * r : t.length, l = os(t, a, c, r, !1), l === l.next && (l.steiner = !0), i.push(vs(l));
      for (i.sort(fs), o = 0; o < i.length; o++) ds(i[o], n), n = ss(n, n.next);
      return n
    }(t, e, o, n)), t.length > 80 * n) {
      a = l = t[0], c = u = t[1];
      for (let e = n; e < i; e += n) h = t[e], f = t[e + 1], h < a && (a = h), f < c && (c = f), h > l && (l = h), f > u && (u = f);
      d = Math.max(l - a, u - c), d = 0 !== d ? 1 / d : 0
    }
    return as(o, s, n, a, c, d), s
  };

  function os(t, e, n, r, i) {
    let o, s;
    if (i === function (t, e, n, r) {
      let i = 0;
      for (let o = e, s = n - r; o < n; o += r) i += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o;
      return i
    }(t, e, n, r) > 0) for (o = e; o < n; o += r) s = Ts(o, t[o], t[o + 1], s); else for (o = n - r; o >= e; o -= r) s = Ts(o, t[o], t[o + 1], s);
    return s && bs(s, s.next) && (Os(s), s = s.next), s
  }

  function ss(t, e) {
    if (!t) return t;
    e || (e = t);
    let n, r = t;
    do {
      if (n = !1, r.steiner || !bs(r, r.next) && 0 !== _s(r.prev, r, r.next)) r = r.next; else {
        if (Os(r), r = e = r.prev, r === r.next) break;
        n = !0
      }
    } while (n || r !== e);
    return e
  }

  function as(t, e, n, r, i, o, s) {
    if (!t) return;
    !s && o && function (t, e, n, r) {
      let i = t;
      do {
        null === i.z && (i.z = ms(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next
      } while (i !== t);
      i.prevZ.nextZ = null, i.prevZ = null, function (t) {
        let e, n, r, i, o, s, a, c, l = 1;
        do {
          for (n = t, t = null, o = null, s = 0; n;) {
            for (s++, r = n, a = 0, e = 0; e < l && (a++, r = r.nextZ, r); e++) ;
            for (c = l; a > 0 || c > 0 && r;) 0 !== a && (0 === c || !r || n.z <= r.z) ? (i = n, n = n.nextZ, a--) : (i = r, r = r.nextZ, c--), o ? o.nextZ = i : t = i, i.prevZ = o, o = i;
            n = r
          }
          o.nextZ = null, l *= 2
        } while (s > 1)
      }(i)
    }(t, r, i, o);
    let a, c, l = t;
    for (; t.prev !== t.next;) if (a = t.prev, c = t.next, o ? ls(t, r, i, o) : cs(t)) e.push(a.i / n), e.push(t.i / n), e.push(c.i / n), Os(t), t = c.next, l = c.next; else if ((t = c) === l) {
      s ? 1 === s ? as(t = us(ss(t), e, n), e, n, r, i, o, 2) : 2 === s && hs(t, e, n, r, i, o) : as(ss(t), e, n, r, i, o, 1);
      break
    }
  }

  function cs(t) {
    const e = t.prev, n = t, r = t.next;
    if (_s(e, n, r) >= 0) return !1;
    let i = t.next.next;
    for (; i !== t.prev;) {
      if (gs(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && _s(i.prev, i, i.next) >= 0) return !1;
      i = i.next
    }
    return !0
  }

  function ls(t, e, n, r) {
    const i = t.prev, o = t, s = t.next;
    if (_s(i, o, s) >= 0) return !1;
    const a = i.x < o.x ? i.x < s.x ? i.x : s.x : o.x < s.x ? o.x : s.x,
      c = i.y < o.y ? i.y < s.y ? i.y : s.y : o.y < s.y ? o.y : s.y,
      l = i.x > o.x ? i.x > s.x ? i.x : s.x : o.x > s.x ? o.x : s.x,
      u = i.y > o.y ? i.y > s.y ? i.y : s.y : o.y > s.y ? o.y : s.y, h = ms(a, c, e, n, r), f = ms(l, u, e, n, r);
    let d = t.prevZ, p = t.nextZ;
    for (; d && d.z >= h && p && p.z <= f;) {
      if (d !== t.prev && d !== t.next && gs(i.x, i.y, o.x, o.y, s.x, s.y, d.x, d.y) && _s(d.prev, d, d.next) >= 0) return !1;
      if (d = d.prevZ, p !== t.prev && p !== t.next && gs(i.x, i.y, o.x, o.y, s.x, s.y, p.x, p.y) && _s(p.prev, p, p.next) >= 0) return !1;
      p = p.nextZ
    }
    for (; d && d.z >= h;) {
      if (d !== t.prev && d !== t.next && gs(i.x, i.y, o.x, o.y, s.x, s.y, d.x, d.y) && _s(d.prev, d, d.next) >= 0) return !1;
      d = d.prevZ
    }
    for (; p && p.z <= f;) {
      if (p !== t.prev && p !== t.next && gs(i.x, i.y, o.x, o.y, s.x, s.y, p.x, p.y) && _s(p.prev, p, p.next) >= 0) return !1;
      p = p.nextZ
    }
    return !0
  }

  function us(t, e, n) {
    let r = t;
    do {
      const i = r.prev, o = r.next.next;
      !bs(i, o) && xs(i, r, r.next, o) && Ms(i, o) && Ms(o, i) && (e.push(i.i / n), e.push(r.i / n), e.push(o.i / n), Os(r), Os(r.next), r = t = o), r = r.next
    } while (r !== t);
    return ss(r)
  }

  function hs(t, e, n, r, i, o) {
    let s = t;
    do {
      let t = s.next.next;
      for (; t !== s.prev;) {
        if (s.i !== t.i && ys(s, t)) {
          let a = Es(s, t);
          return s = ss(s, s.next), a = ss(a, a.next), as(s, e, n, r, i, o), void as(a, e, n, r, i, o)
        }
        t = t.next
      }
      s = s.next
    } while (s !== t)
  }

  function fs(t, e) {
    return t.x - e.x
  }

  function ds(t, e) {
    if (e = function (t, e) {
      let n = e;
      const r = t.x, i = t.y;
      let o, s = -1 / 0;
      do {
        if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
          const t = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
          if (t <= r && t > s) {
            if (s = t, t === r) {
              if (i === n.y) return n;
              if (i === n.next.y) return n.next
            }
            o = n.x < n.next.x ? n : n.next
          }
        }
        n = n.next
      } while (n !== e);
      if (!o) return null;
      if (r === s) return o;
      const a = o, c = o.x, l = o.y;
      let u, h = 1 / 0;
      n = o;
      do {
        r >= n.x && n.x >= c && r !== n.x && gs(i < l ? r : s, i, c, l, i < l ? s : r, i, n.x, n.y) && (u = Math.abs(i - n.y) / (r - n.x), Ms(n, t) && (u < h || u === h && (n.x > o.x || n.x === o.x && ps(o, n))) && (o = n, h = u)), n = n.next
      } while (n !== a);
      return o
    }(t, e), e) {
      const n = Es(e, t);
      ss(e, e.next), ss(n, n.next)
    }
  }

  function ps(t, e) {
    return _s(t.prev, t, e.prev) < 0 && _s(e.next, t, t.next) < 0
  }

  function ms(t, e, n, r, i) {
    return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
  }

  function vs(t) {
    let e = t, n = t;
    do {
      (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
    } while (e !== t);
    return n
  }

  function gs(t, e, n, r, i, o, s, a) {
    return (i - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (r - a) - (n - s) * (e - a) >= 0 && (n - s) * (o - a) - (i - s) * (r - a) >= 0
  }

  function ys(t, e) {
    return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {
      let n = t;
      do {
        if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && xs(n, n.next, t, e)) return !0;
        n = n.next
      } while (n !== t);
      return !1
    }(t, e) && (Ms(t, e) && Ms(e, t) && function (t, e) {
      let n = t, r = !1;
      const i = (t.x + e.x) / 2, o = (t.y + e.y) / 2;
      do {
        n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next
      } while (n !== t);
      return r
    }(t, e) && (_s(t.prev, t, e.prev) || _s(t, e.prev, e)) || bs(t, e) && _s(t.prev, t, t.next) > 0 && _s(e.prev, e, e.next) > 0)
  }

  function _s(t, e, n) {
    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
  }

  function bs(t, e) {
    return t.x === e.x && t.y === e.y
  }

  function xs(t, e, n, r) {
    const i = Ss(_s(t, e, n)), o = Ss(_s(t, e, r)), s = Ss(_s(n, r, t)), a = Ss(_s(n, r, e));
    return i !== o && s !== a || (!(0 !== i || !ws(t, n, e)) || (!(0 !== o || !ws(t, r, e)) || (!(0 !== s || !ws(n, t, r)) || !(0 !== a || !ws(n, e, r)))))
  }

  function ws(t, e, n) {
    return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
  }

  function Ss(t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0
  }

  function Ms(t, e) {
    return _s(t.prev, t, t.next) < 0 ? _s(t, e, t.next) >= 0 && _s(t, t.prev, e) >= 0 : _s(t, e, t.prev) < 0 || _s(t, t.next, e) < 0
  }

  function Es(t, e) {
    const n = new Hs(t.i, t.x, t.y), r = new Hs(e.i, e.x, e.y), i = t.next, o = e.prev;
    return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r
  }

  function Ts(t, e, n, r) {
    const i = new Hs(t, e, n);
    return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
  }

  function Os(t) {
    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
  }

  function Hs(t, e, n) {
    this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
  }

  class As {
    static area(t) {
      const e = t.length;
      let n = 0;
      for (let r = e - 1, i = 0; i < e; r = i++) n += t[r].x * t[i].y - t[i].x * t[r].y;
      return .5 * n
    }

    static isClockWise(t) {
      return As.area(t) < 0
    }

    static triangulateShape(t, e) {
      const n = [], r = [], i = [];
      Ps(t), Rs(n, t);
      let o = t.length;
      e.forEach(Ps);
      for (let a = 0; a < e.length; a++) r.push(o), o += e[a].length, Rs(n, e[a]);
      const s = is(n, r);
      for (let a = 0; a < s.length; a += 3) i.push(s.slice(a, a + 3));
      return i
    }
  }

  function Ps(t) {
    const e = t.length;
    e > 2 && t[e - 1].equals(t[0]) && t.pop()
  }

  function Rs(t, e) {
    for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
  }

  class Ls extends sn {
    constructor(t, e) {
      super(), this.type = "ExtrudeGeometry", this.parameters = {shapes: t, options: e}, t = Array.isArray(t) ? t : [t];
      const n = this, r = [], i = [];
      for (let s = 0, a = t.length; s < a; s++) {
        o(t[s])
      }

      function o(t) {
        const o = [], s = void 0 !== e.curveSegments ? e.curveSegments : 12, a = void 0 !== e.steps ? e.steps : 1;
        let c = void 0 !== e.depth ? e.depth : 100, l = void 0 === e.bevelEnabled || e.bevelEnabled,
          u = void 0 !== e.bevelThickness ? e.bevelThickness : 6, h = void 0 !== e.bevelSize ? e.bevelSize : u - 2,
          f = void 0 !== e.bevelOffset ? e.bevelOffset : 0, d = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
        const p = e.extrudePath, m = void 0 !== e.UVGenerator ? e.UVGenerator : Cs;
        void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = e.amount);
        let v, g, y, _, b, x = !1;
        p && (v = p.getSpacedPoints(a), x = !0, l = !1, g = p.computeFrenetFrames(a, !1), y = new gt, _ = new gt, b = new gt), l || (d = 0, u = 0, h = 0, f = 0);
        const w = t.extractPoints(s);
        let S = w.shape;
        const M = w.holes;
        if (!As.isClockWise(S)) {
          S = S.reverse();
          for (let t = 0, e = M.length; t < e; t++) {
            const e = M[t];
            As.isClockWise(e) && (M[t] = e.reverse())
          }
        }
        const E = As.triangulateShape(S, M), T = S;
        for (let e = 0, n = M.length; e < n; e++) {
          const t = M[e];
          S = S.concat(t)
        }

        function O(t, e, n) {
          return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
        }

        const H = S.length, A = E.length;

        function P(t, e, n) {
          let r, i, o;
          const s = t.x - e.x, a = t.y - e.y, c = n.x - t.x, l = n.y - t.y, u = s * s + a * a, h = s * l - a * c;
          if (Math.abs(h) > Number.EPSILON) {
            const h = Math.sqrt(u), f = Math.sqrt(c * c + l * l), d = e.x - a / h, p = e.y + s / h,
              m = ((n.x - l / f - d) * l - (n.y + c / f - p) * c) / (s * l - a * c);
            r = d + s * m - t.x, i = p + a * m - t.y;
            const v = r * r + i * i;
            if (v <= 2) return new at(r, i);
            o = Math.sqrt(v / 2)
          } else {
            let t = !1;
            s > Number.EPSILON ? c > Number.EPSILON && (t = !0) : s < -Number.EPSILON ? c < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(l) && (t = !0), t ? (r = -a, i = s, o = Math.sqrt(u)) : (r = s, i = a, o = Math.sqrt(u / 2))
          }
          return new at(r / o, i / o)
        }

        const R = [];
        for (let e = 0, n = T.length, r = n - 1, i = e + 1; e < n; e++, r++, i++) r === n && (r = 0), i === n && (i = 0), R[e] = P(T[e], T[r], T[i]);
        const L = [];
        let C, k = R.concat();
        for (let e = 0, n = M.length; e < n; e++) {
          const t = M[e];
          C = [];
          for (let e = 0, n = t.length, r = n - 1, i = e + 1; e < n; e++, r++, i++) r === n && (r = 0), i === n && (i = 0), C[e] = P(t[e], t[r], t[i]);
          L.push(C), k = k.concat(C)
        }
        for (let e = 0; e < d; e++) {
          const t = e / d, n = u * Math.cos(t * Math.PI / 2), r = h * Math.sin(t * Math.PI / 2) + f;
          for (let e = 0, i = T.length; e < i; e++) {
            const t = O(T[e], R[e], r);
            z(t.x, t.y, -n)
          }
          for (let e = 0, i = M.length; e < i; e++) {
            const t = M[e];
            C = L[e];
            for (let e = 0, i = t.length; e < i; e++) {
              const i = O(t[e], C[e], r);
              z(i.x, i.y, -n)
            }
          }
        }
        const D = h + f;
        for (let e = 0; e < H; e++) {
          const t = l ? O(S[e], k[e], D) : S[e];
          x ? (_.copy(g.normals[0]).multiplyScalar(t.x), y.copy(g.binormals[0]).multiplyScalar(t.y), b.copy(v[0]).add(_).add(y), z(b.x, b.y, b.z)) : z(t.x, t.y, 0)
        }
        for (let e = 1; e <= a; e++) for (let t = 0; t < H; t++) {
          const n = l ? O(S[t], k[t], D) : S[t];
          x ? (_.copy(g.normals[e]).multiplyScalar(n.x), y.copy(g.binormals[e]).multiplyScalar(n.y), b.copy(v[e]).add(_).add(y), z(b.x, b.y, b.z)) : z(n.x, n.y, c / a * e)
        }
        for (let e = d - 1; e >= 0; e--) {
          const t = e / d, n = u * Math.cos(t * Math.PI / 2), r = h * Math.sin(t * Math.PI / 2) + f;
          for (let e = 0, i = T.length; e < i; e++) {
            const t = O(T[e], R[e], r);
            z(t.x, t.y, c + n)
          }
          for (let e = 0, i = M.length; e < i; e++) {
            const t = M[e];
            C = L[e];
            for (let e = 0, i = t.length; e < i; e++) {
              const i = O(t[e], C[e], r);
              x ? z(i.x, i.y + v[a - 1].y, v[a - 1].x + n) : z(i.x, i.y, c + n)
            }
          }
        }

        function N(t, e) {
          let n = t.length;
          for (; --n >= 0;) {
            const r = n;
            let i = n - 1;
            i < 0 && (i = t.length - 1);
            for (let t = 0, n = a + 2 * d; t < n; t++) {
              const n = H * t, o = H * (t + 1);
              I(e + r + n, e + i + n, e + i + o, e + r + o)
            }
          }
        }

        function z(t, e, n) {
          o.push(t), o.push(e), o.push(n)
        }

        function j(t, e, i) {
          B(t), B(e), B(i);
          const o = r.length / 3, s = m.generateTopUV(n, r, o - 3, o - 2, o - 1);
          F(s[0]), F(s[1]), F(s[2])
        }

        function I(t, e, i, o) {
          B(t), B(e), B(o), B(e), B(i), B(o);
          const s = r.length / 3, a = m.generateSideWallUV(n, r, s - 6, s - 3, s - 2, s - 1);
          F(a[0]), F(a[1]), F(a[3]), F(a[1]), F(a[2]), F(a[3])
        }

        function B(t) {
          r.push(o[3 * t + 0]), r.push(o[3 * t + 1]), r.push(o[3 * t + 2])
        }

        function F(t) {
          i.push(t.x), i.push(t.y)
        }

        !function () {
          const t = r.length / 3;
          if (l) {
            let t = 0, e = H * t;
            for (let n = 0; n < A; n++) {
              const t = E[n];
              j(t[2] + e, t[1] + e, t[0] + e)
            }
            t = a + 2 * d, e = H * t;
            for (let n = 0; n < A; n++) {
              const t = E[n];
              j(t[0] + e, t[1] + e, t[2] + e)
            }
          } else {
            for (let t = 0; t < A; t++) {
              const e = E[t];
              j(e[2], e[1], e[0])
            }
            for (let t = 0; t < A; t++) {
              const e = E[t];
              j(e[0] + H * a, e[1] + H * a, e[2] + H * a)
            }
          }
          n.addGroup(t, r.length / 3 - t, 0)
        }(), function () {
          const t = r.length / 3;
          let e = 0;
          N(T, e), e += T.length;
          for (let n = 0, r = M.length; n < r; n++) {
            const t = M[n];
            N(t, e), e += t.length
          }
          n.addGroup(t, r.length / 3 - t, 1)
        }()
      }

      this.setAttribute("position", new Je(r, 3)), this.setAttribute("uv", new Je(i, 2)), this.computeVertexNormals()
    }

    toJSON() {
      const t = sn.prototype.toJSON.call(this);
      return function (t, e, n) {
        if (n.shapes = [], Array.isArray(t)) for (let r = 0, i = t.length; r < i; r++) {
          const e = t[r];
          n.shapes.push(e.uuid)
        } else n.shapes.push(t.uuid);
        void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON());
        return n
      }(this.parameters.shapes, this.parameters.options, t)
    }
  }

  const Cs = {
    generateTopUV: function (t, e, n, r, i) {
      const o = e[3 * n], s = e[3 * n + 1], a = e[3 * r], c = e[3 * r + 1], l = e[3 * i], u = e[3 * i + 1];
      return [new at(o, s), new at(a, c), new at(l, u)]
    }, generateSideWallUV: function (t, e, n, r, i, o) {
      const s = e[3 * n], a = e[3 * n + 1], c = e[3 * n + 2], l = e[3 * r], u = e[3 * r + 1], h = e[3 * r + 2],
        f = e[3 * i], d = e[3 * i + 1], p = e[3 * i + 2], m = e[3 * o], v = e[3 * o + 1], g = e[3 * o + 2];
      return Math.abs(a - u) < .01 ? [new at(s, 1 - c), new at(l, 1 - h), new at(f, 1 - p), new at(m, 1 - g)] : [new at(a, 1 - c), new at(u, 1 - h), new at(d, 1 - p), new at(v, 1 - g)]
    }
  };

  class ks extends sn {
    constructor(t, e = 12) {
      super(), this.type = "ShapeGeometry", this.parameters = {shapes: t, curveSegments: e};
      const n = [], r = [], i = [], o = [];
      let s = 0, a = 0;
      if (!1 === Array.isArray(t)) c(t); else for (let l = 0; l < t.length; l++) c(t[l]), this.addGroup(s, a, l), s += a, a = 0;

      function c(t) {
        const s = r.length / 3, c = t.extractPoints(e);
        let l = c.shape;
        const u = c.holes;
        !1 === As.isClockWise(l) && (l = l.reverse());
        for (let e = 0, n = u.length; e < n; e++) {
          const t = u[e];
          !0 === As.isClockWise(t) && (u[e] = t.reverse())
        }
        const h = As.triangulateShape(l, u);
        for (let e = 0, n = u.length; e < n; e++) {
          const t = u[e];
          l = l.concat(t)
        }
        for (let e = 0, n = l.length; e < n; e++) {
          const t = l[e];
          r.push(t.x, t.y, 0), i.push(0, 0, 1), o.push(t.x, t.y)
        }
        for (let e = 0, r = h.length; e < r; e++) {
          const t = h[e], r = t[0] + s, i = t[1] + s, o = t[2] + s;
          n.push(r, i, o), a += 3
        }
      }

      this.setIndex(n), this.setAttribute("position", new Je(r, 3)), this.setAttribute("normal", new Je(i, 3)), this.setAttribute("uv", new Je(o, 2))
    }

    toJSON() {
      const t = sn.prototype.toJSON.call(this);
      return function (t, e) {
        if (e.shapes = [], Array.isArray(t)) for (let n = 0, r = t.length; n < r; n++) {
          const r = t[n];
          e.shapes.push(r.uuid)
        } else e.shapes.push(t.uuid);
        return e
      }(this.parameters.shapes, t)
    }
  }

  class Ds extends sn {
    constructor(t = 1, e = 8, n = 6, r = 0, i = 2 * Math.PI, o = 0, s = Math.PI) {
      super(), this.type = "SphereGeometry", this.parameters = {
        radius: t,
        widthSegments: e,
        heightSegments: n,
        phiStart: r,
        phiLength: i,
        thetaStart: o,
        thetaLength: s
      }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n));
      const a = Math.min(o + s, Math.PI);
      let c = 0;
      const l = [], u = new gt, h = new gt, f = [], d = [], p = [], m = [];
      for (let v = 0; v <= n; v++) {
        const f = [], g = v / n;
        let y = 0;
        0 == v && 0 == o ? y = .5 / e : v == n && a == Math.PI && (y = -.5 / e);
        for (let n = 0; n <= e; n++) {
          const a = n / e;
          u.x = -t * Math.cos(r + a * i) * Math.sin(o + g * s), u.y = t * Math.cos(o + g * s), u.z = t * Math.sin(r + a * i) * Math.sin(o + g * s), d.push(u.x, u.y, u.z), h.copy(u).normalize(), p.push(h.x, h.y, h.z), m.push(a + y, 1 - g), f.push(c++)
        }
        l.push(f)
      }
      for (let v = 0; v < n; v++) for (let t = 0; t < e; t++) {
        const e = l[v][t + 1], r = l[v][t], i = l[v + 1][t], s = l[v + 1][t + 1];
        (0 !== v || o > 0) && f.push(e, r, s), (v !== n - 1 || a < Math.PI) && f.push(r, i, s)
      }
      this.setIndex(f), this.setAttribute("position", new Je(d, 3)), this.setAttribute("normal", new Je(p, 3)), this.setAttribute("uv", new Je(m, 2))
    }
  }

  class Ns extends Ne {
    constructor(t) {
      super(), this.type = "ShadowMaterial", this.color = new Ge(0), this.transparent = !0, this.setValues(t)
    }

    copy(t) {
      return super.copy(t), this.color.copy(t.color), this
    }
  }

  Ns.prototype.isShadowMaterial = !0;

  class zs extends Pn {
    constructor(t) {
      super(t), this.type = "RawShaderMaterial"
    }
  }

  zs.prototype.isRawShaderMaterial = !0;

  class js extends Ne {
    constructor(t) {
      super(), this.defines = {STANDARD: ""}, this.type = "MeshStandardMaterial", this.color = new Ge(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ge(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new at(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.vertexTangents = !1, this.setValues(t)
    }

    copy(t) {
      return super.copy(t), this.defines = {STANDARD: ""}, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this.vertexTangents = t.vertexTangents, this
    }
  }

  js.prototype.isMeshStandardMaterial = !0;

  class Is extends js {
    constructor(t) {
      super(), this.defines = {
        STANDARD: "",
        PHYSICAL: ""
      }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new at(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", {
        get: function () {
          return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
        }, set: function (t) {
          this.reflectivity = tt(2.5 * (t - 1) / (t + 1), 0, 1)
        }
      }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t)
    }

    copy(t) {
      return super.copy(t), this.defines = {
        STANDARD: "",
        PHYSICAL: ""
      }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new Ge).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this
    }
  }

  Is.prototype.isMeshPhysicalMaterial = !0;

  class Bs extends Ne {
    constructor(t) {
      super(), this.type = "MeshPhongMaterial", this.color = new Ge(16777215), this.specular = new Ge(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ge(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new at(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t)
    }

    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this
    }
  }

  Bs.prototype.isMeshPhongMaterial = !0;

  class Fs extends Ne {
    constructor(t) {
      super(), this.defines = {TOON: ""}, this.type = "MeshToonMaterial", this.color = new Ge(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ge(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new at(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }
  }

  Fs.prototype.isMeshToonMaterial = !0;

  class Us extends Ne {
    constructor(t) {
      super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new at(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t)
    }

    copy(t) {
      return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this
    }
  }

  Us.prototype.isMeshNormalMaterial = !0;

  class Gs extends Ne {
    constructor(t) {
      super(), this.type = "MeshLambertMaterial", this.color = new Ge(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ge(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }
  }

  Gs.prototype.isMeshLambertMaterial = !0;

  class Vs extends Ne {
    constructor(t) {
      super(), this.defines = {MATCAP: ""}, this.type = "MeshMatcapMaterial", this.color = new Ge(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new at(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t)
    }

    copy(t) {
      return super.copy(t), this.defines = {MATCAP: ""}, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this
    }
  }

  Vs.prototype.isMeshMatcapMaterial = !0;

  class Ws extends zo {
    constructor(t) {
      super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
    }

    copy(t) {
      return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
    }
  }

  Ws.prototype.isLineDashedMaterial = !0;
  const Xs = {
    arraySlice: function (t, e, n) {
      return Xs.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
    }, convertArray: function (t, e, n) {
      return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
    }, isTypedArray: function (t) {
      return ArrayBuffer.isView(t) && !(t instanceof DataView)
    }, getKeyframeOrder: function (t) {
      const e = t.length, n = new Array(e);
      for (let r = 0; r !== e; ++r) n[r] = r;
      return n.sort((function (e, n) {
        return t[e] - t[n]
      })), n
    }, sortedArray: function (t, e, n) {
      const r = t.length, i = new t.constructor(r);
      for (let o = 0, s = 0; s !== r; ++o) {
        const r = n[o] * e;
        for (let n = 0; n !== e; ++n) i[s++] = t[r + n]
      }
      return i
    }, flattenJSON: function (t, e, n, r) {
      let i = 1, o = t[0];
      for (; void 0 !== o && void 0 === o[r];) o = t[i++];
      if (void 0 === o) return;
      let s = o[r];
      if (void 0 !== s) if (Array.isArray(s)) do {
        s = o[r], void 0 !== s && (e.push(o.time), n.push.apply(n, s)), o = t[i++]
      } while (void 0 !== o); else if (void 0 !== s.toArray) do {
        s = o[r], void 0 !== s && (e.push(o.time), s.toArray(n, n.length)), o = t[i++]
      } while (void 0 !== o); else do {
        s = o[r], void 0 !== s && (e.push(o.time), n.push(s)), o = t[i++]
      } while (void 0 !== o)
    }, subclip: function (t, e, n, r, i = 30) {
      const o = t.clone();
      o.name = e;
      const s = [];
      for (let c = 0; c < o.tracks.length; ++c) {
        const t = o.tracks[c], e = t.getValueSize(), a = [], l = [];
        for (let o = 0; o < t.times.length; ++o) {
          const s = t.times[o] * i;
          if (!(s < n || s >= r)) {
            a.push(t.times[o]);
            for (let n = 0; n < e; ++n) l.push(t.values[o * e + n])
          }
        }
        0 !== a.length && (t.times = Xs.convertArray(a, t.times.constructor), t.values = Xs.convertArray(l, t.values.constructor), s.push(t))
      }
      o.tracks = s;
      let a = 1 / 0;
      for (let c = 0; c < o.tracks.length; ++c) a > o.tracks[c].times[0] && (a = o.tracks[c].times[0]);
      for (let c = 0; c < o.tracks.length; ++c) o.tracks[c].shift(-1 * a);
      return o.resetDuration(), o
    }, makeClipAdditive: function (t, e = 0, n = t, r = 30) {
      r <= 0 && (r = 30);
      const i = n.tracks.length, o = e / r;
      for (let s = 0; s < i; ++s) {
        const e = n.tracks[s], r = e.ValueTypeName;
        if ("bool" === r || "string" === r) continue;
        const i = t.tracks.find((function (t) {
          return t.name === e.name && t.ValueTypeName === r
        }));
        if (void 0 === i) continue;
        let a = 0;
        const c = e.getValueSize();
        e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = c / 3);
        let l = 0;
        const u = i.getValueSize();
        i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (l = u / 3);
        const h = e.times.length - 1;
        let f;
        if (o <= e.times[0]) {
          const t = a, n = c - a;
          f = Xs.arraySlice(e.values, t, n)
        } else if (o >= e.times[h]) {
          const t = h * c + a, n = t + c - a;
          f = Xs.arraySlice(e.values, t, n)
        } else {
          const t = e.createInterpolant(), n = a, r = c - a;
          t.evaluate(o), f = Xs.arraySlice(t.resultBuffer, n, r)
        }
        if ("quaternion" === r) {
          (new vt).fromArray(f).normalize().conjugate().toArray(f)
        }
        const d = i.times.length;
        for (let t = 0; t < d; ++t) {
          const e = t * u + l;
          if ("quaternion" === r) vt.multiplyQuaternionsFlat(i.values, e, f, 0, i.values, e); else {
            const t = u - 2 * l;
            for (let n = 0; n < t; ++n) i.values[e + n] -= f[n]
          }
        }
      }
      return t.blendMode = 2501, t
    }
  };

  class qs {
    constructor(t, e, n, r) {
      this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
    }

    evaluate(t) {
      const e = this.parameterPositions;
      let n = this._cachedIndex, r = e[n], i = e[n - 1];
      t:{
        e:{
          let o;
          n:{
            r:if (!(t < r)) {
              for (let o = n + 2; ;) {
                if (void 0 === r) {
                  if (t < i) break r;
                  return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, i)
                }
                if (n === o) break;
                if (i = r, r = e[++n], t < r) break e
              }
              o = e.length;
              break n
            }
            if (t >= i) break t;
            {
              const s = e[1];
              t < s && (n = 2, i = s);
              for (let o = n - 2; ;) {
                if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                if (n === o) break;
                if (r = i, i = e[--n - 1], t >= i) break e
              }
              o = n, n = 0
            }
          }
          for (; n < o;) {
            const r = n + o >>> 1;
            t < e[r] ? o = r : n = r + 1
          }
          if (r = e[n], i = e[n - 1], void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
          if (void 0 === r) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, i, t)
        }
        this._cachedIndex = n, this.intervalChanged_(n, i, r)
      }
      return this.interpolate_(n, i, t, r)
    }

    getSettings_() {
      return this.settings || this.DefaultSettings_
    }

    copySampleValue_(t) {
      const e = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = t * r;
      for (let o = 0; o !== r; ++o) e[o] = n[i + o];
      return e
    }

    interpolate_() {
      throw new Error("call to abstract method")
    }

    intervalChanged_() {
    }
  }

  qs.prototype.beforeStart_ = qs.prototype.copySampleValue_, qs.prototype.afterEnd_ = qs.prototype.copySampleValue_;

  class Ys extends qs {
    constructor(t, e, n, r) {
      super(t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
        endingStart: N,
        endingEnd: N
      }
    }

    intervalChanged_(t, e, n) {
      const r = this.parameterPositions;
      let i = t - 2, o = t + 1, s = r[i], a = r[o];
      if (void 0 === s) switch (this.getSettings_().endingStart) {
        case z:
          i = t, s = 2 * e - n;
          break;
        case j:
          i = r.length - 2, s = e + r[i] - r[i + 1];
          break;
        default:
          i = t, s = n
      }
      if (void 0 === a) switch (this.getSettings_().endingEnd) {
        case z:
          o = t, a = 2 * n - e;
          break;
        case j:
          o = 1, a = n + r[1] - r[0];
          break;
        default:
          o = t - 1, a = e
      }
      const c = .5 * (n - e), l = this.valueSize;
      this._weightPrev = c / (e - s), this._weightNext = c / (a - n), this._offsetPrev = i * l, this._offsetNext = o * l
    }

    interpolate_(t, e, n, r) {
      const i = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = t * s, c = a - s,
        l = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, f = this._weightNext, d = (n - e) / (r - e),
        p = d * d, m = p * d, v = -h * m + 2 * h * p - h * d, g = (1 + h) * m + (-1.5 - 2 * h) * p + (-.5 + h) * d + 1,
        y = (-1 - f) * m + (1.5 + f) * p + .5 * d, _ = f * m - f * p;
      for (let b = 0; b !== s; ++b) i[b] = v * o[l + b] + g * o[c + b] + y * o[a + b] + _ * o[u + b];
      return i
    }
  }

  class Zs extends qs {
    constructor(t, e, n, r) {
      super(t, e, n, r)
    }

    interpolate_(t, e, n, r) {
      const i = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = t * s, c = a - s,
        l = (n - e) / (r - e), u = 1 - l;
      for (let h = 0; h !== s; ++h) i[h] = o[c + h] * u + o[a + h] * l;
      return i
    }
  }

  class Js extends qs {
    constructor(t, e, n, r) {
      super(t, e, n, r)
    }

    interpolate_(t) {
      return this.copySampleValue_(t - 1)
    }
  }

  class Ks {
    constructor(t, e, n, r) {
      if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
      this.name = t, this.times = Xs.convertArray(e, this.TimeBufferType), this.values = Xs.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
    }

    static toJSON(t) {
      const e = t.constructor;
      let n;
      if (e.toJSON !== this.toJSON) n = e.toJSON(t); else {
        n = {name: t.name, times: Xs.convertArray(t.times, Array), values: Xs.convertArray(t.values, Array)};
        const e = t.getInterpolation();
        e !== t.DefaultInterpolation && (n.interpolation = e)
      }
      return n.type = t.ValueTypeName, n
    }

    InterpolantFactoryMethodDiscrete(t) {
      return new Js(this.times, this.values, this.getValueSize(), t)
    }

    InterpolantFactoryMethodLinear(t) {
      return new Zs(this.times, this.values, this.getValueSize(), t)
    }

    InterpolantFactoryMethodSmooth(t) {
      return new Ys(this.times, this.values, this.getValueSize(), t)
    }

    setInterpolation(t) {
      let e;
      switch (t) {
        case C:
          e = this.InterpolantFactoryMethodDiscrete;
          break;
        case k:
          e = this.InterpolantFactoryMethodLinear;
          break;
        case D:
          e = this.InterpolantFactoryMethodSmooth
      }
      if (void 0 === e) {
        const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (void 0 === this.createInterpolant) {
          if (t === this.DefaultInterpolation) throw new Error(e);
          this.setInterpolation(this.DefaultInterpolation)
        }
        return console.warn("THREE.KeyframeTrack:", e), this
      }
      return this.createInterpolant = e, this
    }

    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return C;
        case this.InterpolantFactoryMethodLinear:
          return k;
        case this.InterpolantFactoryMethodSmooth:
          return D
      }
    }

    getValueSize() {
      return this.values.length / this.times.length
    }

    shift(t) {
      if (0 !== t) {
        const e = this.times;
        for (let n = 0, r = e.length; n !== r; ++n) e[n] += t
      }
      return this
    }

    scale(t) {
      if (1 !== t) {
        const e = this.times;
        for (let n = 0, r = e.length; n !== r; ++n) e[n] *= t
      }
      return this
    }

    trim(t, e) {
      const n = this.times, r = n.length;
      let i = 0, o = r - 1;
      for (; i !== r && n[i] < t;) ++i;
      for (; -1 !== o && n[o] > e;) --o;
      if (++o, 0 !== i || o !== r) {
        i >= o && (o = Math.max(o, 1), i = o - 1);
        const t = this.getValueSize();
        this.times = Xs.arraySlice(n, i, o), this.values = Xs.arraySlice(this.values, i * t, o * t)
      }
      return this
    }

    validate() {
      let t = !0;
      const e = this.getValueSize();
      e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
      const n = this.times, r = this.values, i = n.length;
      0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
      let o = null;
      for (let s = 0; s !== i; s++) {
        const e = n[s];
        if ("number" == typeof e && isNaN(e)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, s, e), t = !1;
          break
        }
        if (null !== o && o > e) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, s, e, o), t = !1;
          break
        }
        o = e
      }
      if (void 0 !== r && Xs.isTypedArray(r)) for (let s = 0, a = r.length; s !== a; ++s) {
        const e = r[s];
        if (isNaN(e)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, s, e), t = !1;
          break
        }
      }
      return t
    }

    optimize() {
      const t = Xs.arraySlice(this.times), e = Xs.arraySlice(this.values), n = this.getValueSize(),
        r = this.getInterpolation() === D, i = t.length - 1;
      let o = 1;
      for (let s = 1; s < i; ++s) {
        let i = !1;
        const a = t[s];
        if (a !== t[s + 1] && (1 !== s || a !== t[0])) if (r) i = !0; else {
          const t = s * n, r = t - n, o = t + n;
          for (let s = 0; s !== n; ++s) {
            const n = e[t + s];
            if (n !== e[r + s] || n !== e[o + s]) {
              i = !0;
              break
            }
          }
        }
        if (i) {
          if (s !== o) {
            t[o] = t[s];
            const r = s * n, i = o * n;
            for (let t = 0; t !== n; ++t) e[i + t] = e[r + t]
          }
          ++o
        }
      }
      if (i > 0) {
        t[o] = t[i];
        for (let t = i * n, r = o * n, s = 0; s !== n; ++s) e[r + s] = e[t + s];
        ++o
      }
      return o !== t.length ? (this.times = Xs.arraySlice(t, 0, o), this.values = Xs.arraySlice(e, 0, o * n)) : (this.times = t, this.values = e), this
    }

    clone() {
      const t = Xs.arraySlice(this.times, 0), e = Xs.arraySlice(this.values, 0),
        n = new (0, this.constructor)(this.name, t, e);
      return n.createInterpolant = this.createInterpolant, n
    }
  }

  Ks.prototype.TimeBufferType = Float32Array, Ks.prototype.ValueBufferType = Float32Array, Ks.prototype.DefaultInterpolation = k;

  class Qs extends Ks {
  }

  Qs.prototype.ValueTypeName = "bool", Qs.prototype.ValueBufferType = Array, Qs.prototype.DefaultInterpolation = C, Qs.prototype.InterpolantFactoryMethodLinear = void 0, Qs.prototype.InterpolantFactoryMethodSmooth = void 0;

  class $s extends Ks {
  }

  $s.prototype.ValueTypeName = "color";

  class ta extends Ks {
  }

  ta.prototype.ValueTypeName = "number";

  class ea extends qs {
    constructor(t, e, n, r) {
      super(t, e, n, r)
    }

    interpolate_(t, e, n, r) {
      const i = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = (n - e) / (r - e);
      let c = t * s;
      for (let l = c + s; c !== l; c += 4) vt.slerpFlat(i, 0, o, c - s, o, c, a);
      return i
    }
  }

  class na extends Ks {
    InterpolantFactoryMethodLinear(t) {
      return new ea(this.times, this.values, this.getValueSize(), t)
    }
  }

  na.prototype.ValueTypeName = "quaternion", na.prototype.DefaultInterpolation = k, na.prototype.InterpolantFactoryMethodSmooth = void 0;

  class ra extends Ks {
  }

  ra.prototype.ValueTypeName = "string", ra.prototype.ValueBufferType = Array, ra.prototype.DefaultInterpolation = C, ra.prototype.InterpolantFactoryMethodLinear = void 0, ra.prototype.InterpolantFactoryMethodSmooth = void 0;

  class ia extends Ks {
  }

  ia.prototype.ValueTypeName = "vector";

  class oa {
    constructor(t, e = -1, n, r = 2500) {
      this.name = t, this.tracks = n, this.duration = e, this.blendMode = r, this.uuid = $(), this.duration < 0 && this.resetDuration()
    }

    static parse(t) {
      const e = [], n = t.tracks, r = 1 / (t.fps || 1);
      for (let o = 0, s = n.length; o !== s; ++o) e.push(sa(n[o]).scale(r));
      const i = new this(t.name, t.duration, e, t.blendMode);
      return i.uuid = t.uuid, i
    }

    static toJSON(t) {
      const e = [], n = t.tracks,
        r = {name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode};
      for (let i = 0, o = n.length; i !== o; ++i) e.push(Ks.toJSON(n[i]));
      return r
    }

    static CreateFromMorphTargetSequence(t, e, n, r) {
      const i = e.length, o = [];
      for (let s = 0; s < i; s++) {
        let t = [], a = [];
        t.push((s + i - 1) % i, s, (s + 1) % i), a.push(0, 1, 0);
        const c = Xs.getKeyframeOrder(t);
        t = Xs.sortedArray(t, 1, c), a = Xs.sortedArray(a, 1, c), r || 0 !== t[0] || (t.push(i), a.push(a[0])), o.push(new ta(".morphTargetInfluences[" + e[s].name + "]", t, a).scale(1 / n))
      }
      return new this(t, -1, o)
    }

    static findByName(t, e) {
      let n = t;
      if (!Array.isArray(t)) {
        const e = t;
        n = e.geometry && e.geometry.animations || e.animations
      }
      for (let r = 0; r < n.length; r++) if (n[r].name === e) return n[r];
      return null
    }

    static CreateClipsFromMorphTargetSequences(t, e, n) {
      const r = {}, i = /^([\w-]*?)([\d]+)$/;
      for (let s = 0, a = t.length; s < a; s++) {
        const e = t[s], n = e.name.match(i);
        if (n && n.length > 1) {
          const t = n[1];
          let i = r[t];
          i || (r[t] = i = []), i.push(e)
        }
      }
      const o = [];
      for (const s in r) o.push(this.CreateFromMorphTargetSequence(s, r[s], e, n));
      return o
    }

    static parseAnimation(t, e) {
      if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
      const n = function (t, e, n, r, i) {
        if (0 !== n.length) {
          const o = [], s = [];
          Xs.flattenJSON(n, o, s, r), 0 !== o.length && i.push(new t(e, o, s))
        }
      }, r = [], i = t.name || "default", o = t.fps || 30, s = t.blendMode;
      let a = t.length || -1;
      const c = t.hierarchy || [];
      for (let l = 0; l < c.length; l++) {
        const t = c[l].keys;
        if (t && 0 !== t.length) if (t[0].morphTargets) {
          const e = {};
          let n;
          for (n = 0; n < t.length; n++) if (t[n].morphTargets) for (let r = 0; r < t[n].morphTargets.length; r++) e[t[n].morphTargets[r]] = -1;
          for (const i in e) {
            const e = [], o = [];
            for (let r = 0; r !== t[n].morphTargets.length; ++r) {
              const r = t[n];
              e.push(r.time), o.push(r.morphTarget === i ? 1 : 0)
            }
            r.push(new ta(".morphTargetInfluence[" + i + "]", e, o))
          }
          a = e.length * (o || 1)
        } else {
          const i = ".bones[" + e[l].name + "]";
          n(ia, i + ".position", t, "pos", r), n(na, i + ".quaternion", t, "rot", r), n(ia, i + ".scale", t, "scl", r)
        }
      }
      if (0 === r.length) return null;
      return new this(i, a, r, s)
    }

    resetDuration() {
      let t = 0;
      for (let e = 0, n = this.tracks.length; e !== n; ++e) {
        const n = this.tracks[e];
        t = Math.max(t, n.times[n.times.length - 1])
      }
      return this.duration = t, this
    }

    trim() {
      for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
      return this
    }

    validate() {
      let t = !0;
      for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
      return t
    }

    optimize() {
      for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
      return this
    }

    clone() {
      const t = [];
      for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
      return new this.constructor(this.name, this.duration, t, this.blendMode)
    }

    toJSON() {
      return this.constructor.toJSON(this)
    }
  }

  function sa(t) {
    if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = function (t) {
      switch (t.toLowerCase()) {
        case"scalar":
        case"double":
        case"float":
        case"number":
        case"integer":
          return ta;
        case"vector":
        case"vector2":
        case"vector3":
        case"vector4":
          return ia;
        case"color":
          return $s;
        case"quaternion":
          return na;
        case"bool":
        case"boolean":
          return Qs;
        case"string":
          return ra
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
    }(t.type);
    if (void 0 === t.times) {
      const e = [], n = [];
      Xs.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
    }
    return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
  }

  const aa = {
    enabled: !1, files: {}, add: function (t, e) {
      !1 !== this.enabled && (this.files[t] = e)
    }, get: function (t) {
      if (!1 !== this.enabled) return this.files[t]
    }, remove: function (t) {
      delete this.files[t]
    }, clear: function () {
      this.files = {}
    }
  };

  class ca {
    constructor(t, e, n) {
      const r = this;
      let i, o = !1, s = 0, a = 0;
      const c = [];
      this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) {
        a++, !1 === o && void 0 !== r.onStart && r.onStart(t, s, a), o = !0
      }, this.itemEnd = function (t) {
        s++, void 0 !== r.onProgress && r.onProgress(t, s, a), s === a && (o = !1, void 0 !== r.onLoad && r.onLoad())
      }, this.itemError = function (t) {
        void 0 !== r.onError && r.onError(t)
      }, this.resolveURL = function (t) {
        return i ? i(t) : t
      }, this.setURLModifier = function (t) {
        return i = t, this
      }, this.addHandler = function (t, e) {
        return c.push(t, e), this
      }, this.removeHandler = function (t) {
        const e = c.indexOf(t);
        return -1 !== e && c.splice(e, 2), this
      }, this.getHandler = function (t) {
        for (let e = 0, n = c.length; e < n; e += 2) {
          const n = c[e], r = c[e + 1];
          if (n.global && (n.lastIndex = 0), n.test(t)) return r
        }
        return null
      }
    }
  }

  const la = new ca;

  class ua {
    constructor(t) {
      this.manager = void 0 !== t ? t : la, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
    }

    load() {
    }

    loadAsync(t, e) {
      const n = this;
      return new Promise((function (r, i) {
        n.load(t, r, e, i)
      }))
    }

    parse() {
    }

    setCrossOrigin(t) {
      return this.crossOrigin = t, this
    }

    setWithCredentials(t) {
      return this.withCredentials = t, this
    }

    setPath(t) {
      return this.path = t, this
    }

    setResourcePath(t) {
      return this.resourcePath = t, this
    }

    setRequestHeader(t) {
      return this.requestHeader = t, this
    }
  }

  const ha = {};

  class fa extends ua {
    constructor(t) {
      super(t)
    }

    load(t, e, n, r) {
      void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
      const i = this, o = aa.get(t);
      if (void 0 !== o) return i.manager.itemStart(t), setTimeout((function () {
        e && e(o), i.manager.itemEnd(t)
      }), 0), o;
      if (void 0 !== ha[t]) return void ha[t].push({onLoad: e, onProgress: n, onError: r});
      const s = t.match(/^data:(.*?)(;base64)?,(.*)$/);
      let a;
      if (s) {
        const n = s[1], o = !!s[2];
        let a = s[3];
        a = decodeURIComponent(a), o && (a = atob(a));
        try {
          let r;
          const o = (this.responseType || "").toLowerCase();
          switch (o) {
            case"arraybuffer":
            case"blob":
              const t = new Uint8Array(a.length);
              for (let n = 0; n < a.length; n++) t[n] = a.charCodeAt(n);
              r = "blob" === o ? new Blob([t.buffer], {type: n}) : t.buffer;
              break;
            case"document":
              const e = new DOMParser;
              r = e.parseFromString(a, n);
              break;
            case"json":
              r = JSON.parse(a);
              break;
            default:
              r = a
          }
          setTimeout((function () {
            e && e(r), i.manager.itemEnd(t)
          }), 0)
        } catch (c) {
          setTimeout((function () {
            r && r(c), i.manager.itemError(t), i.manager.itemEnd(t)
          }), 0)
        }
      } else {
        ha[t] = [], ha[t].push({
          onLoad: e,
          onProgress: n,
          onError: r
        }), a = new XMLHttpRequest, a.open("GET", t, !0), a.addEventListener("load", (function (e) {
          const n = this.response, r = ha[t];
          if (delete ha[t], 200 === this.status || 0 === this.status) {
            0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), aa.add(t, n);
            for (let t = 0, e = r.length; t < e; t++) {
              const e = r[t];
              e.onLoad && e.onLoad(n)
            }
            i.manager.itemEnd(t)
          } else {
            for (let t = 0, n = r.length; t < n; t++) {
              const n = r[t];
              n.onError && n.onError(e)
            }
            i.manager.itemError(t), i.manager.itemEnd(t)
          }
        }), !1), a.addEventListener("progress", (function (e) {
          const n = ha[t];
          for (let t = 0, r = n.length; t < r; t++) {
            const r = n[t];
            r.onProgress && r.onProgress(e)
          }
        }), !1), a.addEventListener("error", (function (e) {
          const n = ha[t];
          delete ha[t];
          for (let t = 0, r = n.length; t < r; t++) {
            const r = n[t];
            r.onError && r.onError(e)
          }
          i.manager.itemError(t), i.manager.itemEnd(t)
        }), !1), a.addEventListener("abort", (function (e) {
          const n = ha[t];
          delete ha[t];
          for (let t = 0, r = n.length; t < r; t++) {
            const r = n[t];
            r.onError && r.onError(e)
          }
          i.manager.itemError(t), i.manager.itemEnd(t)
        }), !1), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
        for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t]);
        a.send(null)
      }
      return i.manager.itemStart(t), a
    }

    setResponseType(t) {
      return this.responseType = t, this
    }

    setMimeType(t) {
      return this.mimeType = t, this
    }
  }

  class da extends ua {
    constructor(t) {
      super(t)
    }

    load(t, e, n, r) {
      void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
      const i = this, o = aa.get(t);
      if (void 0 !== o) return i.manager.itemStart(t), setTimeout((function () {
        e && e(o), i.manager.itemEnd(t)
      }), 0), o;
      const s = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

      function a() {
        s.removeEventListener("load", a, !1), s.removeEventListener("error", c, !1), aa.add(t, this), e && e(this), i.manager.itemEnd(t)
      }

      function c(e) {
        s.removeEventListener("load", a, !1), s.removeEventListener("error", c, !1), r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
      }

      return s.addEventListener("load", a, !1), s.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), i.manager.itemStart(t), s.src = t, s
    }
  }

  class pa extends ua {
    constructor(t) {
      super(t)
    }

    load(t, e, n, r) {
      const i = new Dn, o = new da(this.manager);
      o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
      let s = 0;

      function a(n) {
        o.load(t[n], (function (t) {
          i.images[n] = t, s++, 6 === s && (i.needsUpdate = !0, e && e(i))
        }), void 0, r)
      }

      for (let c = 0; c < t.length; ++c) a(c);
      return i
    }
  }

  class ma extends ua {
    constructor(t) {
      super(t)
    }

    load(t, e, n, r) {
      const i = this, o = new zn, s = new fa(this.manager);
      return s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setPath(this.path), s.setWithCredentials(i.withCredentials), s.load(t, (function (t) {
        const n = i.parse(t);
        n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : m, o.wrapT = void 0 !== n.wrapT ? n.wrapT : m, o.magFilter = void 0 !== n.magFilter ? n.magFilter : b, o.minFilter = void 0 !== n.minFilter ? n.minFilter : b, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (o.encoding = n.encoding), void 0 !== n.flipY && (o.flipY = n.flipY), void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps, o.minFilter = x), 1 === n.mipmapCount && (o.minFilter = b), void 0 !== n.generateMipmaps && (o.generateMipmaps = n.generateMipmaps), o.needsUpdate = !0, e && e(o, n))
      }), n, r), o
    }
  }

  class va extends ua {
    constructor(t) {
      super(t)
    }

    load(t, e, n, r) {
      const i = new ft, o = new da(this.manager);
      return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, (function (n) {
        i.image = n;
        const r = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
        i.format = r ? H : A, i.needsUpdate = !0, void 0 !== e && e(i)
      }), n, r), i
    }
  }

  class ga {
    constructor() {
      this.type = "Curve", this.arcLengthDivisions = 200
    }

    getPoint() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null
    }

    getPointAt(t, e) {
      const n = this.getUtoTmapping(t);
      return this.getPoint(n, e)
    }

    getPoints(t = 5) {
      const e = [];
      for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
      return e
    }

    getSpacedPoints(t = 5) {
      const e = [];
      for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
      return e
    }

    getLength() {
      const t = this.getLengths();
      return t[t.length - 1]
    }

    getLengths(t = this.arcLengthDivisions) {
      if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
      this.needsUpdate = !1;
      const e = [];
      let n, r = this.getPoint(0), i = 0;
      e.push(0);
      for (let o = 1; o <= t; o++) n = this.getPoint(o / t), i += n.distanceTo(r), e.push(i), r = n;
      return this.cacheArcLengths = e, e
    }

    updateArcLengths() {
      this.needsUpdate = !0, this.getLengths()
    }

    getUtoTmapping(t, e) {
      const n = this.getLengths();
      let r = 0;
      const i = n.length;
      let o;
      o = e || t * n[i - 1];
      let s, a = 0, c = i - 1;
      for (; a <= c;) if (r = Math.floor(a + (c - a) / 2), s = n[r] - o, s < 0) a = r + 1; else {
        if (!(s > 0)) {
          c = r;
          break
        }
        c = r - 1
      }
      if (r = c, n[r] === o) return r / (i - 1);
      const l = n[r];
      return (r + (o - l) / (n[r + 1] - l)) / (i - 1)
    }

    getTangent(t, e) {
      const n = 1e-4;
      let r = t - n, i = t + n;
      r < 0 && (r = 0), i > 1 && (i = 1);
      const o = this.getPoint(r), s = this.getPoint(i), a = e || (o.isVector2 ? new at : new gt);
      return a.copy(s).sub(o).normalize(), a
    }

    getTangentAt(t, e) {
      const n = this.getUtoTmapping(t);
      return this.getTangent(n, e)
    }

    computeFrenetFrames(t, e) {
      const n = new gt, r = [], i = [], o = [], s = new gt, a = new Yt;
      for (let f = 0; f <= t; f++) {
        const e = f / t;
        r[f] = this.getTangentAt(e, new gt), r[f].normalize()
      }
      i[0] = new gt, o[0] = new gt;
      let c = Number.MAX_VALUE;
      const l = Math.abs(r[0].x), u = Math.abs(r[0].y), h = Math.abs(r[0].z);
      l <= c && (c = l, n.set(1, 0, 0)), u <= c && (c = u, n.set(0, 1, 0)), h <= c && n.set(0, 0, 1), s.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], s), o[0].crossVectors(r[0], i[0]);
      for (let f = 1; f <= t; f++) {
        if (i[f] = i[f - 1].clone(), o[f] = o[f - 1].clone(), s.crossVectors(r[f - 1], r[f]), s.length() > Number.EPSILON) {
          s.normalize();
          const t = Math.acos(tt(r[f - 1].dot(r[f]), -1, 1));
          i[f].applyMatrix4(a.makeRotationAxis(s, t))
        }
        o[f].crossVectors(r[f], i[f])
      }
      if (!0 === e) {
        let e = Math.acos(tt(i[0].dot(i[t]), -1, 1));
        e /= t, r[0].dot(s.crossVectors(i[0], i[t])) > 0 && (e = -e);
        for (let n = 1; n <= t; n++) i[n].applyMatrix4(a.makeRotationAxis(r[n], e * n)), o[n].crossVectors(r[n], i[n])
      }
      return {tangents: r, normals: i, binormals: o}
    }

    clone() {
      return (new this.constructor).copy(this)
    }

    copy(t) {
      return this.arcLengthDivisions = t.arcLengthDivisions, this
    }

    toJSON() {
      const t = {metadata: {version: 4.5, type: "Curve", generator: "Curve.toJSON"}};
      return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
    }

    fromJSON(t) {
      return this.arcLengthDivisions = t.arcLengthDivisions, this
    }
  }

  class ya extends ga {
    constructor(t = 0, e = 0, n = 1, r = 1, i = 0, o = 2 * Math.PI, s = !1, a = 0) {
      super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = o, this.aClockwise = s, this.aRotation = a
    }

    getPoint(t, e) {
      const n = e || new at, r = 2 * Math.PI;
      let i = this.aEndAngle - this.aStartAngle;
      const o = Math.abs(i) < Number.EPSILON;
      for (; i < 0;) i += r;
      for (; i > r;) i -= r;
      i < Number.EPSILON && (i = o ? 0 : r), !0 !== this.aClockwise || o || (i === r ? i = -r : i -= r);
      const s = this.aStartAngle + t * i;
      let a = this.aX + this.xRadius * Math.cos(s), c = this.aY + this.yRadius * Math.sin(s);
      if (0 !== this.aRotation) {
        const t = Math.cos(this.aRotation), e = Math.sin(this.aRotation), n = a - this.aX, r = c - this.aY;
        a = n * t - r * e + this.aX, c = n * e + r * t + this.aY
      }
      return n.set(a, c)
    }

    copy(t) {
      return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
    }

    toJSON() {
      const t = super.toJSON();
      return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
    }

    fromJSON(t) {
      return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
    }
  }

  ya.prototype.isEllipseCurve = !0;

  class _a extends ya {
    constructor(t, e, n, r, i, o) {
      super(t, e, n, n, r, i, o), this.type = "ArcCurve"
    }
  }

  function ba() {
    let t = 0, e = 0, n = 0, r = 0;

    function i(i, o, s, a) {
      t = i, e = s, n = -3 * i + 3 * o - 2 * s - a, r = 2 * i - 2 * o + s + a
    }

    return {
      initCatmullRom: function (t, e, n, r, o) {
        i(e, n, o * (n - t), o * (r - e))
      }, initNonuniformCatmullRom: function (t, e, n, r, o, s, a) {
        let c = (e - t) / o - (n - t) / (o + s) + (n - e) / s, l = (n - e) / s - (r - e) / (s + a) + (r - n) / a;
        c *= s, l *= s, i(e, n, c, l)
      }, calc: function (i) {
        const o = i * i;
        return t + e * i + n * o + r * (o * i)
      }
    }
  }

  _a.prototype.isArcCurve = !0;
  const xa = new gt, wa = new ba, Sa = new ba, Ma = new ba;

  class Ea extends ga {
    constructor(t = [], e = !1, n = "centripetal", r = .5) {
      super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = r
    }

    getPoint(t, e = new gt) {
      const n = e, r = this.points, i = r.length, o = (i - (this.closed ? 0 : 1)) * t;
      let s, a, c = Math.floor(o), l = o - c;
      this.closed ? c += c > 0 ? 0 : (Math.floor(Math.abs(c) / i) + 1) * i : 0 === l && c === i - 1 && (c = i - 2, l = 1), this.closed || c > 0 ? s = r[(c - 1) % i] : (xa.subVectors(r[0], r[1]).add(r[0]), s = xa);
      const u = r[c % i], h = r[(c + 1) % i];
      if (this.closed || c + 2 < i ? a = r[(c + 2) % i] : (xa.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]), a = xa), "centripetal" === this.curveType || "chordal" === this.curveType) {
        const t = "chordal" === this.curveType ? .5 : .25;
        let e = Math.pow(s.distanceToSquared(u), t), n = Math.pow(u.distanceToSquared(h), t),
          r = Math.pow(h.distanceToSquared(a), t);
        n < 1e-4 && (n = 1), e < 1e-4 && (e = n), r < 1e-4 && (r = n), wa.initNonuniformCatmullRom(s.x, u.x, h.x, a.x, e, n, r), Sa.initNonuniformCatmullRom(s.y, u.y, h.y, a.y, e, n, r), Ma.initNonuniformCatmullRom(s.z, u.z, h.z, a.z, e, n, r)
      } else "catmullrom" === this.curveType && (wa.initCatmullRom(s.x, u.x, h.x, a.x, this.tension), Sa.initCatmullRom(s.y, u.y, h.y, a.y, this.tension), Ma.initCatmullRom(s.z, u.z, h.z, a.z, this.tension));
      return n.set(wa.calc(l), Sa.calc(l), Ma.calc(l)), n
    }

    copy(t) {
      super.copy(t), this.points = [];
      for (let e = 0, n = t.points.length; e < n; e++) {
        const n = t.points[e];
        this.points.push(n.clone())
      }
      return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }

    toJSON() {
      const t = super.toJSON();
      t.points = [];
      for (let e = 0, n = this.points.length; e < n; e++) {
        const n = this.points[e];
        t.points.push(n.toArray())
      }
      return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
    }

    fromJSON(t) {
      super.fromJSON(t), this.points = [];
      for (let e = 0, n = t.points.length; e < n; e++) {
        const n = t.points[e];
        this.points.push((new gt).fromArray(n))
      }
      return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }
  }

  function Ta(t, e, n, r, i) {
    const o = .5 * (r - e), s = .5 * (i - n), a = t * t;
    return (2 * n - 2 * r + o + s) * (t * a) + (-3 * n + 3 * r - 2 * o - s) * a + o * t + n
  }

  function Oa(t, e, n, r) {
    return function (t, e) {
      const n = 1 - t;
      return n * n * e
    }(t, e) + function (t, e) {
      return 2 * (1 - t) * t * e
    }(t, n) + function (t, e) {
      return t * t * e
    }(t, r)
  }

  function Ha(t, e, n, r, i) {
    return function (t, e) {
      const n = 1 - t;
      return n * n * n * e
    }(t, e) + function (t, e) {
      const n = 1 - t;
      return 3 * n * n * t * e
    }(t, n) + function (t, e) {
      return 3 * (1 - t) * t * t * e
    }(t, r) + function (t, e) {
      return t * t * t * e
    }(t, i)
  }

  Ea.prototype.isCatmullRomCurve3 = !0;

  class Aa extends ga {
    constructor(t = new at, e = new at, n = new at, r = new at) {
      super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r
    }

    getPoint(t, e = new at) {
      const n = e, r = this.v0, i = this.v1, o = this.v2, s = this.v3;
      return n.set(Ha(t, r.x, i.x, o.x, s.x), Ha(t, r.y, i.y, o.y, s.y)), n
    }

    copy(t) {
      return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
    }

    toJSON() {
      const t = super.toJSON();
      return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
    }

    fromJSON(t) {
      return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
    }
  }

  Aa.prototype.isCubicBezierCurve = !0;

  class Pa extends ga {
    constructor(t = new gt, e = new gt, n = new gt, r = new gt) {
      super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r
    }

    getPoint(t, e = new gt) {
      const n = e, r = this.v0, i = this.v1, o = this.v2, s = this.v3;
      return n.set(Ha(t, r.x, i.x, o.x, s.x), Ha(t, r.y, i.y, o.y, s.y), Ha(t, r.z, i.z, o.z, s.z)), n
    }

    copy(t) {
      return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
    }

    toJSON() {
      const t = super.toJSON();
      return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
    }

    fromJSON(t) {
      return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
    }
  }

  Pa.prototype.isCubicBezierCurve3 = !0;

  class Ra extends ga {
    constructor(t = new at, e = new at) {
      super(), this.type = "LineCurve", this.v1 = t, this.v2 = e
    }

    getPoint(t, e = new at) {
      const n = e;
      return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
    }

    getPointAt(t, e) {
      return this.getPoint(t, e)
    }

    getTangent(t, e) {
      const n = e || new at;
      return n.copy(this.v2).sub(this.v1).normalize(), n
    }

    copy(t) {
      return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }

    toJSON() {
      const t = super.toJSON();
      return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }

    fromJSON(t) {
      return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }
  }

  Ra.prototype.isLineCurve = !0;

  class La extends ga {
    constructor(t = new at, e = new at, n = new at) {
      super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n
    }

    getPoint(t, e = new at) {
      const n = e, r = this.v0, i = this.v1, o = this.v2;
      return n.set(Oa(t, r.x, i.x, o.x), Oa(t, r.y, i.y, o.y)), n
    }

    copy(t) {
      return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }

    toJSON() {
      const t = super.toJSON();
      return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }

    fromJSON(t) {
      return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }
  }

  La.prototype.isQuadraticBezierCurve = !0;

  class Ca extends ga {
    constructor(t = new gt, e = new gt, n = new gt) {
      super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n
    }

    getPoint(t, e = new gt) {
      const n = e, r = this.v0, i = this.v1, o = this.v2;
      return n.set(Oa(t, r.x, i.x, o.x), Oa(t, r.y, i.y, o.y), Oa(t, r.z, i.z, o.z)), n
    }

    copy(t) {
      return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }

    toJSON() {
      const t = super.toJSON();
      return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }

    fromJSON(t) {
      return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }
  }

  Ca.prototype.isQuadraticBezierCurve3 = !0;

  class ka extends ga {
    constructor(t = []) {
      super(), this.type = "SplineCurve", this.points = t
    }

    getPoint(t, e = new at) {
      const n = e, r = this.points, i = (r.length - 1) * t, o = Math.floor(i), s = i - o, a = r[0 === o ? o : o - 1],
        c = r[o], l = r[o > r.length - 2 ? r.length - 1 : o + 1], u = r[o > r.length - 3 ? r.length - 1 : o + 2];
      return n.set(Ta(s, a.x, c.x, l.x, u.x), Ta(s, a.y, c.y, l.y, u.y)), n
    }

    copy(t) {
      super.copy(t), this.points = [];
      for (let e = 0, n = t.points.length; e < n; e++) {
        const n = t.points[e];
        this.points.push(n.clone())
      }
      return this
    }

    toJSON() {
      const t = super.toJSON();
      t.points = [];
      for (let e = 0, n = this.points.length; e < n; e++) {
        const n = this.points[e];
        t.points.push(n.toArray())
      }
      return t
    }

    fromJSON(t) {
      super.fromJSON(t), this.points = [];
      for (let e = 0, n = t.points.length; e < n; e++) {
        const n = t.points[e];
        this.points.push((new at).fromArray(n))
      }
      return this
    }
  }

  ka.prototype.isSplineCurve = !0;
  var Da = Object.freeze({
    __proto__: null,
    ArcCurve: _a,
    CatmullRomCurve3: Ea,
    CubicBezierCurve: Aa,
    CubicBezierCurve3: Pa,
    EllipseCurve: ya,
    LineCurve: Ra,
    LineCurve3: class extends ga {
      constructor(t = new gt, e = new gt) {
        super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e
      }

      getPoint(t, e = new gt) {
        const n = e;
        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
      }

      getPointAt(t, e) {
        return this.getPoint(t, e)
      }

      copy(t) {
        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
      }

      toJSON() {
        const t = super.toJSON();
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
      }

      fromJSON(t) {
        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
      }
    },
    QuadraticBezierCurve: La,
    QuadraticBezierCurve3: Ca,
    SplineCurve: ka
  });

  class Na extends ga {
    constructor() {
      super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }

    add(t) {
      this.curves.push(t)
    }

    closePath() {
      const t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
      t.equals(e) || this.curves.push(new Ra(e, t))
    }

    getPoint(t) {
      const e = t * this.getLength(), n = this.getCurveLengths();
      let r = 0;
      for (; r < n.length;) {
        if (n[r] >= e) {
          const t = n[r] - e, i = this.curves[r], o = i.getLength(), s = 0 === o ? 0 : 1 - t / o;
          return i.getPointAt(s)
        }
        r++
      }
      return null
    }

    getLength() {
      const t = this.getCurveLengths();
      return t[t.length - 1]
    }

    updateArcLengths() {
      this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
    }

    getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
      const t = [];
      let e = 0;
      for (let n = 0, r = this.curves.length; n < r; n++) e += this.curves[n].getLength(), t.push(e);
      return this.cacheLengths = t, t
    }

    getSpacedPoints(t = 40) {
      const e = [];
      for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
      return this.autoClose && e.push(e[0]), e
    }

    getPoints(t = 12) {
      const e = [];
      let n;
      for (let r = 0, i = this.curves; r < i.length; r++) {
        const o = i[r],
          s = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t,
          a = o.getPoints(s);
        for (let t = 0; t < a.length; t++) {
          const r = a[t];
          n && n.equals(r) || (e.push(r), n = r)
        }
      }
      return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
    }

    copy(t) {
      super.copy(t), this.curves = [];
      for (let e = 0, n = t.curves.length; e < n; e++) {
        const n = t.curves[e];
        this.curves.push(n.clone())
      }
      return this.autoClose = t.autoClose, this
    }

    toJSON() {
      const t = super.toJSON();
      t.autoClose = this.autoClose, t.curves = [];
      for (let e = 0, n = this.curves.length; e < n; e++) {
        const n = this.curves[e];
        t.curves.push(n.toJSON())
      }
      return t
    }

    fromJSON(t) {
      super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
      for (let e = 0, n = t.curves.length; e < n; e++) {
        const n = t.curves[e];
        this.curves.push((new Da[n.type]).fromJSON(n))
      }
      return this
    }
  }

  class za extends Na {
    constructor(t) {
      super(), this.type = "Path", this.currentPoint = new at, t && this.setFromPoints(t)
    }

    setFromPoints(t) {
      this.moveTo(t[0].x, t[0].y);
      for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
      return this
    }

    moveTo(t, e) {
      return this.currentPoint.set(t, e), this
    }

    lineTo(t, e) {
      const n = new Ra(this.currentPoint.clone(), new at(t, e));
      return this.curves.push(n), this.currentPoint.set(t, e), this
    }

    quadraticCurveTo(t, e, n, r) {
      const i = new La(this.currentPoint.clone(), new at(t, e), new at(n, r));
      return this.curves.push(i), this.currentPoint.set(n, r), this
    }

    bezierCurveTo(t, e, n, r, i, o) {
      const s = new Aa(this.currentPoint.clone(), new at(t, e), new at(n, r), new at(i, o));
      return this.curves.push(s), this.currentPoint.set(i, o), this
    }

    splineThru(t) {
      const e = [this.currentPoint.clone()].concat(t), n = new ka(e);
      return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
    }

    arc(t, e, n, r, i, o) {
      const s = this.currentPoint.x, a = this.currentPoint.y;
      return this.absarc(t + s, e + a, n, r, i, o), this
    }

    absarc(t, e, n, r, i, o) {
      return this.absellipse(t, e, n, n, r, i, o), this
    }

    ellipse(t, e, n, r, i, o, s, a) {
      const c = this.currentPoint.x, l = this.currentPoint.y;
      return this.absellipse(t + c, e + l, n, r, i, o, s, a), this
    }

    absellipse(t, e, n, r, i, o, s, a) {
      const c = new ya(t, e, n, r, i, o, s, a);
      if (this.curves.length > 0) {
        const t = c.getPoint(0);
        t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
      }
      this.curves.push(c);
      const l = c.getPoint(1);
      return this.currentPoint.copy(l), this
    }

    copy(t) {
      return super.copy(t), this.currentPoint.copy(t.currentPoint), this
    }

    toJSON() {
      const t = super.toJSON();
      return t.currentPoint = this.currentPoint.toArray(), t
    }

    fromJSON(t) {
      return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
    }
  }

  class ja extends za {
    constructor(t) {
      super(t), this.uuid = $(), this.type = "Shape", this.holes = []
    }

    getPointsHoles(t) {
      const e = [];
      for (let n = 0, r = this.holes.length; n < r; n++) e[n] = this.holes[n].getPoints(t);
      return e
    }

    extractPoints(t) {
      return {shape: this.getPoints(t), holes: this.getPointsHoles(t)}
    }

    copy(t) {
      super.copy(t), this.holes = [];
      for (let e = 0, n = t.holes.length; e < n; e++) {
        const n = t.holes[e];
        this.holes.push(n.clone())
      }
      return this
    }

    toJSON() {
      const t = super.toJSON();
      t.uuid = this.uuid, t.holes = [];
      for (let e = 0, n = this.holes.length; e < n; e++) {
        const n = this.holes[e];
        t.holes.push(n.toJSON())
      }
      return t
    }

    fromJSON(t) {
      super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
      for (let e = 0, n = t.holes.length; e < n; e++) {
        const n = t.holes[e];
        this.holes.push((new za).fromJSON(n))
      }
      return this
    }
  }

  class Ia extends _e {
    constructor(t, e = 1) {
      super(), this.type = "Light", this.color = new Ge(t), this.intensity = e
    }

    dispose() {
    }

    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this
    }

    toJSON(t) {
      const e = super.toJSON(t);
      return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
    }
  }

  Ia.prototype.isLight = !0;

  class Ba extends Ia {
    constructor(t, e, n) {
      super(t, n), this.type = "HemisphereLight", this.position.copy(_e.DefaultUp), this.updateMatrix(), this.groundColor = new Ge(e)
    }

    copy(t) {
      return Ia.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
    }
  }

  Ba.prototype.isHemisphereLight = !0;
  const Fa = new Yt, Ua = new gt, Ga = new gt;

  class Va {
    constructor(t) {
      this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new at(512, 512), this.map = null, this.mapPass = null, this.matrix = new Yt, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Bn, this._frameExtents = new at(1, 1), this._viewportCount = 1, this._viewports = [new pt(0, 0, 1, 1)]
    }

    getViewportCount() {
      return this._viewportCount
    }

    getFrustum() {
      return this._frustum
    }

    updateMatrices(t) {
      const e = this.camera, n = this.matrix;
      Ua.setFromMatrixPosition(t.matrixWorld), e.position.copy(Ua), Ga.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Ga), e.updateMatrixWorld(), Fa.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Fa), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
    }

    getViewport(t) {
      return this._viewports[t]
    }

    getFrameExtents() {
      return this._frameExtents
    }

    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
    }

    copy(t) {
      return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
    }

    clone() {
      return (new this.constructor).copy(this)
    }

    toJSON() {
      const t = {};
      return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
    }
  }

  class Wa extends Va {
    constructor() {
      super(new Ln(50, 1, .5, 500)), this.focus = 1
    }

    updateMatrices(t) {
      const e = this.camera, n = 2 * Q * t.angle * this.focus, r = this.mapSize.width / this.mapSize.height,
        i = t.distance || e.far;
      n === e.fov && r === e.aspect && i === e.far || (e.fov = n, e.aspect = r, e.far = i, e.updateProjectionMatrix()), super.updateMatrices(t)
    }

    copy(t) {
      return super.copy(t), this.focus = t.focus, this
    }
  }

  Wa.prototype.isSpotLightShadow = !0;

  class Xa extends Ia {
    constructor(t, e, n = 0, r = Math.PI / 3, i = 0, o = 1) {
      super(t, e), this.type = "SpotLight", this.position.copy(_e.DefaultUp), this.updateMatrix(), this.target = new _e, this.distance = n, this.angle = r, this.penumbra = i, this.decay = o, this.shadow = new Wa
    }

    get power() {
      return this.intensity * Math.PI
    }

    set power(t) {
      this.intensity = t / Math.PI
    }

    dispose() {
      this.shadow.dispose()
    }

    copy(t) {
      return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
    }
  }

  Xa.prototype.isSpotLight = !0;
  const qa = new Yt, Ya = new gt, Za = new gt;

  class Ja extends Va {
    constructor() {
      super(new Ln(90, 1, .5, 500)), this._frameExtents = new at(4, 2), this._viewportCount = 6, this._viewports = [new pt(2, 1, 1, 1), new pt(0, 1, 1, 1), new pt(3, 1, 1, 1), new pt(1, 1, 1, 1), new pt(3, 0, 1, 1), new pt(1, 0, 1, 1)], this._cubeDirections = [new gt(1, 0, 0), new gt(-1, 0, 0), new gt(0, 0, 1), new gt(0, 0, -1), new gt(0, 1, 0), new gt(0, -1, 0)], this._cubeUps = [new gt(0, 1, 0), new gt(0, 1, 0), new gt(0, 1, 0), new gt(0, 1, 0), new gt(0, 0, 1), new gt(0, 0, -1)]
    }

    updateMatrices(t, e = 0) {
      const n = this.camera, r = this.matrix, i = t.distance || n.far;
      i !== n.far && (n.far = i, n.updateProjectionMatrix()), Ya.setFromMatrixPosition(t.matrixWorld), n.position.copy(Ya), Za.copy(n.position), Za.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Za), n.updateMatrixWorld(), r.makeTranslation(-Ya.x, -Ya.y, -Ya.z), qa.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(qa)
    }
  }

  Ja.prototype.isPointLightShadow = !0;

  class Ka extends Ia {
    constructor(t, e, n = 0, r = 1) {
      super(t, e), this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new Ja
    }

    get power() {
      return 4 * this.intensity * Math.PI
    }

    set power(t) {
      this.intensity = t / (4 * Math.PI)
    }

    dispose() {
      this.shadow.dispose()
    }

    copy(t) {
      return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
    }
  }

  Ka.prototype.isPointLight = !0;

  class Qa extends Rn {
    constructor(t = -1, e = 1, n = 1, r = -1, i = .1, o = 2e3) {
      super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = r, this.near = i, this.far = o, this.updateProjectionMatrix()
    }

    copy(t, e) {
      return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
    }

    setViewOffset(t, e, n, r, i, o) {
      null === this.view && (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
    }

    clearViewOffset() {
      null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
    }

    updateProjectionMatrix() {
      const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom),
        n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
      let i = n - t, o = n + t, s = r + e, a = r - e;
      if (null !== this.view && this.view.enabled) {
        const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
          e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        i += t * this.view.offsetX, o = i + t * this.view.width, s -= e * this.view.offsetY, a = s - e * this.view.height
      }
      this.projectionMatrix.makeOrthographic(i, o, s, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }

    toJSON(t) {
      const e = super.toJSON(t);
      return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
    }
  }

  Qa.prototype.isOrthographicCamera = !0;

  class $a extends Va {
    constructor() {
      super(new Qa(-5, 5, 5, -5, .5, 500))
    }
  }

  $a.prototype.isDirectionalLightShadow = !0;

  class tc extends Ia {
    constructor(t, e) {
      super(t, e), this.type = "DirectionalLight", this.position.copy(_e.DefaultUp), this.updateMatrix(), this.target = new _e, this.shadow = new $a
    }

    dispose() {
      this.shadow.dispose()
    }

    copy(t) {
      return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
    }
  }

  tc.prototype.isDirectionalLight = !0;

  class ec extends Ia {
    constructor(t, e) {
      super(t, e), this.type = "AmbientLight"
    }
  }

  ec.prototype.isAmbientLight = !0;

  class nc extends Ia {
    constructor(t, e, n = 10, r = 10) {
      super(t, e), this.type = "RectAreaLight", this.width = n, this.height = r
    }

    copy(t) {
      return super.copy(t), this.width = t.width, this.height = t.height, this
    }

    toJSON(t) {
      const e = super.toJSON(t);
      return e.object.width = this.width, e.object.height = this.height, e
    }
  }

  nc.prototype.isRectAreaLight = !0;

  class rc {
    constructor() {
      this.coefficients = [];
      for (let t = 0; t < 9; t++) this.coefficients.push(new gt)
    }

    set(t) {
      for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
      return this
    }

    zero() {
      for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
      return this
    }

    getAt(t, e) {
      const n = t.x, r = t.y, i = t.z, o = this.coefficients;
      return e.copy(o[0]).multiplyScalar(.282095), e.addScaledVector(o[1], .488603 * r), e.addScaledVector(o[2], .488603 * i), e.addScaledVector(o[3], .488603 * n), e.addScaledVector(o[4], n * r * 1.092548), e.addScaledVector(o[5], r * i * 1.092548), e.addScaledVector(o[6], .315392 * (3 * i * i - 1)), e.addScaledVector(o[7], n * i * 1.092548), e.addScaledVector(o[8], .546274 * (n * n - r * r)), e
    }

    getIrradianceAt(t, e) {
      const n = t.x, r = t.y, i = t.z, o = this.coefficients;
      return e.copy(o[0]).multiplyScalar(.886227), e.addScaledVector(o[1], 1.023328 * r), e.addScaledVector(o[2], 1.023328 * i), e.addScaledVector(o[3], 1.023328 * n), e.addScaledVector(o[4], .858086 * n * r), e.addScaledVector(o[5], .858086 * r * i), e.addScaledVector(o[6], .743125 * i * i - .247708), e.addScaledVector(o[7], .858086 * n * i), e.addScaledVector(o[8], .429043 * (n * n - r * r)), e
    }

    add(t) {
      for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
      return this
    }

    addScaledSH(t, e) {
      for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);
      return this
    }

    scale(t) {
      for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
      return this
    }

    lerp(t, e) {
      for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
      return this
    }

    equals(t) {
      for (let e = 0; e < 9; e++) if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
      return !0
    }

    copy(t) {
      return this.set(t.coefficients)
    }

    clone() {
      return (new this.constructor).copy(this)
    }

    fromArray(t, e = 0) {
      const n = this.coefficients;
      for (let r = 0; r < 9; r++) n[r].fromArray(t, e + 3 * r);
      return this
    }

    toArray(t = [], e = 0) {
      const n = this.coefficients;
      for (let r = 0; r < 9; r++) n[r].toArray(t, e + 3 * r);
      return t
    }

    static getBasisAt(t, e) {
      const n = t.x, r = t.y, i = t.z;
      e[0] = .282095, e[1] = .488603 * r, e[2] = .488603 * i, e[3] = .488603 * n, e[4] = 1.092548 * n * r, e[5] = 1.092548 * r * i, e[6] = .315392 * (3 * i * i - 1), e[7] = 1.092548 * n * i, e[8] = .546274 * (n * n - r * r)
    }
  }

  rc.prototype.isSphericalHarmonics3 = !0;

  class ic extends Ia {
    constructor(t = new rc, e = 1) {
      super(void 0, e), this.sh = t
    }

    copy(t) {
      return super.copy(t), this.sh.copy(t.sh), this
    }

    fromJSON(t) {
      return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
    }

    toJSON(t) {
      const e = super.toJSON(t);
      return e.object.sh = this.sh.toArray(), e
    }
  }

  ic.prototype.isLightProbe = !0;

  class oc {
    static decodeText(t) {
      if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
      let e = "";
      for (let r = 0, i = t.length; r < i; r++) e += String.fromCharCode(t[r]);
      try {
        return decodeURIComponent(escape(e))
      } catch (n) {
        return e
      }
    }

    static extractUrlBase(t) {
      const e = t.lastIndexOf("/");
      return -1 === e ? "./" : t.substr(0, e + 1)
    }
  }

  class sc extends sn {
    constructor() {
      super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
    }

    copy(t) {
      return super.copy(t), this.instanceCount = t.instanceCount, this
    }

    clone() {
      return (new this.constructor).copy(this)
    }

    toJSON() {
      const t = super.toJSON(this);
      return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
    }
  }

  sc.prototype.isInstancedBufferGeometry = !0;

  class ac extends qe {
    constructor(t, e, n, r) {
      "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, n), this.meshPerAttribute = r || 1
    }

    copy(t) {
      return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
    }

    toJSON() {
      const t = super.toJSON();
      return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
    }
  }

  ac.prototype.isInstancedBufferAttribute = !0;
  (class extends ua {
    constructor(t) {
      super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {premultiplyAlpha: "none"}
    }

    setOptions(t) {
      return this.options = t, this
    }

    load(t, e, n, r) {
      void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
      const i = this, o = aa.get(t);
      if (void 0 !== o) return i.manager.itemStart(t), setTimeout((function () {
        e && e(o), i.manager.itemEnd(t)
      }), 0), o;
      const s = {};
      s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", s.headers = this.requestHeader, fetch(t, s).then((function (t) {
        return t.blob()
      })).then((function (t) {
        return createImageBitmap(t, Object.assign(i.options, {colorSpaceConversion: "none"}))
      })).then((function (n) {
        aa.add(t, n), e && e(n), i.manager.itemEnd(t)
      })).catch((function (e) {
        r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
      })), i.manager.itemStart(t)
    }
  }).prototype.isImageBitmapLoader = !0;

  class cc {
    constructor() {
      this.type = "ShapePath", this.color = new Ge, this.subPaths = [], this.currentPath = null
    }

    moveTo(t, e) {
      return this.currentPath = new za, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
    }

    lineTo(t, e) {
      return this.currentPath.lineTo(t, e), this
    }

    quadraticCurveTo(t, e, n, r) {
      return this.currentPath.quadraticCurveTo(t, e, n, r), this
    }

    bezierCurveTo(t, e, n, r, i, o) {
      return this.currentPath.bezierCurveTo(t, e, n, r, i, o), this
    }

    splineThru(t) {
      return this.currentPath.splineThru(t), this
    }

    toShapes(t, e) {
      function n(t) {
        const e = [];
        for (let n = 0, r = t.length; n < r; n++) {
          const r = t[n], i = new ja;
          i.curves = r.curves, e.push(i)
        }
        return e
      }

      function r(t, e) {
        const n = e.length;
        let r = !1;
        for (let i = n - 1, o = 0; o < n; i = o++) {
          let n = e[i], s = e[o], a = s.x - n.x, c = s.y - n.y;
          if (Math.abs(c) > Number.EPSILON) {
            if (c < 0 && (n = e[o], a = -a, s = e[i], c = -c), t.y < n.y || t.y > s.y) continue;
            if (t.y === n.y) {
              if (t.x === n.x) return !0
            } else {
              const e = c * (t.x - n.x) - a * (t.y - n.y);
              if (0 === e) return !0;
              if (e < 0) continue;
              r = !r
            }
          } else {
            if (t.y !== n.y) continue;
            if (s.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= s.x) return !0
          }
        }
        return r
      }

      const i = As.isClockWise, o = this.subPaths;
      if (0 === o.length) return [];
      if (!0 === e) return n(o);
      let s, a, c;
      const l = [];
      if (1 === o.length) return a = o[0], c = new ja, c.curves = a.curves, l.push(c), l;
      let u = !i(o[0].getPoints());
      u = t ? !u : u;
      const h = [], f = [];
      let d, p, m = [], v = 0;
      f[v] = void 0, m[v] = [];
      for (let g = 0, y = o.length; g < y; g++) a = o[g], d = a.getPoints(), s = i(d), s = t ? !s : s, s ? (!u && f[v] && v++, f[v] = {
        s: new ja,
        p: d
      }, f[v].s.curves = a.curves, u && v++, m[v] = []) : m[v].push({h: a, p: d[0]});
      if (!f[0]) return n(o);
      if (f.length > 1) {
        let t = !1;
        const e = [];
        for (let n = 0, r = f.length; n < r; n++) h[n] = [];
        for (let n = 0, i = f.length; n < i; n++) {
          const i = m[n];
          for (let o = 0; o < i.length; o++) {
            const s = i[o];
            let a = !0;
            for (let i = 0; i < f.length; i++) r(s.p, f[i].p) && (n !== i && e.push({
              froms: n,
              tos: i,
              hole: o
            }), a ? (a = !1, h[i].push(s)) : t = !0);
            a && h[n].push(s)
          }
        }
        e.length > 0 && (t || (m = h))
      }
      for (let g = 0, y = f.length; g < y; g++) {
        c = f[g].s, l.push(c), p = m[g];
        for (let t = 0, e = p.length; t < e; t++) c.holes.push(p[t].h)
      }
      return l
    }
  }

  class lc {
    constructor(t) {
      this.type = "Font", this.data = t
    }

    generateShapes(t, e = 100) {
      const n = [], r = function (t, e, n) {
        const r = Array.from(t), i = e / n.resolution,
          o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * i, s = [];
        let a = 0, c = 0;
        for (let l = 0; l < r.length; l++) {
          const t = r[l];
          if ("\n" === t) a = 0, c -= o; else {
            const e = uc(t, i, a, c, n);
            a += e.offsetX, s.push(e.path)
          }
        }
        return s
      }(t, e, this.data);
      for (let i = 0, o = r.length; i < o; i++) Array.prototype.push.apply(n, r[i].toShapes());
      return n
    }
  }

  function uc(t, e, n, r, i) {
    const o = i.glyphs[t] || i.glyphs["?"];
    if (!o) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + i.familyName + ".");
    const s = new cc;
    let a, c, l, u, h, f, d, p;
    if (o.o) {
      const t = o._cachedOutline || (o._cachedOutline = o.o.split(" "));
      for (let i = 0, o = t.length; i < o;) {
        switch (t[i++]) {
          case"m":
            a = t[i++] * e + n, c = t[i++] * e + r, s.moveTo(a, c);
            break;
          case"l":
            a = t[i++] * e + n, c = t[i++] * e + r, s.lineTo(a, c);
            break;
          case"q":
            l = t[i++] * e + n, u = t[i++] * e + r, h = t[i++] * e + n, f = t[i++] * e + r, s.quadraticCurveTo(h, f, l, u);
            break;
          case"b":
            l = t[i++] * e + n, u = t[i++] * e + r, h = t[i++] * e + n, f = t[i++] * e + r, d = t[i++] * e + n, p = t[i++] * e + r, s.bezierCurveTo(h, f, d, p, l, u)
        }
      }
    }
    return {offsetX: o.ha * e, path: s}
  }

  lc.prototype.isFont = !0;
  let hc;
  const fc = function () {
    return void 0 === hc && (hc = new (window.AudioContext || window.webkitAudioContext)), hc
  };

  class dc extends ua {
    constructor(t) {
      super(t)
    }

    load(t, e, n, r) {
      const i = this, o = new fa(this.manager);
      o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, (function (n) {
        try {
          const t = n.slice(0);
          fc().decodeAudioData(t, (function (t) {
            e(t)
          }))
        } catch (o) {
          r ? r(o) : console.error(o), i.manager.itemError(t)
        }
      }), n, r)
    }
  }

  (class extends ic {
    constructor(t, e, n = 1) {
      super(void 0, n);
      const r = (new Ge).set(t), i = (new Ge).set(e), o = new gt(r.r, r.g, r.b), s = new gt(i.r, i.g, i.b),
        a = Math.sqrt(Math.PI), c = a * Math.sqrt(.75);
      this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a), this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(c)
    }
  }).prototype.isHemisphereLightProbe = !0;
  (class extends ic {
    constructor(t, e = 1) {
      super(void 0, e);
      const n = (new Ge).set(t);
      this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
  }).prototype.isAmbientLightProbe = !0;

  class pc {
    constructor(t = !0) {
      this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
    }

    start() {
      this.startTime = mc(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
    }

    stop() {
      this.getElapsedTime(), this.running = !1, this.autoStart = !1
    }

    getElapsedTime() {
      return this.getDelta(), this.elapsedTime
    }

    getDelta() {
      let t = 0;
      if (this.autoStart && !this.running) return this.start(), 0;
      if (this.running) {
        const e = mc();
        t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
      }
      return t
    }
  }

  function mc() {
    return ("undefined" == typeof performance ? Date : performance).now()
  }

  class vc extends _e {
    constructor(t) {
      super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
    }

    getOutput() {
      return this.gain
    }

    setNodeSource(t) {
      return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
    }

    setMediaElementSource(t) {
      return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
    }

    setMediaStreamSource(t) {
      return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
    }

    setBuffer(t) {
      return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
    }

    play(t = 0) {
      if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
      if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
      this._startedAt = this.context.currentTime + t;
      const e = this.context.createBufferSource();
      return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
    }

    pause() {
      if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
      console.warn("THREE.Audio: this Audio has no playback control.")
    }

    stop() {
      if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
      console.warn("THREE.Audio: this Audio has no playback control.")
    }

    connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
        this.filters[this.filters.length - 1].connect(this.getOutput())
      } else this.source.connect(this.getOutput());
      return this._connected = !0, this
    }

    disconnect() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput())
      } else this.source.disconnect(this.getOutput());
      return this._connected = !1, this
    }

    getFilters() {
      return this.filters
    }

    setFilters(t) {
      return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this
    }

    setDetune(t) {
      if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
    }

    getDetune() {
      return this.detune
    }

    getFilter() {
      return this.getFilters()[0]
    }

    setFilter(t) {
      return this.setFilters(t ? [t] : [])
    }

    setPlaybackRate(t) {
      if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
      console.warn("THREE.Audio: this Audio has no playback control.")
    }

    getPlaybackRate() {
      return this.playbackRate
    }

    onEnded() {
      this.isPlaying = !1
    }

    getLoop() {
      return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
    }

    setLoop(t) {
      if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
      console.warn("THREE.Audio: this Audio has no playback control.")
    }

    setLoopStart(t) {
      return this.loopStart = t, this
    }

    setLoopEnd(t) {
      return this.loopEnd = t, this
    }

    getVolume() {
      return this.gain.gain.value
    }

    setVolume(t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
    }
  }

  class gc {
    constructor(t, e, n) {
      let r, i, o;
      switch (this.binding = t, this.valueSize = n, e) {
        case"quaternion":
          r = this._slerp, i = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
          break;
        case"string":
        case"bool":
          r = this._select, i = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
          break;
        default:
          r = this._lerp, i = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
      }
      this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
    }

    accumulate(t, e) {
      const n = this.buffer, r = this.valueSize, i = t * r + r;
      let o = this.cumulativeWeight;
      if (0 === o) {
        for (let t = 0; t !== r; ++t) n[i + t] = n[t];
        o = e
      } else {
        o += e;
        const t = e / o;
        this._mixBufferRegion(n, i, 0, t, r)
      }
      this.cumulativeWeight = o
    }

    accumulateAdditive(t) {
      const e = this.buffer, n = this.valueSize, r = n * this._addIndex;
      0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, r, 0, t, n), this.cumulativeWeightAdditive += t
    }

    apply(t) {
      const e = this.valueSize, n = this.buffer, r = t * e + e, i = this.cumulativeWeight,
        o = this.cumulativeWeightAdditive, s = this.binding;
      if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) {
        const t = e * this._origIndex;
        this._mixBufferRegion(n, r, t, 1 - i, e)
      }
      o > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * e, 1, e);
      for (let a = e, c = e + e; a !== c; ++a) if (n[a] !== n[a + e]) {
        s.setValue(n, r);
        break
      }
    }

    saveOriginalState() {
      const t = this.binding, e = this.buffer, n = this.valueSize, r = n * this._origIndex;
      t.getValue(e, r);
      for (let i = n, o = r; i !== o; ++i) e[i] = e[r + i % n];
      this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
    }

    restoreOriginalState() {
      const t = 3 * this.valueSize;
      this.binding.setValue(this.buffer, t)
    }

    _setAdditiveIdentityNumeric() {
      const t = this._addIndex * this.valueSize, e = t + this.valueSize;
      for (let n = t; n < e; n++) this.buffer[n] = 0
    }

    _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
    }

    _setAdditiveIdentityOther() {
      const t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize;
      for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
    }

    _select(t, e, n, r, i) {
      if (r >= .5) for (let o = 0; o !== i; ++o) t[e + o] = t[n + o]
    }

    _slerp(t, e, n, r) {
      vt.slerpFlat(t, e, t, e, t, n, r)
    }

    _slerpAdditive(t, e, n, r, i) {
      const o = this._workIndex * i;
      vt.multiplyQuaternionsFlat(t, o, t, e, t, n), vt.slerpFlat(t, e, t, e, t, o, r)
    }

    _lerp(t, e, n, r, i) {
      const o = 1 - r;
      for (let s = 0; s !== i; ++s) {
        const i = e + s;
        t[i] = t[i] * o + t[n + s] * r
      }
    }

    _lerpAdditive(t, e, n, r, i) {
      for (let o = 0; o !== i; ++o) {
        const i = e + o;
        t[i] = t[i] + t[n + o] * r
      }
    }
  }

  const yc = "\\[\\]\\.:\\/", _c = new RegExp("[\\[\\]\\.:\\/]", "g"), bc = "[^\\[\\]\\.:\\/]",
    xc = "[^" + yc.replace("\\.", "") + "]", wc = /((?:WC+[\/:])*)/.source.replace("WC", bc),
    Sc = /(WCOD+)?/.source.replace("WCOD", xc), Mc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", bc),
    Ec = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", bc), Tc = new RegExp("^" + wc + Sc + Mc + Ec + "$"),
    Oc = ["material", "materials", "bones"];

  class Hc {
    constructor(t, e, n) {
      this.path = e, this.parsedPath = n || Hc.parseTrackName(e), this.node = Hc.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }

    static create(t, e, n) {
      return t && t.isAnimationObjectGroup ? new Hc.Composite(t, e, n) : new Hc(t, e, n)
    }

    static sanitizeNodeName(t) {
      return t.replace(/\s/g, "_").replace(_c, "")
    }

    static parseTrackName(t) {
      const e = Tc.exec(t);
      if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
      const n = {nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6]},
        r = n.nodeName && n.nodeName.lastIndexOf(".");
      if (void 0 !== r && -1 !== r) {
        const t = n.nodeName.substring(r + 1);
        -1 !== Oc.indexOf(t) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = t)
      }
      if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
      return n
    }

    static findNode(t, e) {
      if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
      if (t.skeleton) {
        const n = t.skeleton.getBoneByName(e);
        if (void 0 !== n) return n
      }
      if (t.children) {
        const n = function (t) {
          for (let r = 0; r < t.length; r++) {
            const i = t[r];
            if (i.name === e || i.uuid === e) return i;
            const o = n(i.children);
            if (o) return o
          }
          return null
        }, r = n(t.children);
        if (r) return r
      }
      return null
    }

    _getValue_unavailable() {
    }

    _setValue_unavailable() {
    }

    _getValue_direct(t, e) {
      t[e] = this.node[this.propertyName]
    }

    _getValue_array(t, e) {
      const n = this.resolvedProperty;
      for (let r = 0, i = n.length; r !== i; ++r) t[e++] = n[r]
    }

    _getValue_arrayElement(t, e) {
      t[e] = this.resolvedProperty[this.propertyIndex]
    }

    _getValue_toArray(t, e) {
      this.resolvedProperty.toArray(t, e)
    }

    _setValue_direct(t, e) {
      this.targetObject[this.propertyName] = t[e]
    }

    _setValue_direct_setNeedsUpdate(t, e) {
      this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
    }

    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
      this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
    }

    _setValue_array(t, e) {
      const n = this.resolvedProperty;
      for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++]
    }

    _setValue_array_setNeedsUpdate(t, e) {
      const n = this.resolvedProperty;
      for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
      this.targetObject.needsUpdate = !0
    }

    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
      const n = this.resolvedProperty;
      for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
      this.targetObject.matrixWorldNeedsUpdate = !0
    }

    _setValue_arrayElement(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e]
    }

    _setValue_arrayElement_setNeedsUpdate(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
    }

    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
    }

    _setValue_fromArray(t, e) {
      this.resolvedProperty.fromArray(t, e)
    }

    _setValue_fromArray_setNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
    }

    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
    }

    _getValue_unbound(t, e) {
      this.bind(), this.getValue(t, e)
    }

    _setValue_unbound(t, e) {
      this.bind(), this.setValue(t, e)
    }

    bind() {
      let t = this.node;
      const e = this.parsedPath, n = e.objectName, r = e.propertyName;
      let i = e.propertyIndex;
      if (t || (t = Hc.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      if (n) {
        let r = e.objectIndex;
        switch (n) {
          case"materials":
            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            t = t.material.materials;
            break;
          case"bones":
            if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            t = t.skeleton.bones;
            for (let e = 0; e < t.length; e++) if (t[e].name === r) {
              r = e;
              break
            }
            break;
          default:
            if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            t = t[n]
        }
        if (void 0 !== r) {
          if (void 0 === t[r]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
          t = t[r]
        }
      }
      const o = t[r];
      if (void 0 === o) {
        const n = e.nodeName;
        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", t)
      }
      let s = this.Versioning.None;
      this.targetObject = t, void 0 !== t.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
      let a = this.BindingType.Direct;
      if (void 0 !== i) {
        if ("morphTargetInfluences" === r) {
          if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          void 0 !== t.morphTargetDictionary[i] && (i = t.morphTargetDictionary[i])
        }
        a = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = i
      } else void 0 !== o.fromArray && void 0 !== o.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (a = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r;
      this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][s]
    }

    unbind() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
  }

  Hc.Composite = class {
    constructor(t, e, n) {
      const r = n || Hc.parseTrackName(e);
      this._targetGroup = t, this._bindings = t.subscribe_(e, r)
    }

    getValue(t, e) {
      this.bind();
      const n = this._targetGroup.nCachedObjects_, r = this._bindings[n];
      void 0 !== r && r.getValue(t, e)
    }

    setValue(t, e) {
      const n = this._bindings;
      for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(t, e)
    }

    bind() {
      const t = this._bindings;
      for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
    }

    unbind() {
      const t = this._bindings;
      for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
    }
  }, Hc.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  }, Hc.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  }, Hc.prototype.GetterByBindingType = [Hc.prototype._getValue_direct, Hc.prototype._getValue_array, Hc.prototype._getValue_arrayElement, Hc.prototype._getValue_toArray], Hc.prototype.SetterByBindingTypeAndVersioning = [[Hc.prototype._setValue_direct, Hc.prototype._setValue_direct_setNeedsUpdate, Hc.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Hc.prototype._setValue_array, Hc.prototype._setValue_array_setNeedsUpdate, Hc.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Hc.prototype._setValue_arrayElement, Hc.prototype._setValue_arrayElement_setNeedsUpdate, Hc.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Hc.prototype._setValue_fromArray, Hc.prototype._setValue_fromArray_setNeedsUpdate, Hc.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];

  class Ac {
    constructor(t, e, n = null, r = e.blendMode) {
      this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = r;
      const i = e.tracks, o = i.length, s = new Array(o), a = {endingStart: N, endingEnd: N};
      for (let c = 0; c !== o; ++c) {
        const t = i[c].createInterpolant(null);
        s[c] = t, t.settings = a
      }
      this._interpolantSettings = a, this._interpolants = s, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
    }

    play() {
      return this._mixer._activateAction(this), this
    }

    stop() {
      return this._mixer._deactivateAction(this), this.reset()
    }

    reset() {
      return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
    }

    isRunning() {
      return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
    }

    isScheduled() {
      return this._mixer._isActiveAction(this)
    }

    startAt(t) {
      return this._startTime = t, this
    }

    setLoop(t, e) {
      return this.loop = t, this.repetitions = e, this
    }

    setEffectiveWeight(t) {
      return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
    }

    getEffectiveWeight() {
      return this._effectiveWeight
    }

    fadeIn(t) {
      return this._scheduleFading(t, 0, 1)
    }

    fadeOut(t) {
      return this._scheduleFading(t, 1, 0)
    }

    crossFadeFrom(t, e, n) {
      if (t.fadeOut(e), this.fadeIn(e), n) {
        const n = this._clip.duration, r = t._clip.duration, i = r / n, o = n / r;
        t.warp(1, i, e), this.warp(o, 1, e)
      }
      return this
    }

    crossFadeTo(t, e, n) {
      return t.crossFadeFrom(this, e, n)
    }

    stopFading() {
      const t = this._weightInterpolant;
      return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
    }

    setEffectiveTimeScale(t) {
      return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
    }

    getEffectiveTimeScale() {
      return this._effectiveTimeScale
    }

    setDuration(t) {
      return this.timeScale = this._clip.duration / t, this.stopWarping()
    }

    syncWith(t) {
      return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
    }

    halt(t) {
      return this.warp(this._effectiveTimeScale, 0, t)
    }

    warp(t, e, n) {
      const r = this._mixer, i = r.time, o = this.timeScale;
      let s = this._timeScaleInterpolant;
      null === s && (s = r._lendControlInterpolant(), this._timeScaleInterpolant = s);
      const a = s.parameterPositions, c = s.sampleValues;
      return a[0] = i, a[1] = i + n, c[0] = t / o, c[1] = e / o, this
    }

    stopWarping() {
      const t = this._timeScaleInterpolant;
      return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
    }

    getMixer() {
      return this._mixer
    }

    getClip() {
      return this._clip
    }

    getRoot() {
      return this._localRoot || this._mixer._root
    }

    _update(t, e, n, r) {
      if (!this.enabled) return void this._updateWeight(t);
      const i = this._startTime;
      if (null !== i) {
        const r = (t - i) * n;
        if (r < 0 || 0 === n) return;
        this._startTime = null, e = n * r
      }
      e *= this._updateTimeScale(t);
      const o = this._updateTime(e), s = this._updateWeight(t);
      if (s > 0) {
        const t = this._interpolants, e = this._propertyBindings;
        if (2501 === this.blendMode) for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(o), e[n].accumulateAdditive(s); else for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(o), e[n].accumulate(r, s)
      }
    }

    _updateWeight(t) {
      let e = 0;
      if (this.enabled) {
        e = this.weight;
        const n = this._weightInterpolant;
        if (null !== n) {
          const r = n.evaluate(t)[0];
          e *= r, t > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
        }
      }
      return this._effectiveWeight = e, e
    }

    _updateTimeScale(t) {
      let e = 0;
      if (!this.paused) {
        e = this.timeScale;
        const n = this._timeScaleInterpolant;
        if (null !== n) {
          e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
        }
      }
      return this._effectiveTimeScale = e, e
    }

    _updateTime(t) {
      const e = this._clip.duration, n = this.loop;
      let r = this.time + t, i = this._loopCount;
      const o = 2202 === n;
      if (0 === t) return -1 === i ? r : o && 1 == (1 & i) ? e - r : r;
      if (2200 === n) {
        -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
        t:{
          if (r >= e) r = e; else {
            if (!(r < 0)) {
              this.time = r;
              break t
            }
            r = 0
          }
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: t < 0 ? -1 : 1
          })
        }
      } else {
        if (-1 === i && (t >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), r >= e || r < 0) {
          const n = Math.floor(r / e);
          r -= e * n, i += Math.abs(n);
          const s = this.repetitions - i;
          if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = t > 0 ? e : 0, this.time = r, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: t > 0 ? 1 : -1
          }); else {
            if (1 === s) {
              const e = t < 0;
              this._setEndings(e, !e, o)
            } else this._setEndings(!1, !1, o);
            this._loopCount = i, this.time = r, this._mixer.dispatchEvent({type: "loop", action: this, loopDelta: n})
          }
        } else this.time = r;
        if (o && 1 == (1 & i)) return e - r
      }
      return r
    }

    _setEndings(t, e, n) {
      const r = this._interpolantSettings;
      n ? (r.endingStart = z, r.endingEnd = z) : (r.endingStart = t ? this.zeroSlopeAtStart ? z : N : j, r.endingEnd = e ? this.zeroSlopeAtEnd ? z : N : j)
    }

    _scheduleFading(t, e, n) {
      const r = this._mixer, i = r.time;
      let o = this._weightInterpolant;
      null === o && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
      const s = o.parameterPositions, a = o.sampleValues;
      return s[0] = i, a[0] = e, s[1] = i + t, a[1] = n, this
    }
  }

  (class extends Y {
    constructor(t) {
      super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
    }

    _bindAction(t, e) {
      const n = t._localRoot || this._root, r = t._clip.tracks, i = r.length, o = t._propertyBindings,
        s = t._interpolants, a = n.uuid, c = this._bindingsByRootAndName;
      let l = c[a];
      void 0 === l && (l = {}, c[a] = l);
      for (let u = 0; u !== i; ++u) {
        const t = r[u], i = t.name;
        let c = l[i];
        if (void 0 !== c) o[u] = c; else {
          if (c = o[u], void 0 !== c) {
            null === c._cacheIndex && (++c.referenceCount, this._addInactiveBinding(c, a, i));
            continue
          }
          const r = e && e._propertyBindings[u].binding.parsedPath;
          c = new gc(Hc.create(n, i, r), t.ValueTypeName, t.getValueSize()), ++c.referenceCount, this._addInactiveBinding(c, a, i), o[u] = c
        }
        s[u].resultBuffer = c.buffer
      }
    }

    _activateAction(t) {
      if (!this._isActiveAction(t)) {
        if (null === t._cacheIndex) {
          const e = (t._localRoot || this._root).uuid, n = t._clip.uuid, r = this._actionsByClip[n];
          this._bindAction(t, r && r.knownActions[0]), this._addInactiveAction(t, n, e)
        }
        const e = t._propertyBindings;
        for (let t = 0, n = e.length; t !== n; ++t) {
          const n = e[t];
          0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
        }
        this._lendAction(t)
      }
    }

    _deactivateAction(t) {
      if (this._isActiveAction(t)) {
        const e = t._propertyBindings;
        for (let t = 0, n = e.length; t !== n; ++t) {
          const n = e[t];
          0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
        }
        this._takeBackAction(t)
      }
    }

    _initMemoryManager() {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
      const t = this;
      this.stats = {
        actions: {
          get total() {
            return t._actions.length
          }, get inUse() {
            return t._nActiveActions
          }
        }, bindings: {
          get total() {
            return t._bindings.length
          }, get inUse() {
            return t._nActiveBindings
          }
        }, controlInterpolants: {
          get total() {
            return t._controlInterpolants.length
          }, get inUse() {
            return t._nActiveControlInterpolants
          }
        }
      }
    }

    _isActiveAction(t) {
      const e = t._cacheIndex;
      return null !== e && e < this._nActiveActions
    }

    _addInactiveAction(t, e, n) {
      const r = this._actions, i = this._actionsByClip;
      let o = i[e];
      if (void 0 === o) o = {knownActions: [t], actionByRoot: {}}, t._byClipCacheIndex = 0, i[e] = o; else {
        const e = o.knownActions;
        t._byClipCacheIndex = e.length, e.push(t)
      }
      t._cacheIndex = r.length, r.push(t), o.actionByRoot[n] = t
    }

    _removeInactiveAction(t) {
      const e = this._actions, n = e[e.length - 1], r = t._cacheIndex;
      n._cacheIndex = r, e[r] = n, e.pop(), t._cacheIndex = null;
      const i = t._clip.uuid, o = this._actionsByClip, s = o[i], a = s.knownActions, c = a[a.length - 1],
        l = t._byClipCacheIndex;
      c._byClipCacheIndex = l, a[l] = c, a.pop(), t._byClipCacheIndex = null;
      delete s.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete o[i], this._removeInactiveBindingsForAction(t)
    }

    _removeInactiveBindingsForAction(t) {
      const e = t._propertyBindings;
      for (let n = 0, r = e.length; n !== r; ++n) {
        const t = e[n];
        0 == --t.referenceCount && this._removeInactiveBinding(t)
      }
    }

    _lendAction(t) {
      const e = this._actions, n = t._cacheIndex, r = this._nActiveActions++, i = e[r];
      t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
    }

    _takeBackAction(t) {
      const e = this._actions, n = t._cacheIndex, r = --this._nActiveActions, i = e[r];
      t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
    }

    _addInactiveBinding(t, e, n) {
      const r = this._bindingsByRootAndName, i = this._bindings;
      let o = r[e];
      void 0 === o && (o = {}, r[e] = o), o[n] = t, t._cacheIndex = i.length, i.push(t)
    }

    _removeInactiveBinding(t) {
      const e = this._bindings, n = t.binding, r = n.rootNode.uuid, i = n.path, o = this._bindingsByRootAndName,
        s = o[r], a = e[e.length - 1], c = t._cacheIndex;
      a._cacheIndex = c, e[c] = a, e.pop(), delete s[i], 0 === Object.keys(s).length && delete o[r]
    }

    _lendBinding(t) {
      const e = this._bindings, n = t._cacheIndex, r = this._nActiveBindings++, i = e[r];
      t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
    }

    _takeBackBinding(t) {
      const e = this._bindings, n = t._cacheIndex, r = --this._nActiveBindings, i = e[r];
      t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
    }

    _lendControlInterpolant() {
      const t = this._controlInterpolants, e = this._nActiveControlInterpolants++;
      let n = t[e];
      return void 0 === n && (n = new Zs(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
    }

    _takeBackControlInterpolant(t) {
      const e = this._controlInterpolants, n = t.__cacheIndex, r = --this._nActiveControlInterpolants, i = e[r];
      t.__cacheIndex = r, e[r] = t, i.__cacheIndex = n, e[n] = i
    }

    clipAction(t, e, n) {
      const r = e || this._root, i = r.uuid;
      let o = "string" == typeof t ? oa.findByName(r, t) : t;
      const s = null !== o ? o.uuid : t, a = this._actionsByClip[s];
      let c = null;
      if (void 0 === n && (n = null !== o ? o.blendMode : I), void 0 !== a) {
        const t = a.actionByRoot[i];
        if (void 0 !== t && t.blendMode === n) return t;
        c = a.knownActions[0], null === o && (o = c._clip)
      }
      if (null === o) return null;
      const l = new Ac(this, o, e, n);
      return this._bindAction(l, c), this._addInactiveAction(l, s, i), l
    }

    existingAction(t, e) {
      const n = e || this._root, r = n.uuid, i = "string" == typeof t ? oa.findByName(n, t) : t, o = i ? i.uuid : t,
        s = this._actionsByClip[o];
      return void 0 !== s && s.actionByRoot[r] || null
    }

    stopAllAction() {
      const t = this._actions;
      for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
      return this
    }

    update(t) {
      t *= this.timeScale;
      const e = this._actions, n = this._nActiveActions, r = this.time += t, i = Math.sign(t), o = this._accuIndex ^= 1;
      for (let c = 0; c !== n; ++c) {
        e[c]._update(r, t, i, o)
      }
      const s = this._bindings, a = this._nActiveBindings;
      for (let c = 0; c !== a; ++c) s[c].apply(o);
      return this
    }

    setTime(t) {
      this.time = 0;
      for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
      return this.update(t)
    }

    getRoot() {
      return this._root
    }

    uncacheClip(t) {
      const e = this._actions, n = t.uuid, r = this._actionsByClip, i = r[n];
      if (void 0 !== i) {
        const t = i.knownActions;
        for (let n = 0, r = t.length; n !== r; ++n) {
          const r = t[n];
          this._deactivateAction(r);
          const i = r._cacheIndex, o = e[e.length - 1];
          r._cacheIndex = null, r._byClipCacheIndex = null, o._cacheIndex = i, e[i] = o, e.pop(), this._removeInactiveBindingsForAction(r)
        }
        delete r[n]
      }
    }

    uncacheRoot(t) {
      const e = t.uuid, n = this._actionsByClip;
      for (const i in n) {
        const t = n[i].actionByRoot[e];
        void 0 !== t && (this._deactivateAction(t), this._removeInactiveAction(t))
      }
      const r = this._bindingsByRootAndName[e];
      if (void 0 !== r) for (const i in r) {
        const t = r[i];
        t.restoreOriginalState(), this._removeInactiveBinding(t)
      }
    }

    uncacheAction(t, e) {
      const n = this.existingAction(t, e);
      null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
    }
  }).prototype._controlInterpolantsResultBuffer = new Float32Array(1);

  class Pc {
    constructor(t) {
      "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
    }

    clone() {
      return new Pc(void 0 === this.value.clone ? this.value : this.value.clone())
    }
  }

  (class extends oo {
    constructor(t, e, n = 1) {
      super(t, e), this.meshPerAttribute = n || 1
    }

    copy(t) {
      return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
    }

    clone(t) {
      const e = super.clone(t);
      return e.meshPerAttribute = this.meshPerAttribute, e
    }

    toJSON(t) {
      const e = super.toJSON(t);
      return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
    }
  }).prototype.isInstancedInterleavedBuffer = !0;

  class Rc {
    constructor(t = 1, e = 0, n = 0) {
      return this.radius = t, this.phi = e, this.theta = n, this
    }

    set(t, e, n) {
      return this.radius = t, this.phi = e, this.theta = n, this
    }

    copy(t) {
      return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
    }

    makeSafe() {
      const t = 1e-6;
      return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this
    }

    setFromVector3(t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z)
    }

    setFromCartesianCoords(t, e, n) {
      return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(tt(e / this.radius, -1, 1))), this
    }

    clone() {
      return (new this.constructor).copy(this)
    }
  }

  const Lc = new at;

  class Cc {
    constructor(t = new at(1 / 0, 1 / 0), e = new at(-1 / 0, -1 / 0)) {
      this.min = t, this.max = e
    }

    set(t, e) {
      return this.min.copy(t), this.max.copy(e), this
    }

    setFromPoints(t) {
      this.makeEmpty();
      for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
      return this
    }

    setFromCenterAndSize(t, e) {
      const n = Lc.copy(e).multiplyScalar(.5);
      return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
    }

    clone() {
      return (new this.constructor).copy(this)
    }

    copy(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this
    }

    makeEmpty() {
      return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
    }

    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y
    }

    getCenter(t) {
      return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new at), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
    }

    getSize(t) {
      return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new at), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
    }

    expandByPoint(t) {
      return this.min.min(t), this.max.max(t), this
    }

    expandByVector(t) {
      return this.min.sub(t), this.max.add(t), this
    }

    expandByScalar(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this
    }

    containsPoint(t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
    }

    containsBox(t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
    }

    getParameter(t, e) {
      return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new at), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
    }

    intersectsBox(t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
    }

    clampPoint(t, e) {
      return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new at), e.copy(t).clamp(this.min, this.max)
    }

    distanceToPoint(t) {
      return Lc.copy(t).clamp(this.min, this.max).sub(t).length()
    }

    intersect(t) {
      return this.min.max(t.min), this.max.min(t.max), this
    }

    union(t) {
      return this.min.min(t.min), this.max.max(t.max), this
    }

    translate(t) {
      return this.min.add(t), this.max.add(t), this
    }

    equals(t) {
      return t.min.equals(this.min) && t.max.equals(this.max)
    }
  }

  Cc.prototype.isBox2 = !0;
  (class extends _e {
    constructor(t) {
      super(), this.material = t, this.render = function () {
      }, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
    }
  }).prototype.isImmediateRenderObject = !0;
  const kc = new gt;

  class Dc extends _e {
    constructor(t, e) {
      super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
      const n = new sn,
        r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
      for (let o = 0, s = 1, a = 32; o < a; o++, s++) {
        const t = o / a * Math.PI * 2, e = s / a * Math.PI * 2;
        r.push(Math.cos(t), Math.sin(t), 1, Math.cos(e), Math.sin(e), 1)
      }
      n.setAttribute("position", new Je(r, 3));
      const i = new zo({fog: !1, toneMapped: !1});
      this.cone = new Xo(n, i), this.add(this.cone), this.update()
    }

    dispose() {
      this.cone.geometry.dispose(), this.cone.material.dispose()
    }

    update() {
      this.light.updateMatrixWorld();
      const t = this.light.distance ? this.light.distance : 1e3, e = t * Math.tan(this.light.angle);
      this.cone.scale.set(e, e, t), kc.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(kc), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
  }

  const Nc = new gt, zc = new Yt, jc = new Yt;

  function Ic(t) {
    const e = [];
    t && t.isBone && e.push(t);
    for (let n = 0; n < t.children.length; n++) e.push.apply(e, Ic(t.children[n]));
    return e
  }

  const Bc = new Float32Array(1), Fc = new Int32Array(Bc.buffer);

  class Uc {
    static toHalfFloat(t) {
      Bc[0] = t;
      const e = Fc[0];
      let n = e >> 16 & 32768, r = e >> 12 & 2047;
      const i = e >> 23 & 255;
      return i < 103 ? n : i > 142 ? (n |= 31744, n |= (255 == i ? 0 : 1) && 8388607 & e, n) : i < 113 ? (r |= 2048, n |= (r >> 114 - i) + (r >> 113 - i & 1), n) : (n |= i - 112 << 10 | r >> 1, n += 1 & r, n)
    }
  }

  const Gc = Math.pow(2, 8), Vc = [.125, .215, .35, .446, .526, .582], Wc = 5 + Vc.length, Xc = 20,
    qc = {[B]: 0, [F]: 1, [G]: 2, 3004: 3, 3005: 4, 3006: 5, [U]: 6},
    Yc = new Ve({side: o, depthWrite: !1, depthTest: !1}), Zc = new Mn(new Tn, Yc),
    Jc = new Qa, {_lodPlanes: Kc, _sizeLods: Qc, _sigmas: $c} = cl(), tl = new Ge;
  let el = null;
  const nl = (1 + Math.sqrt(5)) / 2, rl = 1 / nl,
    il = [new gt(1, 1, 1), new gt(-1, 1, 1), new gt(1, 1, -1), new gt(-1, 1, -1), new gt(0, nl, rl), new gt(0, nl, -rl), new gt(rl, 0, nl), new gt(-rl, 0, nl), new gt(nl, rl, 0), new gt(-nl, rl, 0)];

  function ol(t) {
    const e = Math.max(t.r, t.g, t.b), n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
    t.multiplyScalar(Math.pow(2, -n));
    return (n + 128) / 255
  }

  class sl {
    constructor(t) {
      this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = function (t) {
        const e = new Float32Array(t), n = new gt(0, 1, 0);
        return new zs({
          name: "SphericalGaussianBlur",
          defines: {n: t},
          uniforms: {
            envMap: {value: null},
            samples: {value: 1},
            weights: {value: e},
            latitudinal: {value: !1},
            dTheta: {value: 0},
            mipInt: {value: 0},
            poleAxis: {value: n},
            inputEncoding: {value: qc[B]},
            outputEncoding: {value: qc[B]}
          },
          vertexShader: dl(),
          fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${pl()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
          blending: 0,
          depthTest: !1,
          depthWrite: !1
        })
      }(Xc), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
    }

    fromScene(t, e = 0, n = .1, r = 100) {
      el = this._renderer.getRenderTarget();
      const i = this._allocateTargets();
      return this._sceneToCubeUV(t, n, r, i), e > 0 && this._blur(i, 0, 0, e), this._applyPMREM(i), this._cleanup(i), i
    }

    fromEquirectangular(t) {
      return this._fromTexture(t)
    }

    fromCubemap(t) {
      return this._fromTexture(t)
    }

    compileCubemapShader() {
      null === this._cubemapShader && (this._cubemapShader = fl(), this._compileMaterial(this._cubemapShader))
    }

    compileEquirectangularShader() {
      null === this._equirectShader && (this._equirectShader = hl(), this._compileMaterial(this._equirectShader))
    }

    dispose() {
      this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
      for (let t = 0; t < Kc.length; t++) Kc[t].dispose()
    }

    _cleanup(t) {
      this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(el), t.scissorTest = !1, ul(t, 0, 0, t.width, t.height)
    }

    _fromTexture(t) {
      el = this._renderer.getRenderTarget();
      const e = this._allocateTargets(t);
      return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
    }

    _allocateTargets(t) {
      const e = {
        magFilter: g,
        minFilter: g,
        generateMipmaps: !1,
        type: w,
        format: P,
        encoding: al(t) ? t.encoding : G,
        depthBuffer: !1
      }, n = ll(e);
      return n.depthBuffer = !t, this._pingPongRenderTarget = ll(e), n
    }

    _compileMaterial(t) {
      const e = new Mn(Kc[0], t);
      this._renderer.compile(e, Jc)
    }

    _sceneToCubeUV(t, e, n, r) {
      const i = new Ln(90, 1, e, n), o = [1, -1, 1, 1, 1, 1], s = [1, 1, 1, -1, -1, -1], a = this._renderer,
        c = a.autoClear, l = a.outputEncoding, u = a.toneMapping;
      a.getClearColor(tl), a.toneMapping = 0, a.outputEncoding = B, a.autoClear = !1;
      let h = !1;
      const f = t.background;
      if (f) {
        if (f.isColor) {
          Yc.color.copy(f).convertSRGBToLinear(), t.background = null;
          const e = ol(Yc.color);
          Yc.opacity = e, h = !0
        }
      } else {
        Yc.color.copy(tl).convertSRGBToLinear();
        const t = ol(Yc.color);
        Yc.opacity = t, h = !0
      }
      for (let d = 0; d < 6; d++) {
        const e = d % 3;
        0 == e ? (i.up.set(0, o[d], 0), i.lookAt(s[d], 0, 0)) : 1 == e ? (i.up.set(0, 0, o[d]), i.lookAt(0, s[d], 0)) : (i.up.set(0, o[d], 0), i.lookAt(0, 0, s[d])), ul(r, e * Gc, d > 2 ? Gc : 0, Gc, Gc), a.setRenderTarget(r), h && a.render(Zc, i), a.render(t, i)
      }
      a.toneMapping = u, a.outputEncoding = l, a.autoClear = c
    }

    _textureToCubeUV(t, e) {
      const n = this._renderer;
      t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = fl()) : null == this._equirectShader && (this._equirectShader = hl());
      const r = t.isCubeTexture ? this._cubemapShader : this._equirectShader, i = new Mn(Kc[0], r), o = r.uniforms;
      o.envMap.value = t, t.isCubeTexture || o.texelSize.value.set(1 / t.image.width, 1 / t.image.height), o.inputEncoding.value = qc[t.encoding], o.outputEncoding.value = qc[e.texture.encoding], ul(e, 0, 0, 3 * Gc, 2 * Gc), n.setRenderTarget(e), n.render(i, Jc)
    }

    _applyPMREM(t) {
      const e = this._renderer, n = e.autoClear;
      e.autoClear = !1;
      for (let r = 1; r < Wc; r++) {
        const e = Math.sqrt($c[r] * $c[r] - $c[r - 1] * $c[r - 1]), n = il[(r - 1) % il.length];
        this._blur(t, r - 1, r, e, n)
      }
      e.autoClear = n
    }

    _blur(t, e, n, r, i) {
      const o = this._pingPongRenderTarget;
      this._halfBlur(t, o, e, n, r, "latitudinal", i), this._halfBlur(o, t, n, n, r, "longitudinal", i)
    }

    _halfBlur(t, e, n, r, i, o, s) {
      const a = this._renderer, c = this._blurMaterial;
      "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!");
      const l = new Mn(Kc[r], c), u = c.uniforms, h = Qc[n] - 1, f = isFinite(i) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
        d = i / f, p = isFinite(i) ? 1 + Math.floor(3 * d) : Xc;
      p > Xc && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${p} samples when the maximum is set to 20`);
      const m = [];
      let v = 0;
      for (let y = 0; y < Xc; ++y) {
        const t = y / d, e = Math.exp(-t * t / 2);
        m.push(e), 0 == y ? v += e : y < p && (v += 2 * e)
      }
      for (let y = 0; y < m.length; y++) m[y] = m[y] / v;
      u.envMap.value = t.texture, u.samples.value = p, u.weights.value = m, u.latitudinal.value = "latitudinal" === o, s && (u.poleAxis.value = s), u.dTheta.value = f, u.mipInt.value = 8 - n, u.inputEncoding.value = qc[t.texture.encoding], u.outputEncoding.value = qc[t.texture.encoding];
      const g = Qc[r];
      ul(e, 3 * Math.max(0, Gc - 2 * g), (0 === r ? 0 : 2 * Gc) + 2 * g * (r > 4 ? r - 8 + 4 : 0), 3 * g, 2 * g), a.setRenderTarget(e), a.render(l, Jc)
    }
  }

  function al(t) {
    return void 0 !== t && t.type === w && (t.encoding === B || t.encoding === F || t.encoding === U)
  }

  function cl() {
    const t = [], e = [], n = [];
    let r = 8;
    for (let i = 0; i < Wc; i++) {
      const o = Math.pow(2, r);
      e.push(o);
      let s = 1 / o;
      i > 4 ? s = Vc[i - 8 + 4 - 1] : 0 == i && (s = 0), n.push(s);
      const a = 1 / (o - 1), c = -a / 2, l = 1 + a / 2, u = [c, c, l, c, l, l, c, c, l, l, c, l], h = 6, f = 6, d = 3,
        p = 2, m = 1, v = new Float32Array(d * f * h), g = new Float32Array(p * f * h), y = new Float32Array(m * f * h);
      for (let t = 0; t < h; t++) {
        const e = t % 3 * 2 / 3 - 1, n = t > 2 ? 0 : -1,
          r = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
        v.set(r, d * f * t), g.set(u, p * f * t);
        const i = [t, t, t, t, t, t];
        y.set(i, m * f * t)
      }
      const _ = new sn;
      _.setAttribute("position", new qe(v, d)), _.setAttribute("uv", new qe(g, p)), _.setAttribute("faceIndex", new qe(y, m)), t.push(_), r > 4 && r--
    }
    return {_lodPlanes: t, _sizeLods: e, _sigmas: n}
  }

  function ll(t) {
    const e = new mt(3 * Gc, 3 * Gc, t);
    return e.texture.mapping = f, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
  }

  function ul(t, e, n, r, i) {
    t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i)
  }

  function hl() {
    const t = new at(1, 1);
    return new zs({
      name: "EquirectangularToCubeUV",
      uniforms: {
        envMap: {value: null},
        texelSize: {value: t},
        inputEncoding: {value: qc[B]},
        outputEncoding: {value: qc[B]}
      },
      vertexShader: dl(),
      fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${pl()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
      blending: 0,
      depthTest: !1,
      depthWrite: !1
    })
  }

  function fl() {
    return new zs({
      name: "CubemapToCubeUV",
      uniforms: {envMap: {value: null}, inputEncoding: {value: qc[B]}, outputEncoding: {value: qc[B]}},
      vertexShader: dl(),
      fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${pl()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
      blending: 0,
      depthTest: !1,
      depthWrite: !1
    })
  }

  function dl() {
    return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
  }

  function pl() {
    return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"
  }

  ga.create = function (t, e) {
    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(ga.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
  }, za.prototype.fromPoints = function (t) {
    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
  }, class extends Xo {
    constructor(t = 10, e = 10, n = 4473924, r = 8947848) {
      n = new Ge(n), r = new Ge(r);
      const i = e / 2, o = t / e, s = t / 2, a = [], c = [];
      for (let u = 0, h = 0, f = -s; u <= e; u++, f += o) {
        a.push(-s, 0, f, s, 0, f), a.push(f, 0, -s, f, 0, s);
        const t = u === i ? n : r;
        t.toArray(c, h), h += 3, t.toArray(c, h), h += 3, t.toArray(c, h), h += 3, t.toArray(c, h), h += 3
      }
      const l = new sn;
      l.setAttribute("position", new Je(a, 3)), l.setAttribute("color", new Je(c, 3));
      super(l, new zo({vertexColors: !0, toneMapped: !1})), this.type = "GridHelper"
    }
  }.prototype.setColors = function () {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
  }, class extends Xo {
    constructor(t) {
      const e = Ic(t), n = new sn, r = [], i = [], o = new Ge(0, 0, 1), s = new Ge(0, 1, 0);
      for (let a = 0; a < e.length; a++) {
        const t = e[a];
        t.parent && t.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(o.r, o.g, o.b), i.push(s.r, s.g, s.b))
      }
      n.setAttribute("position", new Je(r, 3)), n.setAttribute("color", new Je(i, 3));
      super(n, new zo({
        vertexColors: !0,
        depthTest: !1,
        depthWrite: !1,
        toneMapped: !1,
        transparent: !0
      })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
    }

    updateMatrixWorld(t) {
      const e = this.bones, n = this.geometry, r = n.getAttribute("position");
      jc.copy(this.root.matrixWorld).invert();
      for (let i = 0, o = 0; i < e.length; i++) {
        const t = e[i];
        t.parent && t.parent.isBone && (zc.multiplyMatrices(jc, t.matrixWorld), Nc.setFromMatrixPosition(zc), r.setXYZ(o, Nc.x, Nc.y, Nc.z), zc.multiplyMatrices(jc, t.parent.matrixWorld), Nc.setFromMatrixPosition(zc), r.setXYZ(o + 1, Nc.x, Nc.y, Nc.z), o += 2)
      }
      n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
    }
  }.prototype.update = function () {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
  }, ua.prototype.extractUrlBase = function (t) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), oc.extractUrlBase(t)
  }, ua.Handlers = {
    add: function () {
      console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
    }, get: function () {
      console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
    }
  }, Cc.prototype.center = function (t) {
    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
  }, Cc.prototype.empty = function () {
    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
  }, Cc.prototype.isIntersectionBox = function (t) {
    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
  }, Cc.prototype.size = function (t) {
    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
  }, bt.prototype.center = function (t) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
  }, bt.prototype.empty = function () {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
  }, bt.prototype.isIntersectionBox = function (t) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
  }, bt.prototype.isIntersectionSphere = function (t) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
  }, bt.prototype.size = function (t) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
  }, It.prototype.empty = function () {
    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
  }, Bn.prototype.setFromMatrix = function (t) {
    return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
  }, ct.prototype.flattenToArrayOffset = function (t, e) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
  }, ct.prototype.multiplyVector3 = function (t) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
  }, ct.prototype.multiplyVector3Array = function () {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
  }, ct.prototype.applyToBufferAttribute = function (t) {
    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
  }, ct.prototype.applyToVector3Array = function () {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
  }, ct.prototype.getInverse = function (t) {
    return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
  }, Yt.prototype.extractPosition = function (t) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
  }, Yt.prototype.flattenToArrayOffset = function (t, e) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
  }, Yt.prototype.getPosition = function () {
    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new gt).setFromMatrixColumn(this, 3)
  }, Yt.prototype.setRotationFromQuaternion = function (t) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
  }, Yt.prototype.multiplyToArray = function () {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
  }, Yt.prototype.multiplyVector3 = function (t) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
  }, Yt.prototype.multiplyVector4 = function (t) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
  }, Yt.prototype.multiplyVector3Array = function () {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
  }, Yt.prototype.rotateAxis = function (t) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
  }, Yt.prototype.crossVector = function (t) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
  }, Yt.prototype.translate = function () {
    console.error("THREE.Matrix4: .translate() has been removed.")
  }, Yt.prototype.rotateX = function () {
    console.error("THREE.Matrix4: .rotateX() has been removed.")
  }, Yt.prototype.rotateY = function () {
    console.error("THREE.Matrix4: .rotateY() has been removed.")
  }, Yt.prototype.rotateZ = function () {
    console.error("THREE.Matrix4: .rotateZ() has been removed.")
  }, Yt.prototype.rotateByAxis = function () {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
  }, Yt.prototype.applyToBufferAttribute = function (t) {
    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
  }, Yt.prototype.applyToVector3Array = function () {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
  }, Yt.prototype.makeFrustum = function (t, e, n, r, i, o) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, r, n, i, o)
  }, Yt.prototype.getInverse = function (t) {
    return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
  }, Se.prototype.isIntersectionLine = function (t) {
    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
  }, vt.prototype.multiplyVector3 = function (t) {
    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
  }, vt.prototype.inverse = function () {
    return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
  }, qt.prototype.isIntersectionBox = function (t) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
  }, qt.prototype.isIntersectionPlane = function (t) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
  }, qt.prototype.isIntersectionSphere = function (t) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
  }, ke.prototype.area = function () {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
  }, ke.prototype.barycoordFromPoint = function (t, e) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
  }, ke.prototype.midpoint = function (t) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
  }, ke.prototypenormal = function (t) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
  }, ke.prototype.plane = function (t) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
  }, ke.barycoordFromPoint = function (t, e, n, r, i) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), ke.getBarycoord(t, e, n, r, i)
  }, ke.normal = function (t, e, n, r) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), ke.getNormal(t, e, n, r)
  }, ja.prototype.extractAllPoints = function (t) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
  }, ja.prototype.extrude = function (t) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Ls(this, t)
  }, ja.prototype.makeGeometry = function (t) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new ks(this, t)
  }, at.prototype.fromAttribute = function (t, e, n) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
  }, at.prototype.distanceToManhattan = function (t) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
  }, at.prototype.lengthManhattan = function () {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
  }, gt.prototype.setEulerFromRotationMatrix = function () {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
  }, gt.prototype.setEulerFromQuaternion = function () {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
  }, gt.prototype.getPositionFromMatrix = function (t) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
  }, gt.prototype.getScaleFromMatrix = function (t) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
  }, gt.prototype.getColumnFromMatrix = function (t, e) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
  }, gt.prototype.applyProjection = function (t) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
  }, gt.prototype.fromAttribute = function (t, e, n) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
  }, gt.prototype.distanceToManhattan = function (t) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
  }, gt.prototype.lengthManhattan = function () {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
  }, pt.prototype.fromAttribute = function (t, e, n) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
  }, pt.prototype.lengthManhattan = function () {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
  }, _e.prototype.getChildByName = function (t) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
  }, _e.prototype.renderDepth = function () {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
  }, _e.prototype.translate = function (t, e) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
  }, _e.prototype.getWorldRotation = function () {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
  }, _e.prototype.applyMatrix = function (t) {
    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
  }, Object.defineProperties(_e.prototype, {
    eulerOrder: {
      get: function () {
        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
      }, set: function (t) {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
      }
    }, useQuaternion: {
      get: function () {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
      }, set: function () {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
      }
    }
  }), Mn.prototype.setDrawMode = function () {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
  }, Object.defineProperties(Mn.prototype, {
    drawMode: {
      get: function () {
        return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
      }, set: function () {
        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
      }
    }
  }), Po.prototype.initBones = function () {
    console.error("THREE.SkinnedMesh: initBones() has been removed.")
  }, Ln.prototype.setLens = function (t, e) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
  }, Object.defineProperties(Ia.prototype, {
    onlyShadow: {
      set: function () {
        console.warn("THREE.Light: .onlyShadow has been removed.")
      }
    }, shadowCameraFov: {
      set: function (t) {
        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
      }
    }, shadowCameraLeft: {
      set: function (t) {
        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
      }
    }, shadowCameraRight: {
      set: function (t) {
        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
      }
    }, shadowCameraTop: {
      set: function (t) {
        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
      }
    }, shadowCameraBottom: {
      set: function (t) {
        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
      }
    }, shadowCameraNear: {
      set: function (t) {
        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
      }
    }, shadowCameraFar: {
      set: function (t) {
        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
      }
    }, shadowCameraVisible: {
      set: function () {
        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
      }
    }, shadowBias: {
      set: function (t) {
        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
      }
    }, shadowDarkness: {
      set: function () {
        console.warn("THREE.Light: .shadowDarkness has been removed.")
      }
    }, shadowMapWidth: {
      set: function (t) {
        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
      }
    }, shadowMapHeight: {
      set: function (t) {
        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
      }
    }
  }), Object.defineProperties(qe.prototype, {
    length: {
      get: function () {
        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
      }
    }, dynamic: {
      get: function () {
        return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === X
      }, set: function () {
        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(X)
      }
    }
  }), qe.prototype.setDynamic = function (t) {
    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? X : W), this
  }, qe.prototype.copyIndicesArray = function () {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
  }, qe.prototype.setArray = function () {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
  }, sn.prototype.addIndex = function (t) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
  }, sn.prototype.addAttribute = function (t, e) {
    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new qe(arguments[1], arguments[2])))
  }, sn.prototype.addDrawCall = function (t, e, n) {
    void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
  }, sn.prototype.clearDrawCalls = function () {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
  }, sn.prototype.computeOffsets = function () {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
  }, sn.prototype.removeAttribute = function (t) {
    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
  }, sn.prototype.applyMatrix = function (t) {
    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
  }, Object.defineProperties(sn.prototype, {
    drawcalls: {
      get: function () {
        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
      }
    }, offsets: {
      get: function () {
        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
      }
    }
  }), oo.prototype.setDynamic = function (t) {
    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? X : W), this
  }, oo.prototype.setArray = function () {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
  }, Ls.prototype.getArrays = function () {
    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
  }, Ls.prototype.addShapeList = function () {
    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
  }, Ls.prototype.addShape = function () {
    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
  }, io.prototype.dispose = function () {
    console.error("THREE.Scene: .dispose() has been removed.")
  },Pc.prototype.onUpdate = function () {
    return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
  },Object.defineProperties(Ne.prototype, {
    wrapAround: {
      get: function () {
        console.warn("THREE.Material: .wrapAround has been removed.")
      }, set: function () {
        console.warn("THREE.Material: .wrapAround has been removed.")
      }
    }, overdraw: {
      get: function () {
        console.warn("THREE.Material: .overdraw has been removed.")
      }, set: function () {
        console.warn("THREE.Material: .overdraw has been removed.")
      }
    }, wrapRGB: {
      get: function () {
        return console.warn("THREE.Material: .wrapRGB has been removed."), new Ge
      }
    }, shading: {
      get: function () {
        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
      }, set: function (t) {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
      }
    }, stencilMask: {
      get: function () {
        return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
      }, set: function (t) {
        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t
      }
    }
  }),Object.defineProperties(Pn.prototype, {
    derivatives: {
      get: function () {
        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
      }, set: function (t) {
        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
      }
    }
  }),eo.prototype.clearTarget = function (t, e, n, r) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, r)
  },eo.prototype.animate = function (t) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
  },eo.prototype.getCurrentRenderTarget = function () {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
  },eo.prototype.getMaxAnisotropy = function () {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
  },eo.prototype.getPrecision = function () {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
  },eo.prototype.resetGLState = function () {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
  },eo.prototype.supportsFloatTextures = function () {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
  },eo.prototype.supportsHalfFloatTextures = function () {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
  },eo.prototype.supportsStandardDerivatives = function () {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
  },eo.prototype.supportsCompressedTextureS3TC = function () {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
  },eo.prototype.supportsCompressedTexturePVRTC = function () {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
  },eo.prototype.supportsBlendMinMax = function () {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
  },eo.prototype.supportsVertexTextures = function () {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
  },eo.prototype.supportsInstancedArrays = function () {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
  },eo.prototype.enableScissorTest = function (t) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
  },eo.prototype.initMaterial = function () {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
  },eo.prototype.addPrePlugin = function () {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
  },eo.prototype.addPostPlugin = function () {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
  },eo.prototype.updateShadowMap = function () {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
  },eo.prototype.setFaceCulling = function () {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
  },eo.prototype.allocTextureUnit = function () {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
  },eo.prototype.setTexture = function () {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
  },eo.prototype.setTexture2D = function () {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
  },eo.prototype.setTextureCube = function () {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
  },eo.prototype.getActiveMipMapLevel = function () {
    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
  },Object.defineProperties(eo.prototype, {
    shadowMapEnabled: {
      get: function () {
        return this.shadowMap.enabled
      }, set: function (t) {
        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
      }
    }, shadowMapType: {
      get: function () {
        return this.shadowMap.type
      }, set: function (t) {
        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
      }
    }, shadowMapCullFace: {
      get: function () {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
      }, set: function () {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
      }
    }, context: {
      get: function () {
        return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
      }
    }, vr: {
      get: function () {
        return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
      }
    }, gammaInput: {
      get: function () {
        return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
      }, set: function () {
        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
      }
    }, gammaOutput: {
      get: function () {
        return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
      }, set: function (t) {
        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? F : B
      }
    }, toneMappingWhitePoint: {
      get: function () {
        return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
      }, set: function () {
        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
      }
    }
  }),Object.defineProperties(Wi.prototype, {
    cullFace: {
      get: function () {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
      }, set: function () {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
      }
    }, renderReverseSided: {
      get: function () {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
      }, set: function () {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
      }
    }, renderSingleSided: {
      get: function () {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
      }, set: function () {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
      }
    }
  }),Object.defineProperties(mt.prototype, {
    wrapS: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
      }
    }, wrapT: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
      }
    }, magFilter: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
      }
    }, minFilter: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
      }
    }, anisotropy: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
      }
    }, offset: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
      }
    }, repeat: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
      }
    }, format: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
      }
    }, type: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
      }
    }, generateMipmaps: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
      }
    }
  }),vc.prototype.load = function (t) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    const e = this;
    return (new dc).load(t, (function (t) {
      e.setBuffer(t)
    })), this
  },kn.prototype.updateCubeMap = function (t, e) {
    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
  },kn.prototype.clear = function (t, e, n, r) {
    return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, r)
  },ut.crossOrigin = void 0,ut.loadTexture = function (t, e, n, r) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    const i = new va;
    i.setCrossOrigin(this.crossOrigin);
    const o = i.load(t, n, void 0, r);
    return e && (o.mapping = e), o
  },ut.loadTextureCube = function (t, e, n, r) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    const i = new pa;
    i.setCrossOrigin(this.crossOrigin);
    const o = i.load(t, n, void 0, r);
    return e && (o.mapping = e), o
  },ut.loadCompressedTexture = function () {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
  },ut.loadCompressedTextureCube = function () {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
  };
  "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {detail: {revision: "128"}})), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "128")
}, function (t, e, n) {
  "use strict";
  n.d(e, "b", (function () {
    return J
  })), n.d(e, "c", (function () {
    return Q
  })), n.d(e, "a", (function () {
    return it
  }));
  const r = "undefined" != typeof window && null != window.customElements && void 0 !== window.customElements.polyfillWrapFlushCallback,
    i = (t, e, n = null) => {
      for (; e !== n;) {
        const n = e.nextSibling;
        t.removeChild(e), e = n
      }
    }, o = `{{lit-${String(Math.random()).slice(2)}}}`, s = `\x3c!--${o}--\x3e`, a = new RegExp(`${o}|${s}`),
    c = "$lit$";

  class l {
    constructor(t, e) {
      this.parts = [], this.element = e;
      const n = [], r = [], i = document.createTreeWalker(e.content, 133, null, !1);
      let s = 0, l = -1, h = 0;
      const {strings: p, values: {length: m}} = t;
      for (; h < m;) {
        const t = i.nextNode();
        if (null !== t) {
          if (l++, 1 === t.nodeType) {
            if (t.hasAttributes()) {
              const e = t.attributes, {length: n} = e;
              let r = 0;
              for (let t = 0; t < n; t++) u(e[t].name, c) && r++;
              for (; r-- > 0;) {
                const e = p[h], n = d.exec(e)[2], r = n.toLowerCase() + c, i = t.getAttribute(r);
                t.removeAttribute(r);
                const o = i.split(a);
                this.parts.push({type: "attribute", index: l, name: n, strings: o}), h += o.length - 1
              }
            }
            "TEMPLATE" === t.tagName && (r.push(t), i.currentNode = t.content)
          } else if (3 === t.nodeType) {
            const e = t.data;
            if (e.indexOf(o) >= 0) {
              const r = t.parentNode, i = e.split(a), o = i.length - 1;
              for (let e = 0; e < o; e++) {
                let n, o = i[e];
                if ("" === o) n = f(); else {
                  const t = d.exec(o);
                  null !== t && u(t[2], c) && (o = o.slice(0, t.index) + t[1] + t[2].slice(0, -c.length) + t[3]), n = document.createTextNode(o)
                }
                r.insertBefore(n, t), this.parts.push({type: "node", index: ++l})
              }
              "" === i[o] ? (r.insertBefore(f(), t), n.push(t)) : t.data = i[o], h += o
            }
          } else if (8 === t.nodeType) if (t.data === o) {
            const e = t.parentNode;
            null !== t.previousSibling && l !== s || (l++, e.insertBefore(f(), t)), s = l, this.parts.push({
              type: "node",
              index: l
            }), null === t.nextSibling ? t.data = "" : (n.push(t), l--), h++
          } else {
            let e = -1;
            for (; -1 !== (e = t.data.indexOf(o, e + 1));) this.parts.push({type: "node", index: -1}), h++
          }
        } else i.currentNode = r.pop()
      }
      for (const o of n) o.parentNode.removeChild(o)
    }
  }

  const u = (t, e) => {
      const n = t.length - e.length;
      return n >= 0 && t.slice(n) === e
    }, h = t => -1 !== t.index, f = () => document.createComment(""),
    d = /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

  function p(t, e) {
    const {element: {content: n}, parts: r} = t, i = document.createTreeWalker(n, 133, null, !1);
    let o = v(r), s = r[o], a = -1, c = 0;
    const l = [];
    let u = null;
    for (; i.nextNode();) {
      a++;
      const t = i.currentNode;
      for (t.previousSibling === u && (u = null), e.has(t) && (l.push(t), null === u && (u = t)), null !== u && c++; void 0 !== s && s.index === a;) s.index = null !== u ? -1 : s.index - c, o = v(r, o), s = r[o]
    }
    l.forEach((t => t.parentNode.removeChild(t)))
  }

  const m = t => {
    let e = 11 === t.nodeType ? 0 : 1;
    const n = document.createTreeWalker(t, 133, null, !1);
    for (; n.nextNode();) e++;
    return e
  }, v = (t, e = -1) => {
    for (let n = e + 1; n < t.length; n++) {
      const e = t[n];
      if (h(e)) return n
    }
    return -1
  };
  const g = new WeakMap, y = t => "function" == typeof t && g.has(t), _ = {}, b = {};

  class x {
    constructor(t, e, n) {
      this.__parts = [], this.template = t, this.processor = e, this.options = n
    }

    update(t) {
      let e = 0;
      for (const n of this.__parts) void 0 !== n && n.setValue(t[e]), e++;
      for (const n of this.__parts) void 0 !== n && n.commit()
    }

    _clone() {
      const t = r ? this.template.element.content.cloneNode(!0) : document.importNode(this.template.element.content, !0),
        e = [], n = this.template.parts, i = document.createTreeWalker(t, 133, null, !1);
      let o, s = 0, a = 0, c = i.nextNode();
      for (; s < n.length;) if (o = n[s], h(o)) {
        for (; a < o.index;) a++, "TEMPLATE" === c.nodeName && (e.push(c), i.currentNode = c.content), null === (c = i.nextNode()) && (i.currentNode = e.pop(), c = i.nextNode());
        if ("node" === o.type) {
          const t = this.processor.handleTextExpression(this.options);
          t.insertAfterNode(c.previousSibling), this.__parts.push(t)
        } else this.__parts.push(...this.processor.handleAttributeExpressions(c, o.name, o.strings, this.options));
        s++
      } else this.__parts.push(void 0), s++;
      return r && (document.adoptNode(t), customElements.upgrade(t)), t
    }
  }

  const w = window.trustedTypes && trustedTypes.createPolicy("lit-html", {createHTML: t => t}), S = ` ${o} `;

  class M {
    constructor(t, e, n, r) {
      this.strings = t, this.values = e, this.type = n, this.processor = r
    }

    getHTML() {
      const t = this.strings.length - 1;
      let e = "", n = !1;
      for (let r = 0; r < t; r++) {
        const t = this.strings[r], i = t.lastIndexOf("\x3c!--");
        n = (i > -1 || n) && -1 === t.indexOf("--\x3e", i + 1);
        const a = d.exec(t);
        e += null === a ? t + (n ? S : s) : t.substr(0, a.index) + a[1] + a[2] + c + a[3] + o
      }
      return e += this.strings[t], e
    }

    getTemplateElement() {
      const t = document.createElement("template");
      let e = this.getHTML();
      return void 0 !== w && (e = w.createHTML(e)), t.innerHTML = e, t
    }
  }

  const E = t => null === t || !("object" == typeof t || "function" == typeof t),
    T = t => Array.isArray(t) || !(!t || !t[Symbol.iterator]);

  class O {
    constructor(t, e, n) {
      this.dirty = !0, this.element = t, this.name = e, this.strings = n, this.parts = [];
      for (let r = 0; r < n.length - 1; r++) this.parts[r] = this._createPart()
    }

    _createPart() {
      return new H(this)
    }

    _getValue() {
      const t = this.strings, e = t.length - 1, n = this.parts;
      if (1 === e && "" === t[0] && "" === t[1]) {
        const t = n[0].value;
        if ("symbol" == typeof t) return String(t);
        if ("string" == typeof t || !T(t)) return t
      }
      let r = "";
      for (let i = 0; i < e; i++) {
        r += t[i];
        const e = n[i];
        if (void 0 !== e) {
          const t = e.value;
          if (E(t) || !T(t)) r += "string" == typeof t ? t : String(t); else for (const e of t) r += "string" == typeof e ? e : String(e)
        }
      }
      return r += t[e], r
    }

    commit() {
      this.dirty && (this.dirty = !1, this.element.setAttribute(this.name, this._getValue()))
    }
  }

  class H {
    constructor(t) {
      this.value = void 0, this.committer = t
    }

    setValue(t) {
      t === _ || E(t) && t === this.value || (this.value = t, y(t) || (this.committer.dirty = !0))
    }

    commit() {
      for (; y(this.value);) {
        const t = this.value;
        this.value = _, t(this)
      }
      this.value !== _ && this.committer.commit()
    }
  }

  class A {
    constructor(t) {
      this.value = void 0, this.__pendingValue = void 0, this.options = t
    }

    appendInto(t) {
      this.startNode = t.appendChild(f()), this.endNode = t.appendChild(f())
    }

    insertAfterNode(t) {
      this.startNode = t, this.endNode = t.nextSibling
    }

    appendIntoPart(t) {
      t.__insert(this.startNode = f()), t.__insert(this.endNode = f())
    }

    insertAfterPart(t) {
      t.__insert(this.startNode = f()), this.endNode = t.endNode, t.endNode = this.startNode
    }

    setValue(t) {
      this.__pendingValue = t
    }

    commit() {
      if (null === this.startNode.parentNode) return;
      for (; y(this.__pendingValue);) {
        const t = this.__pendingValue;
        this.__pendingValue = _, t(this)
      }
      const t = this.__pendingValue;
      t !== _ && (E(t) ? t !== this.value && this.__commitText(t) : t instanceof M ? this.__commitTemplateResult(t) : t instanceof Node ? this.__commitNode(t) : T(t) ? this.__commitIterable(t) : t === b ? (this.value = b, this.clear()) : this.__commitText(t))
    }

    __insert(t) {
      this.endNode.parentNode.insertBefore(t, this.endNode)
    }

    __commitNode(t) {
      this.value !== t && (this.clear(), this.__insert(t), this.value = t)
    }

    __commitText(t) {
      const e = this.startNode.nextSibling, n = "string" == typeof(t = null == t ? "" : t) ? t : String(t);
      e === this.endNode.previousSibling && 3 === e.nodeType ? e.data = n : this.__commitNode(document.createTextNode(n)), this.value = t
    }

    __commitTemplateResult(t) {
      const e = this.options.templateFactory(t);
      if (this.value instanceof x && this.value.template === e) this.value.update(t.values); else {
        const n = new x(e, t.processor, this.options), r = n._clone();
        n.update(t.values), this.__commitNode(r), this.value = n
      }
    }

    __commitIterable(t) {
      Array.isArray(this.value) || (this.value = [], this.clear());
      const e = this.value;
      let n, r = 0;
      for (const i of t) n = e[r], void 0 === n && (n = new A(this.options), e.push(n), 0 === r ? n.appendIntoPart(this) : n.insertAfterPart(e[r - 1])), n.setValue(i), n.commit(), r++;
      r < e.length && (e.length = r, this.clear(n && n.endNode))
    }

    clear(t = this.startNode) {
      i(this.startNode.parentNode, t.nextSibling, this.endNode)
    }
  }

  class P {
    constructor(t, e, n) {
      if (this.value = void 0, this.__pendingValue = void 0, 2 !== n.length || "" !== n[0] || "" !== n[1]) throw new Error("Boolean attributes can only contain a single expression");
      this.element = t, this.name = e, this.strings = n
    }

    setValue(t) {
      this.__pendingValue = t
    }

    commit() {
      for (; y(this.__pendingValue);) {
        const t = this.__pendingValue;
        this.__pendingValue = _, t(this)
      }
      if (this.__pendingValue === _) return;
      const t = !!this.__pendingValue;
      this.value !== t && (t ? this.element.setAttribute(this.name, "") : this.element.removeAttribute(this.name), this.value = t), this.__pendingValue = _
    }
  }

  class R extends O {
    constructor(t, e, n) {
      super(t, e, n), this.single = 2 === n.length && "" === n[0] && "" === n[1]
    }

    _createPart() {
      return new L(this)
    }

    _getValue() {
      return this.single ? this.parts[0].value : super._getValue()
    }

    commit() {
      this.dirty && (this.dirty = !1, this.element[this.name] = this._getValue())
    }
  }

  class L extends H {
  }

  let C = !1;
  (() => {
    try {
      const t = {
        get capture() {
          return C = !0, !1
        }
      };
      window.addEventListener("test", t, t), window.removeEventListener("test", t, t)
    } catch (t) {
    }
  })();

  class k {
    constructor(t, e, n) {
      this.value = void 0, this.__pendingValue = void 0, this.element = t, this.eventName = e, this.eventContext = n, this.__boundHandleEvent = t => this.handleEvent(t)
    }

    setValue(t) {
      this.__pendingValue = t
    }

    commit() {
      for (; y(this.__pendingValue);) {
        const t = this.__pendingValue;
        this.__pendingValue = _, t(this)
      }
      if (this.__pendingValue === _) return;
      const t = this.__pendingValue, e = this.value,
        n = null == t || null != e && (t.capture !== e.capture || t.once !== e.once || t.passive !== e.passive),
        r = null != t && (null == e || n);
      n && this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options), r && (this.__options = D(t), this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options)), this.value = t, this.__pendingValue = _
    }

    handleEvent(t) {
      "function" == typeof this.value ? this.value.call(this.eventContext || this.element, t) : this.value.handleEvent(t)
    }
  }

  const D = t => t && (C ? {capture: t.capture, passive: t.passive, once: t.once} : t.capture);

  function N(t) {
    let e = z.get(t.type);
    void 0 === e && (e = {stringsArray: new WeakMap, keyString: new Map}, z.set(t.type, e));
    let n = e.stringsArray.get(t.strings);
    if (void 0 !== n) return n;
    const r = t.strings.join(o);
    return n = e.keyString.get(r), void 0 === n && (n = new l(t, t.getTemplateElement()), e.keyString.set(r, n)), e.stringsArray.set(t.strings, n), n
  }

  const z = new Map, j = new WeakMap;
  new class {
    handleAttributeExpressions(t, e, n, r) {
      const i = e[0];
      if ("." === i) {
        return new R(t, e.slice(1), n).parts
      }
      if ("@" === i) return [new k(t, e.slice(1), r.eventContext)];
      if ("?" === i) return [new P(t, e.slice(1), n)];
      return new O(t, e, n).parts
    }

    handleTextExpression(t) {
      return new A(t)
    }
  };
  "undefined" != typeof window && (window.litHtmlVersions || (window.litHtmlVersions = [])).push("1.4.1");
  const I = (t, e) => `${t}--${e}`;
  let B = !0;
  void 0 === window.ShadyCSS ? B = !1 : void 0 === window.ShadyCSS.prepareTemplateDom && (console.warn("Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1."), B = !1);
  const F = t => e => {
    const n = I(e.type, t);
    let r = z.get(n);
    void 0 === r && (r = {stringsArray: new WeakMap, keyString: new Map}, z.set(n, r));
    let i = r.stringsArray.get(e.strings);
    if (void 0 !== i) return i;
    const s = e.strings.join(o);
    if (i = r.keyString.get(s), void 0 === i) {
      const n = e.getTemplateElement();
      B && window.ShadyCSS.prepareTemplateDom(n, t), i = new l(e, n), r.keyString.set(s, i)
    }
    return r.stringsArray.set(e.strings, i), i
  }, U = ["html", "svg"], G = new Set, V = (t, e, n) => {
    G.add(t);
    const r = n ? n.element : document.createElement("template"), i = e.querySelectorAll("style"), {length: o} = i;
    if (0 === o) return void window.ShadyCSS.prepareTemplateStyles(r, t);
    const s = document.createElement("style");
    for (let l = 0; l < o; l++) {
      const t = i[l];
      t.parentNode.removeChild(t), s.textContent += t.textContent
    }
    (t => {
      U.forEach((e => {
        const n = z.get(I(e, t));
        void 0 !== n && n.keyString.forEach((t => {
          const {element: {content: e}} = t, n = new Set;
          Array.from(e.querySelectorAll("style")).forEach((t => {
            n.add(t)
          })), p(t, n)
        }))
      }))
    })(t);
    const a = r.content;
    n ? function (t, e, n = null) {
      const {element: {content: r}, parts: i} = t;
      if (null == n) return void r.appendChild(e);
      const o = document.createTreeWalker(r, 133, null, !1);
      let s = v(i), a = 0, c = -1;
      for (; o.nextNode();) for (c++, o.currentNode === n && (a = m(e), n.parentNode.insertBefore(e, n)); -1 !== s && i[s].index === c;) {
        if (a > 0) {
          for (; -1 !== s;) i[s].index += a, s = v(i, s);
          return
        }
        s = v(i, s)
      }
    }(n, s, a.firstChild) : a.insertBefore(s, a.firstChild), window.ShadyCSS.prepareTemplateStyles(r, t);
    const c = a.querySelector("style");
    if (window.ShadyCSS.nativeShadow && null !== c) e.insertBefore(c.cloneNode(!0), e.firstChild); else if (n) {
      a.insertBefore(s, a.firstChild);
      const t = new Set;
      t.add(s), p(n, t)
    }
  };
  window.JSCompiler_renameProperty = t => t;
  const W = {
      toAttribute(t, e) {
        switch (e) {
          case Boolean:
            return t ? "" : null;
          case Object:
          case Array:
            return null == t ? t : JSON.stringify(t)
        }
        return t
      }, fromAttribute(t, e) {
        switch (e) {
          case Boolean:
            return null !== t;
          case Number:
            return null === t ? null : Number(t);
          case Object:
          case Array:
            return JSON.parse(t)
        }
        return t
      }
    }, X = (t, e) => e !== t && (e == e || t == t),
    q = {attribute: !0, type: String, converter: W, reflect: !1, hasChanged: X}, Y = "finalized";

  class Z extends HTMLElement {
    constructor() {
      super(), this.initialize()
    }

    static get observedAttributes() {
      this.finalize();
      const t = [];
      return this._classProperties.forEach(((e, n) => {
        const r = this._attributeNameForProperty(n, e);
        void 0 !== r && (this._attributeToPropertyMap.set(r, n), t.push(r))
      })), t
    }

    static _ensureClassProperties() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties", this))) {
        this._classProperties = new Map;
        const t = Object.getPrototypeOf(this)._classProperties;
        void 0 !== t && t.forEach(((t, e) => this._classProperties.set(e, t)))
      }
    }

    static createProperty(t, e = q) {
      if (this._ensureClassProperties(), this._classProperties.set(t, e), e.noAccessor || this.prototype.hasOwnProperty(t)) return;
      const n = "symbol" == typeof t ? Symbol() : `__${t}`, r = this.getPropertyDescriptor(t, n, e);
      void 0 !== r && Object.defineProperty(this.prototype, t, r)
    }

    static getPropertyDescriptor(t, e, n) {
      return {
        get() {
          return this[e]
        }, set(r) {
          const i = this[t];
          this[e] = r, this.requestUpdateInternal(t, i, n)
        }, configurable: !0, enumerable: !0
      }
    }

    static getPropertyOptions(t) {
      return this._classProperties && this._classProperties.get(t) || q
    }

    static finalize() {
      const t = Object.getPrototypeOf(this);
      if (t.hasOwnProperty(Y) || t.finalize(), this.finalized = !0, this._ensureClassProperties(), this._attributeToPropertyMap = new Map, this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
        const t = this.properties,
          e = [...Object.getOwnPropertyNames(t), ..."function" == typeof Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(t) : []];
        for (const n of e) this.createProperty(n, t[n])
      }
    }

    static _attributeNameForProperty(t, e) {
      const n = e.attribute;
      return !1 === n ? void 0 : "string" == typeof n ? n : "string" == typeof t ? t.toLowerCase() : void 0
    }

    static _valueHasChanged(t, e, n = X) {
      return n(t, e)
    }

    static _propertyValueFromAttribute(t, e) {
      const n = e.type, r = e.converter || W, i = "function" == typeof r ? r : r.fromAttribute;
      return i ? i(t, n) : t
    }

    static _propertyValueToAttribute(t, e) {
      if (void 0 === e.reflect) return;
      const n = e.type, r = e.converter;
      return (r && r.toAttribute || W.toAttribute)(t, n)
    }

    initialize() {
      this._updateState = 0, this._updatePromise = new Promise((t => this._enableUpdatingResolver = t)), this._changedProperties = new Map, this._saveInstanceProperties(), this.requestUpdateInternal()
    }

    _saveInstanceProperties() {
      this.constructor._classProperties.forEach(((t, e) => {
        if (this.hasOwnProperty(e)) {
          const t = this[e];
          delete this[e], this._instanceProperties || (this._instanceProperties = new Map), this._instanceProperties.set(e, t)
        }
      }))
    }

    _applyInstanceProperties() {
      this._instanceProperties.forEach(((t, e) => this[e] = t)), this._instanceProperties = void 0
    }

    connectedCallback() {
      this.enableUpdating()
    }

    enableUpdating() {
      void 0 !== this._enableUpdatingResolver && (this._enableUpdatingResolver(), this._enableUpdatingResolver = void 0)
    }

    disconnectedCallback() {
    }

    attributeChangedCallback(t, e, n) {
      e !== n && this._attributeToProperty(t, n)
    }

    _propertyToAttribute(t, e, n = q) {
      const r = this.constructor, i = r._attributeNameForProperty(t, n);
      if (void 0 !== i) {
        const t = r._propertyValueToAttribute(e, n);
        if (void 0 === t) return;
        this._updateState = 8 | this._updateState, null == t ? this.removeAttribute(i) : this.setAttribute(i, t), this._updateState = -9 & this._updateState
      }
    }

    _attributeToProperty(t, e) {
      if (8 & this._updateState) return;
      const n = this.constructor, r = n._attributeToPropertyMap.get(t);
      if (void 0 !== r) {
        const t = n.getPropertyOptions(r);
        this._updateState = 16 | this._updateState, this[r] = n._propertyValueFromAttribute(e, t), this._updateState = -17 & this._updateState
      }
    }

    requestUpdateInternal(t, e, n) {
      let r = !0;
      if (void 0 !== t) {
        const i = this.constructor;
        n = n || i.getPropertyOptions(t), i._valueHasChanged(this[t], e, n.hasChanged) ? (this._changedProperties.has(t) || this._changedProperties.set(t, e), !0 !== n.reflect || 16 & this._updateState || (void 0 === this._reflectingProperties && (this._reflectingProperties = new Map), this._reflectingProperties.set(t, n))) : r = !1
      }
      !this._hasRequestedUpdate && r && (this._updatePromise = this._enqueueUpdate())
    }

    requestUpdate(t, e) {
      return this.requestUpdateInternal(t, e), this.updateComplete
    }

    async _enqueueUpdate() {
      this._updateState = 4 | this._updateState;
      try {
        await this._updatePromise
      } catch (e) {
      }
      const t = this.performUpdate();
      return null != t && await t, !this._hasRequestedUpdate
    }

    get _hasRequestedUpdate() {
      return 4 & this._updateState
    }

    get hasUpdated() {
      return 1 & this._updateState
    }

    performUpdate() {
      if (!this._hasRequestedUpdate) return;
      this._instanceProperties && this._applyInstanceProperties();
      let t = !1;
      const e = this._changedProperties;
      try {
        t = this.shouldUpdate(e), t ? this.update(e) : this._markUpdated()
      } catch (n) {
        throw t = !1, this._markUpdated(), n
      }
      t && (1 & this._updateState || (this._updateState = 1 | this._updateState, this.firstUpdated(e)), this.updated(e))
    }

    _markUpdated() {
      this._changedProperties = new Map, this._updateState = -5 & this._updateState
    }

    get updateComplete() {
      return this._getUpdateComplete()
    }

    _getUpdateComplete() {
      return this.getUpdateComplete()
    }

    getUpdateComplete() {
      return this._updatePromise
    }

    shouldUpdate(t) {
      return !0
    }

    update(t) {
      void 0 !== this._reflectingProperties && this._reflectingProperties.size > 0 && (this._reflectingProperties.forEach(((t, e) => this._propertyToAttribute(e, this[e], t))), this._reflectingProperties = void 0), this._markUpdated()
    }

    updated(t) {
    }

    firstUpdated(t) {
    }
  }

  Z.finalized = !0;
  const J = t => e => "function" == typeof e ? ((t, e) => (window.customElements.define(t, e), e))(t, e) : ((t, e) => {
      const {kind: n, elements: r} = e;
      return {
        kind: n, elements: r, finisher(e) {
          window.customElements.define(t, e)
        }
      }
    })(t, e),
    K = (t, e) => "method" === e.kind && e.descriptor && !("value" in e.descriptor) ? Object.assign(Object.assign({}, e), {
      finisher(n) {
        n.createProperty(e.key, t)
      }
    }) : {
      kind: "field", key: Symbol(), placement: "own", descriptor: {}, initializer() {
        "function" == typeof e.initializer && (this[e.key] = e.initializer.call(this))
      }, finisher(n) {
        n.createProperty(e.key, t)
      }
    };

  function Q(t) {
    return (e, n) => void 0 !== n ? ((t, e, n) => {
      e.constructor.createProperty(n, t)
    })(t, e, n) : K(t, e)
  }

  const $ = Element.prototype;
  $.msMatchesSelector || $.webkitMatchesSelector;
  const tt = window.ShadowRoot && (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype,
    et = Symbol();

  class nt {
    constructor(t, e) {
      if (e !== et) throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      this.cssText = t
    }

    get styleSheet() {
      return void 0 === this._styleSheet && (tt ? (this._styleSheet = new CSSStyleSheet, this._styleSheet.replaceSync(this.cssText)) : this._styleSheet = null), this._styleSheet
    }

    toString() {
      return this.cssText
    }
  }

  (window.litElementVersions || (window.litElementVersions = [])).push("2.5.1");
  const rt = {};

  class it extends Z {
    static getStyles() {
      return this.styles
    }

    static _getUniqueStyles() {
      if (this.hasOwnProperty(JSCompiler_renameProperty("_styles", this))) return;
      const t = this.getStyles();
      if (Array.isArray(t)) {
        const e = (t, n) => t.reduceRight(((t, n) => Array.isArray(n) ? e(n, t) : (t.add(n), t)), n), n = e(t, new Set),
          r = [];
        n.forEach((t => r.unshift(t))), this._styles = r
      } else this._styles = void 0 === t ? [] : [t];
      this._styles = this._styles.map((t => {
        if (t instanceof CSSStyleSheet && !tt) {
          const e = Array.prototype.slice.call(t.cssRules).reduce(((t, e) => t + e.cssText), "");
          return new nt(String(e), et)
        }
        return t
      }))
    }

    initialize() {
      super.initialize(), this.constructor._getUniqueStyles(), this.renderRoot = this.createRenderRoot(), window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot && this.adoptStyles()
    }

    createRenderRoot() {
      return this.attachShadow(this.constructor.shadowRootOptions)
    }

    adoptStyles() {
      const t = this.constructor._styles;
      0 !== t.length && (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow ? tt ? this.renderRoot.adoptedStyleSheets = t.map((t => t instanceof CSSStyleSheet ? t : t.styleSheet)) : this._needsShimAdoptedStyleSheets = !0 : window.ShadyCSS.ScopingShim.prepareAdoptedCssText(t.map((t => t.cssText)), this.localName))
    }

    connectedCallback() {
      super.connectedCallback(), this.hasUpdated && void 0 !== window.ShadyCSS && window.ShadyCSS.styleElement(this)
    }

    update(t) {
      const e = this.render();
      super.update(t), e !== rt && this.constructor.render(e, this.renderRoot, {
        scopeName: this.localName,
        eventContext: this
      }), this._needsShimAdoptedStyleSheets && (this._needsShimAdoptedStyleSheets = !1, this.constructor._styles.forEach((t => {
        const e = document.createElement("style");
        e.textContent = t.cssText, this.renderRoot.appendChild(e)
      })))
    }

    render() {
      return rt
    }
  }

  it.finalized = !0, it.render = (t, e, n) => {
    if (!n || "object" != typeof n || !n.scopeName) throw new Error("The `scopeName` option is required.");
    const r = n.scopeName, o = j.has(e), s = B && 11 === e.nodeType && !!e.host, a = s && !G.has(r),
      c = a ? document.createDocumentFragment() : e;
    if (((t, e, n) => {
      let r = j.get(e);
      void 0 === r && (i(e, e.firstChild), j.set(e, r = new A(Object.assign({templateFactory: N}, n))), r.appendInto(e)), r.setValue(t), r.commit()
    })(t, c, Object.assign({templateFactory: F(r)}, n)), a) {
      const t = j.get(c);
      j.delete(c);
      const n = t.value instanceof x ? t.value.template : void 0;
      V(r, c, n), i(e, e.firstChild), e.appendChild(c), j.set(e, t)
    }
    !o && s && window.ShadyCSS.styleElement(e.host)
  }, it.shadowRootOptions = {mode: "open"}
}, function (t, e, n) {
  "use strict";

  function r(t, e) {
    var n = t.__state.conversionName.toString(), r = Math.round(t.r), i = Math.round(t.g), o = Math.round(t.b), s = t.a,
      a = Math.round(t.h), c = t.s.toFixed(1), l = t.v.toFixed(1);
    if (e || "THREE_CHAR_HEX" === n || "SIX_CHAR_HEX" === n) {
      for (var u = t.hex.toString(16); u.length < 6;) u = "0" + u;
      return "#" + u
    }
    return "CSS_RGB" === n ? "rgb(" + r + "," + i + "," + o + ")" : "CSS_RGBA" === n ? "rgba(" + r + "," + i + "," + o + "," + s + ")" : "HEX" === n ? "0x" + t.hex.toString(16) : "RGB_ARRAY" === n ? "[" + r + "," + i + "," + o + "]" : "RGBA_ARRAY" === n ? "[" + r + "," + i + "," + o + "," + s + "]" : "RGB_OBJ" === n ? "{r:" + r + ",g:" + i + ",b:" + o + "}" : "RGBA_OBJ" === n ? "{r:" + r + ",g:" + i + ",b:" + o + ",a:" + s + "}" : "HSV_OBJ" === n ? "{h:" + a + ",s:" + c + ",v:" + l + "}" : "HSVA_OBJ" === n ? "{h:" + a + ",s:" + c + ",v:" + l + ",a:" + s + "}" : "unknown format"
  }

  n.d(e, "a", (function () {
    return vt
  })), n.d(e, "b", (function () {
    return gt
  }));
  var i = Array.prototype.forEach, o = Array.prototype.slice, s = {
    BREAK: {}, extend: function (t) {
      return this.each(o.call(arguments, 1), (function (e) {
        (this.isObject(e) ? Object.keys(e) : []).forEach(function (n) {
          this.isUndefined(e[n]) || (t[n] = e[n])
        }.bind(this))
      }), this), t
    }, defaults: function (t) {
      return this.each(o.call(arguments, 1), (function (e) {
        (this.isObject(e) ? Object.keys(e) : []).forEach(function (n) {
          this.isUndefined(t[n]) && (t[n] = e[n])
        }.bind(this))
      }), this), t
    }, compose: function () {
      var t = o.call(arguments);
      return function () {
        for (var e = o.call(arguments), n = t.length - 1; n >= 0; n--) e = [t[n].apply(this, e)];
        return e[0]
      }
    }, each: function (t, e, n) {
      if (t) if (i && t.forEach && t.forEach === i) t.forEach(e, n); else if (t.length === t.length + 0) {
        var r, o = void 0;
        for (o = 0, r = t.length; o < r; o++) if (o in t && e.call(n, t[o], o) === this.BREAK) return
      } else for (var s in t) if (e.call(n, t[s], s) === this.BREAK) return
    }, defer: function (t) {
      setTimeout(t, 0)
    }, debounce: function (t, e, n) {
      var r = void 0;
      return function () {
        var i = this, o = arguments;

        function s() {
          r = null, n || t.apply(i, o)
        }

        var a = n || !r;
        clearTimeout(r), r = setTimeout(s, e), a && t.apply(i, o)
      }
    }, toArray: function (t) {
      return t.toArray ? t.toArray() : o.call(t)
    }, isUndefined: function (t) {
      return void 0 === t
    }, isNull: function (t) {
      return null === t
    }, isNaN: function (t) {
      function e(e) {
        return t.apply(this, arguments)
      }

      return e.toString = function () {
        return t.toString()
      }, e
    }((function (t) {
      return isNaN(t)
    })), isArray: Array.isArray || function (t) {
      return t.constructor === Array
    }, isObject: function (t) {
      return t === Object(t)
    }, isNumber: function (t) {
      return t === t + 0
    }, isString: function (t) {
      return t === t + ""
    }, isBoolean: function (t) {
      return !1 === t || !0 === t
    }, isFunction: function (t) {
      return t instanceof Function
    }
  }, a = [{
    litmus: s.isString, conversions: {
      THREE_CHAR_HEX: {
        read: function (t) {
          var e = t.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
          return null !== e && {
            space: "HEX",
            hex: parseInt("0x" + e[1].toString() + e[1].toString() + e[2].toString() + e[2].toString() + e[3].toString() + e[3].toString(), 0)
          }
        }, write: r
      }, SIX_CHAR_HEX: {
        read: function (t) {
          var e = t.match(/^#([A-F0-9]{6})$/i);
          return null !== e && {space: "HEX", hex: parseInt("0x" + e[1].toString(), 0)}
        }, write: r
      }, CSS_RGB: {
        read: function (t) {
          var e = t.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
          return null !== e && {space: "RGB", r: parseFloat(e[1]), g: parseFloat(e[2]), b: parseFloat(e[3])}
        }, write: r
      }, CSS_RGBA: {
        read: function (t) {
          var e = t.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
          return null !== e && {
            space: "RGB",
            r: parseFloat(e[1]),
            g: parseFloat(e[2]),
            b: parseFloat(e[3]),
            a: parseFloat(e[4])
          }
        }, write: r
      }
    }
  }, {
    litmus: s.isNumber, conversions: {
      HEX: {
        read: function (t) {
          return {space: "HEX", hex: t, conversionName: "HEX"}
        }, write: function (t) {
          return t.hex
        }
      }
    }
  }, {
    litmus: s.isArray, conversions: {
      RGB_ARRAY: {
        read: function (t) {
          return 3 === t.length && {space: "RGB", r: t[0], g: t[1], b: t[2]}
        }, write: function (t) {
          return [t.r, t.g, t.b]
        }
      }, RGBA_ARRAY: {
        read: function (t) {
          return 4 === t.length && {space: "RGB", r: t[0], g: t[1], b: t[2], a: t[3]}
        }, write: function (t) {
          return [t.r, t.g, t.b, t.a]
        }
      }
    }
  }, {
    litmus: s.isObject, conversions: {
      RGBA_OBJ: {
        read: function (t) {
          return !!(s.isNumber(t.r) && s.isNumber(t.g) && s.isNumber(t.b) && s.isNumber(t.a)) && {
            space: "RGB",
            r: t.r,
            g: t.g,
            b: t.b,
            a: t.a
          }
        }, write: function (t) {
          return {r: t.r, g: t.g, b: t.b, a: t.a}
        }
      }, RGB_OBJ: {
        read: function (t) {
          return !!(s.isNumber(t.r) && s.isNumber(t.g) && s.isNumber(t.b)) && {space: "RGB", r: t.r, g: t.g, b: t.b}
        }, write: function (t) {
          return {r: t.r, g: t.g, b: t.b}
        }
      }, HSVA_OBJ: {
        read: function (t) {
          return !!(s.isNumber(t.h) && s.isNumber(t.s) && s.isNumber(t.v) && s.isNumber(t.a)) && {
            space: "HSV",
            h: t.h,
            s: t.s,
            v: t.v,
            a: t.a
          }
        }, write: function (t) {
          return {h: t.h, s: t.s, v: t.v, a: t.a}
        }
      }, HSV_OBJ: {
        read: function (t) {
          return !!(s.isNumber(t.h) && s.isNumber(t.s) && s.isNumber(t.v)) && {space: "HSV", h: t.h, s: t.s, v: t.v}
        }, write: function (t) {
          return {h: t.h, s: t.s, v: t.v}
        }
      }
    }
  }], c = void 0, l = void 0, u = function () {
    l = !1;
    var t = arguments.length > 1 ? s.toArray(arguments) : arguments[0];
    return s.each(a, (function (e) {
      if (e.litmus(t)) return s.each(e.conversions, (function (e, n) {
        if (c = e.read(t), !1 === l && !1 !== c) return l = c, c.conversionName = n, c.conversion = e, s.BREAK
      })), s.BREAK
    })), l
  }, h = void 0, f = {
    hsv_to_rgb: function (t, e, n) {
      var r = Math.floor(t / 60) % 6, i = t / 60 - Math.floor(t / 60), o = n * (1 - e), s = n * (1 - i * e),
        a = n * (1 - (1 - i) * e), c = [[n, a, o], [s, n, o], [o, n, a], [o, s, n], [a, o, n], [n, o, s]][r];
      return {r: 255 * c[0], g: 255 * c[1], b: 255 * c[2]}
    }, rgb_to_hsv: function (t, e, n) {
      var r = Math.min(t, e, n), i = Math.max(t, e, n), o = i - r, s = void 0;
      return 0 === i ? {
        h: NaN,
        s: 0,
        v: 0
      } : (s = t === i ? (e - n) / o : e === i ? 2 + (n - t) / o : 4 + (t - e) / o, (s /= 6) < 0 && (s += 1), {
        h: 360 * s,
        s: o / i,
        v: i / 255
      })
    }, rgb_to_hex: function (t, e, n) {
      var r = this.hex_with_component(0, 2, t);
      return r = this.hex_with_component(r, 1, e), r = this.hex_with_component(r, 0, n)
    }, component_from_hex: function (t, e) {
      return t >> 8 * e & 255
    }, hex_with_component: function (t, e, n) {
      return n << (h = 8 * e) | t & ~(255 << h)
    }
  }, d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
    return typeof t
  } : function (t) {
    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
  }, p = function (t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }, m = function () {
    function t(t, e) {
      for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
      }
    }

    return function (e, n, r) {
      return n && t(e.prototype, n), r && t(e, r), e
    }
  }(), v = function t(e, n, r) {
    null === e && (e = Function.prototype);
    var i = Object.getOwnPropertyDescriptor(e, n);
    if (void 0 === i) {
      var o = Object.getPrototypeOf(e);
      return null === o ? void 0 : t(o, n, r)
    }
    if ("value" in i) return i.value;
    var s = i.get;
    return void 0 !== s ? s.call(r) : void 0
  }, g = function (t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
  }, y = function (t, e) {
    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return !e || "object" != typeof e && "function" != typeof e ? t : e
  }, _ = function () {
    function t() {
      if (p(this, t), this.__state = u.apply(this, arguments), !1 === this.__state) throw new Error("Failed to interpret color arguments");
      this.__state.a = this.__state.a || 1
    }

    return m(t, [{
      key: "toString", value: function () {
        return r(this)
      }
    }, {
      key: "toHexString", value: function () {
        return r(this, !0)
      }
    }, {
      key: "toOriginal", value: function () {
        return this.__state.conversion.write(this)
      }
    }]), t
  }();

  function b(t, e, n) {
    Object.defineProperty(t, e, {
      get: function () {
        return "RGB" === this.__state.space || _.recalculateRGB(this, e, n), this.__state[e]
      }, set: function (t) {
        "RGB" !== this.__state.space && (_.recalculateRGB(this, e, n), this.__state.space = "RGB"), this.__state[e] = t
      }
    })
  }

  function x(t, e) {
    Object.defineProperty(t, e, {
      get: function () {
        return "HSV" === this.__state.space || _.recalculateHSV(this), this.__state[e]
      }, set: function (t) {
        "HSV" !== this.__state.space && (_.recalculateHSV(this), this.__state.space = "HSV"), this.__state[e] = t
      }
    })
  }

  _.recalculateRGB = function (t, e, n) {
    if ("HEX" === t.__state.space) t.__state[e] = f.component_from_hex(t.__state.hex, n); else {
      if ("HSV" !== t.__state.space) throw new Error("Corrupted color state");
      s.extend(t.__state, f.hsv_to_rgb(t.__state.h, t.__state.s, t.__state.v))
    }
  }, _.recalculateHSV = function (t) {
    var e = f.rgb_to_hsv(t.r, t.g, t.b);
    s.extend(t.__state, {
      s: e.s,
      v: e.v
    }), s.isNaN(e.h) ? s.isUndefined(t.__state.h) && (t.__state.h = 0) : t.__state.h = e.h
  }, _.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], b(_.prototype, "r", 2), b(_.prototype, "g", 1), b(_.prototype, "b", 0), x(_.prototype, "h"), x(_.prototype, "s"), x(_.prototype, "v"), Object.defineProperty(_.prototype, "a", {
    get: function () {
      return this.__state.a
    }, set: function (t) {
      this.__state.a = t
    }
  }), Object.defineProperty(_.prototype, "hex", {
    get: function () {
      return "HEX" !== this.__state.space && (this.__state.hex = f.rgb_to_hex(this.r, this.g, this.b), this.__state.space = "HEX"), this.__state.hex
    }, set: function (t) {
      this.__state.space = "HEX", this.__state.hex = t
    }
  });
  var w = function () {
    function t(e, n) {
      p(this, t), this.initialValue = e[n], this.domElement = document.createElement("div"), this.object = e, this.property = n, this.__onChange = void 0, this.__onFinishChange = void 0
    }

    return m(t, [{
      key: "onChange", value: function (t) {
        return this.__onChange = t, this
      }
    }, {
      key: "onFinishChange", value: function (t) {
        return this.__onFinishChange = t, this
      }
    }, {
      key: "setValue", value: function (t) {
        return this.object[this.property] = t, this.__onChange && this.__onChange.call(this, t), this.updateDisplay(), this
      }
    }, {
      key: "getValue", value: function () {
        return this.object[this.property]
      }
    }, {
      key: "updateDisplay", value: function () {
        return this
      }
    }, {
      key: "isModified", value: function () {
        return this.initialValue !== this.getValue()
      }
    }]), t
  }(), S = {};
  s.each({
    HTMLEvents: ["change"],
    MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
    KeyboardEvents: ["keydown"]
  }, (function (t, e) {
    s.each(t, (function (t) {
      S[t] = e
    }))
  }));
  var M = /(\d+(\.\d+)?)px/;

  function E(t) {
    if ("0" === t || s.isUndefined(t)) return 0;
    var e = t.match(M);
    return s.isNull(e) ? 0 : parseFloat(e[1])
  }

  var T = {
    makeSelectable: function (t, e) {
      void 0 !== t && void 0 !== t.style && (t.onselectstart = e ? function () {
        return !1
      } : function () {
      }, t.style.MozUserSelect = e ? "auto" : "none", t.style.KhtmlUserSelect = e ? "auto" : "none", t.unselectable = e ? "on" : "off")
    }, makeFullscreen: function (t, e, n) {
      var r = n, i = e;
      s.isUndefined(i) && (i = !0), s.isUndefined(r) && (r = !0), t.style.position = "absolute", i && (t.style.left = 0, t.style.right = 0), r && (t.style.top = 0, t.style.bottom = 0)
    }, fakeEvent: function (t, e, n, r) {
      var i = n || {}, o = S[e];
      if (!o) throw new Error("Event type " + e + " not supported.");
      var a = document.createEvent(o);
      switch (o) {
        case"MouseEvents":
          var c = i.x || i.clientX || 0, l = i.y || i.clientY || 0;
          a.initMouseEvent(e, i.bubbles || !1, i.cancelable || !0, window, i.clickCount || 1, 0, 0, c, l, !1, !1, !1, !1, 0, null);
          break;
        case"KeyboardEvents":
          var u = a.initKeyboardEvent || a.initKeyEvent;
          s.defaults(i, {
            cancelable: !0,
            ctrlKey: !1,
            altKey: !1,
            shiftKey: !1,
            metaKey: !1,
            keyCode: void 0,
            charCode: void 0
          }), u(e, i.bubbles || !1, i.cancelable, window, i.ctrlKey, i.altKey, i.shiftKey, i.metaKey, i.keyCode, i.charCode);
          break;
        default:
          a.initEvent(e, i.bubbles || !1, i.cancelable || !0)
      }
      s.defaults(a, r), t.dispatchEvent(a)
    }, bind: function (t, e, n, r) {
      var i = r || !1;
      return t.addEventListener ? t.addEventListener(e, n, i) : t.attachEvent && t.attachEvent("on" + e, n), T
    }, unbind: function (t, e, n, r) {
      var i = r || !1;
      return t.removeEventListener ? t.removeEventListener(e, n, i) : t.detachEvent && t.detachEvent("on" + e, n), T
    }, addClass: function (t, e) {
      if (void 0 === t.className) t.className = e; else if (t.className !== e) {
        var n = t.className.split(/ +/);
        -1 === n.indexOf(e) && (n.push(e), t.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""))
      }
      return T
    }, removeClass: function (t, e) {
      if (e) if (t.className === e) t.removeAttribute("class"); else {
        var n = t.className.split(/ +/), r = n.indexOf(e);
        -1 !== r && (n.splice(r, 1), t.className = n.join(" "))
      } else t.className = void 0;
      return T
    }, hasClass: function (t, e) {
      return new RegExp("(?:^|\\s+)" + e + "(?:\\s+|$)").test(t.className) || !1
    }, getWidth: function (t) {
      var e = getComputedStyle(t);
      return E(e["border-left-width"]) + E(e["border-right-width"]) + E(e["padding-left"]) + E(e["padding-right"]) + E(e.width)
    }, getHeight: function (t) {
      var e = getComputedStyle(t);
      return E(e["border-top-width"]) + E(e["border-bottom-width"]) + E(e["padding-top"]) + E(e["padding-bottom"]) + E(e.height)
    }, getOffset: function (t) {
      var e = t, n = {left: 0, top: 0};
      if (e.offsetParent) do {
        n.left += e.offsetLeft, n.top += e.offsetTop, e = e.offsetParent
      } while (e);
      return n
    }, isActive: function (t) {
      return t === document.activeElement && (t.type || t.href)
    }
  }, O = function (t) {
    function e(t, n) {
      p(this, e);
      var r = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)), i = r;
      return r.__prev = r.getValue(), r.__checkbox = document.createElement("input"), r.__checkbox.setAttribute("type", "checkbox"), T.bind(r.__checkbox, "change", (function () {
        i.setValue(!i.__prev)
      }), !1), r.domElement.appendChild(r.__checkbox), r.updateDisplay(), r
    }

    return g(e, t), m(e, [{
      key: "setValue", value: function (t) {
        var n = v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
        return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), n
      }
    }, {
      key: "updateDisplay", value: function () {
        return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
      }
    }]), e
  }(w), H = function (t) {
    function e(t, n, r) {
      p(this, e);
      var i = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)), o = r, a = i;
      if (i.__select = document.createElement("select"), s.isArray(o)) {
        var c = {};
        s.each(o, (function (t) {
          c[t] = t
        })), o = c
      }
      return s.each(o, (function (t, e) {
        var n = document.createElement("option");
        n.innerHTML = e, n.setAttribute("value", t), a.__select.appendChild(n)
      })), i.updateDisplay(), T.bind(i.__select, "change", (function () {
        var t = this.options[this.selectedIndex].value;
        a.setValue(t)
      })), i.domElement.appendChild(i.__select), i
    }

    return g(e, t), m(e, [{
      key: "setValue", value: function (t) {
        var n = v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
        return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), n
      }
    }, {
      key: "updateDisplay", value: function () {
        return T.isActive(this.__select) ? this : (this.__select.value = this.getValue(), v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this))
      }
    }]), e
  }(w), A = function (t) {
    function e(t, n) {
      p(this, e);
      var r = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)), i = r;

      function o() {
        i.setValue(i.__input.value)
      }

      return r.__input = document.createElement("input"), r.__input.setAttribute("type", "text"), T.bind(r.__input, "keyup", o), T.bind(r.__input, "change", o), T.bind(r.__input, "blur", (function () {
        i.__onFinishChange && i.__onFinishChange.call(i, i.getValue())
      })), T.bind(r.__input, "keydown", (function (t) {
        13 === t.keyCode && this.blur()
      })), r.updateDisplay(), r.domElement.appendChild(r.__input), r
    }

    return g(e, t), m(e, [{
      key: "updateDisplay", value: function () {
        return T.isActive(this.__input) || (this.__input.value = this.getValue()), v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
      }
    }]), e
  }(w);

  function P(t) {
    var e = t.toString();
    return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0
  }

  var R = function (t) {
    function e(t, n, r) {
      p(this, e);
      var i = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)), o = r || {};
      return i.__min = o.min, i.__max = o.max, i.__step = o.step, s.isUndefined(i.__step) ? 0 === i.initialValue ? i.__impliedStep = 1 : i.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(i.initialValue)) / Math.LN10)) / 10 : i.__impliedStep = i.__step, i.__precision = P(i.__impliedStep), i
    }

    return g(e, t), m(e, [{
      key: "setValue", value: function (t) {
        var n = t;
        return void 0 !== this.__min && n < this.__min ? n = this.__min : void 0 !== this.__max && n > this.__max && (n = this.__max), void 0 !== this.__step && n % this.__step != 0 && (n = Math.round(n / this.__step) * this.__step), v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, n)
      }
    }, {
      key: "min", value: function (t) {
        return this.__min = t, this
      }
    }, {
      key: "max", value: function (t) {
        return this.__max = t, this
      }
    }, {
      key: "step", value: function (t) {
        return this.__step = t, this.__impliedStep = t, this.__precision = P(t), this
      }
    }]), e
  }(w);
  var L = function (t) {
    function e(t, n, r) {
      p(this, e);
      var i = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, r));
      i.__truncationSuspended = !1;
      var o = i, a = void 0;

      function c() {
        o.__onFinishChange && o.__onFinishChange.call(o, o.getValue())
      }

      function l(t) {
        var e = a - t.clientY;
        o.setValue(o.getValue() + e * o.__impliedStep), a = t.clientY
      }

      function u() {
        T.unbind(window, "mousemove", l), T.unbind(window, "mouseup", u), c()
      }

      return i.__input = document.createElement("input"), i.__input.setAttribute("type", "text"), T.bind(i.__input, "change", (function () {
        var t = parseFloat(o.__input.value);
        s.isNaN(t) || o.setValue(t)
      })), T.bind(i.__input, "blur", (function () {
        c()
      })), T.bind(i.__input, "mousedown", (function (t) {
        T.bind(window, "mousemove", l), T.bind(window, "mouseup", u), a = t.clientY
      })), T.bind(i.__input, "keydown", (function (t) {
        13 === t.keyCode && (o.__truncationSuspended = !0, this.blur(), o.__truncationSuspended = !1, c())
      })), i.updateDisplay(), i.domElement.appendChild(i.__input), i
    }

    return g(e, t), m(e, [{
      key: "updateDisplay", value: function () {
        var t, n, r;
        return this.__input.value = this.__truncationSuspended ? this.getValue() : (t = this.getValue(), n = this.__precision, r = Math.pow(10, n), Math.round(t * r) / r), v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
      }
    }]), e
  }(R);

  function C(t, e, n, r, i) {
    return r + (t - e) / (n - e) * (i - r)
  }

  var k = function (t) {
    function e(t, n, r, i, o) {
      p(this, e);
      var s = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, {min: r, max: i, step: o})), a = s;

      function c(t) {
        t.preventDefault();
        var e = a.__background.getBoundingClientRect();
        return a.setValue(C(t.clientX, e.left, e.right, a.__min, a.__max)), !1
      }

      function l() {
        T.unbind(window, "mousemove", c), T.unbind(window, "mouseup", l), a.__onFinishChange && a.__onFinishChange.call(a, a.getValue())
      }

      function u(t) {
        var e = t.touches[0].clientX, n = a.__background.getBoundingClientRect();
        a.setValue(C(e, n.left, n.right, a.__min, a.__max))
      }

      function h() {
        T.unbind(window, "touchmove", u), T.unbind(window, "touchend", h), a.__onFinishChange && a.__onFinishChange.call(a, a.getValue())
      }

      return s.__background = document.createElement("div"), s.__foreground = document.createElement("div"), T.bind(s.__background, "mousedown", (function (t) {
        document.activeElement.blur(), T.bind(window, "mousemove", c), T.bind(window, "mouseup", l), c(t)
      })), T.bind(s.__background, "touchstart", (function (t) {
        if (1 !== t.touches.length) return;
        T.bind(window, "touchmove", u), T.bind(window, "touchend", h), u(t)
      })), T.addClass(s.__background, "slider"), T.addClass(s.__foreground, "slider-fg"), s.updateDisplay(), s.__background.appendChild(s.__foreground), s.domElement.appendChild(s.__background), s
    }

    return g(e, t), m(e, [{
      key: "updateDisplay", value: function () {
        var t = (this.getValue() - this.__min) / (this.__max - this.__min);
        return this.__foreground.style.width = 100 * t + "%", v(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
      }
    }]), e
  }(R), D = function (t) {
    function e(t, n, r) {
      p(this, e);
      var i = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)), o = i;
      return i.__button = document.createElement("div"), i.__button.innerHTML = void 0 === r ? "Fire" : r, T.bind(i.__button, "click", (function (t) {
        return t.preventDefault(), o.fire(), !1
      })), T.addClass(i.__button, "button"), i.domElement.appendChild(i.__button), i
    }

    return g(e, t), m(e, [{
      key: "fire", value: function () {
        this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue())
      }
    }]), e
  }(w), N = function (t) {
    function e(t, n) {
      p(this, e);
      var r = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
      r.__color = new _(r.getValue()), r.__temp = new _(0);
      var i = r;
      r.domElement = document.createElement("div"), T.makeSelectable(r.domElement, !1), r.__selector = document.createElement("div"), r.__selector.className = "selector", r.__saturation_field = document.createElement("div"), r.__saturation_field.className = "saturation-field", r.__field_knob = document.createElement("div"), r.__field_knob.className = "field-knob", r.__field_knob_border = "2px solid ", r.__hue_knob = document.createElement("div"), r.__hue_knob.className = "hue-knob", r.__hue_field = document.createElement("div"), r.__hue_field.className = "hue-field", r.__input = document.createElement("input"), r.__input.type = "text", r.__input_textShadow = "0 1px 1px ", T.bind(r.__input, "keydown", (function (t) {
        13 === t.keyCode && d.call(this)
      })), T.bind(r.__input, "blur", d), T.bind(r.__selector, "mousedown", (function () {
        T.addClass(this, "drag").bind(window, "mouseup", (function () {
          T.removeClass(i.__selector, "drag")
        }))
      })), T.bind(r.__selector, "touchstart", (function () {
        T.addClass(this, "drag").bind(window, "touchend", (function () {
          T.removeClass(i.__selector, "drag")
        }))
      }));
      var o, a = document.createElement("div");

      function c(t) {
        v(t), T.bind(window, "mousemove", v), T.bind(window, "touchmove", v), T.bind(window, "mouseup", h), T.bind(window, "touchend", h)
      }

      function l(t) {
        g(t), T.bind(window, "mousemove", g), T.bind(window, "touchmove", g), T.bind(window, "mouseup", f), T.bind(window, "touchend", f)
      }

      function h() {
        T.unbind(window, "mousemove", v), T.unbind(window, "touchmove", v), T.unbind(window, "mouseup", h), T.unbind(window, "touchend", h), m()
      }

      function f() {
        T.unbind(window, "mousemove", g), T.unbind(window, "touchmove", g), T.unbind(window, "mouseup", f), T.unbind(window, "touchend", f), m()
      }

      function d() {
        var t = u(this.value);
        !1 !== t ? (i.__color.__state = t, i.setValue(i.__color.toOriginal())) : this.value = i.__color.toString()
      }

      function m() {
        i.__onFinishChange && i.__onFinishChange.call(i, i.__color.toOriginal())
      }

      function v(t) {
        -1 === t.type.indexOf("touch") && t.preventDefault();
        var e = i.__saturation_field.getBoundingClientRect(), n = t.touches && t.touches[0] || t, r = n.clientX,
          o = n.clientY, s = (r - e.left) / (e.right - e.left), a = 1 - (o - e.top) / (e.bottom - e.top);
        return a > 1 ? a = 1 : a < 0 && (a = 0), s > 1 ? s = 1 : s < 0 && (s = 0), i.__color.v = a, i.__color.s = s, i.setValue(i.__color.toOriginal()), !1
      }

      function g(t) {
        -1 === t.type.indexOf("touch") && t.preventDefault();
        var e = i.__hue_field.getBoundingClientRect(),
          n = 1 - ((t.touches && t.touches[0] || t).clientY - e.top) / (e.bottom - e.top);
        return n > 1 ? n = 1 : n < 0 && (n = 0), i.__color.h = 360 * n, i.setValue(i.__color.toOriginal()), !1
      }

      return s.extend(r.__selector.style, {
        width: "122px",
        height: "102px",
        padding: "3px",
        backgroundColor: "#222",
        boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
      }), s.extend(r.__field_knob.style, {
        position: "absolute",
        width: "12px",
        height: "12px",
        border: r.__field_knob_border + (r.__color.v < .5 ? "#fff" : "#000"),
        boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
        borderRadius: "12px",
        zIndex: 1
      }), s.extend(r.__hue_knob.style, {
        position: "absolute",
        width: "15px",
        height: "2px",
        borderRight: "4px solid #fff",
        zIndex: 1
      }), s.extend(r.__saturation_field.style, {
        width: "100px",
        height: "100px",
        border: "1px solid #555",
        marginRight: "3px",
        display: "inline-block",
        cursor: "pointer"
      }), s.extend(a.style, {
        width: "100%",
        height: "100%",
        background: "none"
      }), j(a, "top", "rgba(0,0,0,0)", "#000"), s.extend(r.__hue_field.style, {
        width: "15px",
        height: "100px",
        border: "1px solid #555",
        cursor: "ns-resize",
        position: "absolute",
        top: "3px",
        right: "3px"
      }), (o = r.__hue_field).style.background = "", o.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", o.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", o.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", o.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", o.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", s.extend(r.__input.style, {
        outline: "none",
        textAlign: "center",
        color: "#fff",
        border: 0,
        fontWeight: "bold",
        textShadow: r.__input_textShadow + "rgba(0,0,0,0.7)"
      }), T.bind(r.__saturation_field, "mousedown", c), T.bind(r.__saturation_field, "touchstart", c), T.bind(r.__field_knob, "mousedown", c), T.bind(r.__field_knob, "touchstart", c), T.bind(r.__hue_field, "mousedown", l), T.bind(r.__hue_field, "touchstart", l), r.__saturation_field.appendChild(a), r.__selector.appendChild(r.__field_knob), r.__selector.appendChild(r.__saturation_field), r.__selector.appendChild(r.__hue_field), r.__hue_field.appendChild(r.__hue_knob), r.domElement.appendChild(r.__input), r.domElement.appendChild(r.__selector), r.updateDisplay(), r
    }

    return g(e, t), m(e, [{
      key: "updateDisplay", value: function () {
        var t = u(this.getValue());
        if (!1 !== t) {
          var e = !1;
          s.each(_.COMPONENTS, (function (n) {
            if (!s.isUndefined(t[n]) && !s.isUndefined(this.__color.__state[n]) && t[n] !== this.__color.__state[n]) return e = !0, {}
          }), this), e && s.extend(this.__color.__state, t)
        }
        s.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
        var n = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0, r = 255 - n;
        s.extend(this.__field_knob.style, {
          marginLeft: 100 * this.__color.s - 7 + "px",
          marginTop: 100 * (1 - this.__color.v) - 7 + "px",
          backgroundColor: this.__temp.toHexString(),
          border: this.__field_knob_border + "rgb(" + n + "," + n + "," + n + ")"
        }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, j(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), s.extend(this.__input.style, {
          backgroundColor: this.__color.toHexString(),
          color: "rgb(" + n + "," + n + "," + n + ")",
          textShadow: this.__input_textShadow + "rgba(" + r + "," + r + "," + r + ",.7)"
        })
      }
    }]), e
  }(w), z = ["-moz-", "-o-", "-webkit-", "-ms-", ""];

  function j(t, e, n, r) {
    t.style.background = "", s.each(z, (function (i) {
      t.style.cssText += "background: " + i + "linear-gradient(" + e + ", " + n + " 0%, " + r + " 100%); "
    }))
  }

  var I = function (t, e) {
      var n = e || document, r = document.createElement("style");
      r.type = "text/css", r.innerHTML = t;
      var i = n.getElementsByTagName("head")[0];
      try {
        i.appendChild(r)
      } catch (o) {
      }
    },
    B = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>',
    F = function (t, e) {
      var n = t[e];
      return s.isArray(arguments[2]) || s.isObject(arguments[2]) ? new H(t, e, arguments[2]) : s.isNumber(n) ? s.isNumber(arguments[2]) && s.isNumber(arguments[3]) ? s.isNumber(arguments[4]) ? new k(t, e, arguments[2], arguments[3], arguments[4]) : new k(t, e, arguments[2], arguments[3]) : s.isNumber(arguments[4]) ? new L(t, e, {
        min: arguments[2],
        max: arguments[3],
        step: arguments[4]
      }) : new L(t, e, {
        min: arguments[2],
        max: arguments[3]
      }) : s.isString(n) ? new A(t, e) : s.isFunction(n) ? new D(t, e, "") : s.isBoolean(n) ? new O(t, e) : null
    };
  var U = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) {
    setTimeout(t, 1e3 / 60)
  }, G = function () {
    function t() {
      p(this, t), this.backgroundElement = document.createElement("div"), s.extend(this.backgroundElement.style, {
        backgroundColor: "rgba(0,0,0,0.8)",
        top: 0,
        left: 0,
        display: "none",
        zIndex: "1000",
        opacity: 0,
        WebkitTransition: "opacity 0.2s linear",
        transition: "opacity 0.2s linear"
      }), T.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), s.extend(this.domElement.style, {
        position: "fixed",
        display: "none",
        zIndex: "1001",
        opacity: 0,
        WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
        transition: "transform 0.2s ease-out, opacity 0.2s linear"
      }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
      var e = this;
      T.bind(this.backgroundElement, "click", (function () {
        e.hide()
      }))
    }

    return m(t, [{
      key: "show", value: function () {
        var t = this;
        this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), s.defer((function () {
          t.backgroundElement.style.opacity = 1, t.domElement.style.opacity = 1, t.domElement.style.webkitTransform = "scale(1)"
        }))
      }
    }, {
      key: "hide", value: function () {
        var t = this, e = function e() {
          t.domElement.style.display = "none", t.backgroundElement.style.display = "none", T.unbind(t.domElement, "webkitTransitionEnd", e), T.unbind(t.domElement, "transitionend", e), T.unbind(t.domElement, "oTransitionEnd", e)
        };
        T.bind(this.domElement, "webkitTransitionEnd", e), T.bind(this.domElement, "transitionend", e), T.bind(this.domElement, "oTransitionEnd", e), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)"
      }
    }, {
      key: "layout", value: function () {
        this.domElement.style.left = window.innerWidth / 2 - T.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - T.getHeight(this.domElement) / 2 + "px"
      }
    }]), t
  }(), V = function (t) {
    if (t && "undefined" != typeof window) {
      var e = document.createElement("style");
      return e.setAttribute("type", "text/css"), e.innerHTML = t, document.head.appendChild(e), t
    }
  }(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");
  I(V);
  var W = "Default", X = function () {
    try {
      return !!window.localStorage
    } catch (t) {
      return !1
    }
  }(), q = void 0, Y = !0, Z = void 0, J = !1, K = [], Q = function t(e) {
    var n = this, r = e || {};
    this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), T.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], r = s.defaults(r, {
      closeOnTop: !1,
      autoPlace: !0,
      width: t.DEFAULT_WIDTH
    }), r = s.defaults(r, {
      resizable: r.autoPlace,
      hideable: r.autoPlace
    }), s.isUndefined(r.load) ? r.load = {preset: W} : r.preset && (r.load.preset = r.preset), s.isUndefined(r.parent) && r.hideable && K.push(this), r.resizable = s.isUndefined(r.parent) && r.resizable, r.autoPlace && s.isUndefined(r.scrollable) && (r.scrollable = !0);
    var i, o = X && "true" === localStorage.getItem(it(this, "isLocal")), a = void 0, c = void 0;
    if (Object.defineProperties(this, {
      parent: {
        get: function () {
          return r.parent
        }
      }, scrollable: {
        get: function () {
          return r.scrollable
        }
      }, autoPlace: {
        get: function () {
          return r.autoPlace
        }
      }, closeOnTop: {
        get: function () {
          return r.closeOnTop
        }
      }, preset: {
        get: function () {
          return n.parent ? n.getRoot().preset : r.load.preset
        }, set: function (t) {
          n.parent ? n.getRoot().preset = t : r.load.preset = t, function (t) {
            for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].value === t.preset && (t.__preset_select.selectedIndex = e)
          }(this), n.revert()
        }
      }, width: {
        get: function () {
          return r.width
        }, set: function (t) {
          r.width = t, lt(n, t)
        }
      }, name: {
        get: function () {
          return r.name
        }, set: function (t) {
          r.name = t, c && (c.innerHTML = r.name)
        }
      }, closed: {
        get: function () {
          return r.closed
        }, set: function (e) {
          r.closed = e, r.closed ? T.addClass(n.__ul, t.CLASS_CLOSED) : T.removeClass(n.__ul, t.CLASS_CLOSED), this.onResize(), n.__closeButton && (n.__closeButton.innerHTML = e ? t.TEXT_OPEN : t.TEXT_CLOSED)
        }
      }, load: {
        get: function () {
          return r.load
        }
      }, useLocalStorage: {
        get: function () {
          return o
        }, set: function (t) {
          X && (o = t, t ? T.bind(window, "unload", a) : T.unbind(window, "unload", a), localStorage.setItem(it(n, "isLocal"), t))
        }
      }
    }), s.isUndefined(r.parent)) {
      if (this.closed = r.closed || !1, T.addClass(this.domElement, t.CLASS_MAIN), T.makeSelectable(this.domElement, !1), X && o) {
        n.useLocalStorage = !0;
        var l = localStorage.getItem(it(this, "gui"));
        l && (r.load = JSON.parse(l))
      }
      this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = t.TEXT_CLOSED, T.addClass(this.__closeButton, t.CLASS_CLOSE_BUTTON), r.closeOnTop ? (T.addClass(this.__closeButton, t.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (T.addClass(this.__closeButton, t.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), T.bind(this.__closeButton, "click", (function () {
        n.closed = !n.closed
      }))
    } else {
      void 0 === r.closed && (r.closed = !0);
      var u = document.createTextNode(r.name);
      T.addClass(u, "controller-name"), c = $(n, u);
      T.addClass(this.__ul, t.CLASS_CLOSED), T.addClass(c, "title"), T.bind(c, "click", (function (t) {
        return t.preventDefault(), n.closed = !n.closed, !1
      })), r.closed || (this.closed = !1)
    }
    r.autoPlace && (s.isUndefined(r.parent) && (Y && (Z = document.createElement("div"), T.addClass(Z, "dg"), T.addClass(Z, t.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(Z), Y = !1), Z.appendChild(this.domElement), T.addClass(this.domElement, t.CLASS_AUTO_PLACE)), this.parent || lt(n, r.width)), this.__resizeHandler = function () {
      n.onResizeDebounced()
    }, T.bind(window, "resize", this.__resizeHandler), T.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), T.bind(this.__ul, "transitionend", this.__resizeHandler), T.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), r.resizable && ct(this), a = function () {
      X && "true" === localStorage.getItem(it(n, "isLocal")) && localStorage.setItem(it(n, "gui"), JSON.stringify(n.getSaveObject()))
    }, this.saveToLocalStorageIfPossible = a, r.parent || ((i = n.getRoot()).width += 1, s.defer((function () {
      i.width -= 1
    })))
  };

  function $(t, e, n) {
    var r = document.createElement("li");
    return e && r.appendChild(e), n ? t.__ul.insertBefore(r, n) : t.__ul.appendChild(r), t.onResize(), r
  }

  function tt(t) {
    T.unbind(window, "resize", t.__resizeHandler), t.saveToLocalStorageIfPossible && T.unbind(window, "unload", t.saveToLocalStorageIfPossible)
  }

  function et(t, e) {
    var n = t.__preset_select[t.__preset_select.selectedIndex];
    n.innerHTML = e ? n.value + "*" : n.value
  }

  function nt(t, e) {
    var n = t.getRoot(), r = n.__rememberedObjects.indexOf(e.object);
    if (-1 !== r) {
      var i = n.__rememberedObjectIndecesToControllers[r];
      if (void 0 === i && (i = {}, n.__rememberedObjectIndecesToControllers[r] = i), i[e.property] = e, n.load && n.load.remembered) {
        var o = n.load.remembered, s = void 0;
        if (o[t.preset]) s = o[t.preset]; else {
          if (!o.Default) return;
          s = o.Default
        }
        if (s[r] && void 0 !== s[r][e.property]) {
          var a = s[r][e.property];
          e.initialValue = a, e.setValue(a)
        }
      }
    }
  }

  function rt(t, e, n, r) {
    if (void 0 === e[n]) throw new Error('Object "' + e + '" has no property "' + n + '"');
    var i = void 0;
    if (r.color) i = new N(e, n); else {
      var o = [e, n].concat(r.factoryArgs);
      i = F.apply(t, o)
    }
    r.before instanceof w && (r.before = r.before.__li), nt(t, i), T.addClass(i.domElement, "c");
    var a = document.createElement("span");
    T.addClass(a, "property-name"), a.innerHTML = i.property;
    var c = document.createElement("div");
    c.appendChild(a), c.appendChild(i.domElement);
    var l = $(t, c, r.before);
    return T.addClass(l, Q.CLASS_CONTROLLER_ROW), i instanceof N ? T.addClass(l, "color") : T.addClass(l, d(i.getValue())), function (t, e, n) {
      if (n.__li = e, n.__gui = t, s.extend(n, {
        options: function (e) {
          if (arguments.length > 1) {
            var r = n.__li.nextElementSibling;
            return n.remove(), rt(t, n.object, n.property, {before: r, factoryArgs: [s.toArray(arguments)]})
          }
          if (s.isArray(e) || s.isObject(e)) {
            var i = n.__li.nextElementSibling;
            return n.remove(), rt(t, n.object, n.property, {before: i, factoryArgs: [e]})
          }
        }, name: function (t) {
          return n.__li.firstElementChild.firstElementChild.innerHTML = t, n
        }, listen: function () {
          return n.__gui.listen(n), n
        }, remove: function () {
          return n.__gui.remove(n), n
        }
      }), n instanceof k) {
        var r = new L(n.object, n.property, {min: n.__min, max: n.__max, step: n.__step});
        s.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], (function (t) {
          var e = n[t], i = r[t];
          n[t] = r[t] = function () {
            var t = Array.prototype.slice.call(arguments);
            return i.apply(r, t), e.apply(n, t)
          }
        })), T.addClass(e, "has-slider"), n.domElement.insertBefore(r.domElement, n.domElement.firstElementChild)
      } else if (n instanceof L) {
        var i = function (e) {
          if (s.isNumber(n.__min) && s.isNumber(n.__max)) {
            var r = n.__li.firstElementChild.firstElementChild.innerHTML, i = n.__gui.__listening.indexOf(n) > -1;
            n.remove();
            var o = rt(t, n.object, n.property, {
              before: n.__li.nextElementSibling,
              factoryArgs: [n.__min, n.__max, n.__step]
            });
            return o.name(r), i && o.listen(), o
          }
          return e
        };
        n.min = s.compose(i, n.min), n.max = s.compose(i, n.max)
      } else n instanceof O ? (T.bind(e, "click", (function () {
        T.fakeEvent(n.__checkbox, "click")
      })), T.bind(n.__checkbox, "click", (function (t) {
        t.stopPropagation()
      }))) : n instanceof D ? (T.bind(e, "click", (function () {
        T.fakeEvent(n.__button, "click")
      })), T.bind(e, "mouseover", (function () {
        T.addClass(n.__button, "hover")
      })), T.bind(e, "mouseout", (function () {
        T.removeClass(n.__button, "hover")
      }))) : n instanceof N && (T.addClass(e, "color"), n.updateDisplay = s.compose((function (t) {
        return e.style.borderLeftColor = n.__color.toString(), t
      }), n.updateDisplay), n.updateDisplay());
      n.setValue = s.compose((function (e) {
        return t.getRoot().__preset_select && n.isModified() && et(t.getRoot(), !0), e
      }), n.setValue)
    }(t, l, i), t.__controllers.push(i), i
  }

  function it(t, e) {
    return document.location.href + "." + e
  }

  function ot(t, e, n) {
    var r = document.createElement("option");
    r.innerHTML = e, r.value = e, t.__preset_select.appendChild(r), n && (t.__preset_select.selectedIndex = t.__preset_select.length - 1)
  }

  function st(t, e) {
    e.style.display = t.useLocalStorage ? "block" : "none"
  }

  function at(t) {
    var e = t.__save_row = document.createElement("li");
    T.addClass(t.domElement, "has-save"), t.__ul.insertBefore(e, t.__ul.firstChild), T.addClass(e, "save-row");
    var n = document.createElement("span");
    n.innerHTML = "&nbsp;", T.addClass(n, "button gears");
    var r = document.createElement("span");
    r.innerHTML = "Save", T.addClass(r, "button"), T.addClass(r, "save");
    var i = document.createElement("span");
    i.innerHTML = "New", T.addClass(i, "button"), T.addClass(i, "save-as");
    var o = document.createElement("span");
    o.innerHTML = "Revert", T.addClass(o, "button"), T.addClass(o, "revert");
    var a = t.__preset_select = document.createElement("select");
    if (t.load && t.load.remembered ? s.each(t.load.remembered, (function (e, n) {
      ot(t, n, n === t.preset)
    })) : ot(t, W, !1), T.bind(a, "change", (function () {
      for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].innerHTML = t.__preset_select[e].value;
      t.preset = this.value
    })), e.appendChild(a), e.appendChild(n), e.appendChild(r), e.appendChild(i), e.appendChild(o), X) {
      var c = document.getElementById("dg-local-explain"), l = document.getElementById("dg-local-storage");
      document.getElementById("dg-save-locally").style.display = "block", "true" === localStorage.getItem(it(0, "isLocal")) && l.setAttribute("checked", "checked"), st(t, c), T.bind(l, "change", (function () {
        t.useLocalStorage = !t.useLocalStorage, st(t, c)
      }))
    }
    var u = document.getElementById("dg-new-constructor");
    T.bind(u, "keydown", (function (t) {
      !t.metaKey || 67 !== t.which && 67 !== t.keyCode || q.hide()
    })), T.bind(n, "click", (function () {
      u.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2), q.show(), u.focus(), u.select()
    })), T.bind(r, "click", (function () {
      t.save()
    })), T.bind(i, "click", (function () {
      var e = prompt("Enter a new preset name.");
      e && t.saveAs(e)
    })), T.bind(o, "click", (function () {
      t.revert()
    }))
  }

  function ct(t) {
    var e = void 0;

    function n(n) {
      return n.preventDefault(), t.width += e - n.clientX, t.onResize(), e = n.clientX, !1
    }

    function r() {
      T.removeClass(t.__closeButton, Q.CLASS_DRAG), T.unbind(window, "mousemove", n), T.unbind(window, "mouseup", r)
    }

    function i(i) {
      return i.preventDefault(), e = i.clientX, T.addClass(t.__closeButton, Q.CLASS_DRAG), T.bind(window, "mousemove", n), T.bind(window, "mouseup", r), !1
    }

    t.__resize_handle = document.createElement("div"), s.extend(t.__resize_handle.style, {
      width: "6px",
      marginLeft: "-3px",
      height: "200px",
      cursor: "ew-resize",
      position: "absolute"
    }), T.bind(t.__resize_handle, "mousedown", i), T.bind(t.__closeButton, "mousedown", i), t.domElement.insertBefore(t.__resize_handle, t.domElement.firstElementChild)
  }

  function lt(t, e) {
    t.domElement.style.width = e + "px", t.__save_row && t.autoPlace && (t.__save_row.style.width = e + "px"), t.__closeButton && (t.__closeButton.style.width = e + "px")
  }

  function ut(t, e) {
    var n = {};
    return s.each(t.__rememberedObjects, (function (r, i) {
      var o = {}, a = t.__rememberedObjectIndecesToControllers[i];
      s.each(a, (function (t, n) {
        o[n] = e ? t.initialValue : t.getValue()
      })), n[i] = o
    })), n
  }

  function ht(t) {
    0 !== t.length && U.call(window, (function () {
      ht(t)
    })), s.each(t, (function (t) {
      t.updateDisplay()
    }))
  }

  Q.toggleHide = function () {
    J = !J, s.each(K, (function (t) {
      t.domElement.style.display = J ? "none" : ""
    }))
  }, Q.CLASS_AUTO_PLACE = "a", Q.CLASS_AUTO_PLACE_CONTAINER = "ac", Q.CLASS_MAIN = "main", Q.CLASS_CONTROLLER_ROW = "cr", Q.CLASS_TOO_TALL = "taller-than-window", Q.CLASS_CLOSED = "closed", Q.CLASS_CLOSE_BUTTON = "close-button", Q.CLASS_CLOSE_TOP = "close-top", Q.CLASS_CLOSE_BOTTOM = "close-bottom", Q.CLASS_DRAG = "drag", Q.DEFAULT_WIDTH = 245, Q.TEXT_CLOSED = "Close Controls", Q.TEXT_OPEN = "Open Controls", Q._keydownHandler = function (t) {
    "text" === document.activeElement.type || 72 !== t.which && 72 !== t.keyCode || Q.toggleHide()
  }, T.bind(window, "keydown", Q._keydownHandler, !1), s.extend(Q.prototype, {
    add: function (t, e) {
      return rt(this, t, e, {factoryArgs: Array.prototype.slice.call(arguments, 2)})
    }, addColor: function (t, e) {
      return rt(this, t, e, {color: !0})
    }, remove: function (t) {
      this.__ul.removeChild(t.__li), this.__controllers.splice(this.__controllers.indexOf(t), 1);
      var e = this;
      s.defer((function () {
        e.onResize()
      }))
    }, destroy: function () {
      if (this.parent) throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
      this.autoPlace && Z.removeChild(this.domElement);
      var t = this;
      s.each(this.__folders, (function (e) {
        t.removeFolder(e)
      })), T.unbind(window, "keydown", Q._keydownHandler, !1), tt(this)
    }, addFolder: function (t) {
      if (void 0 !== this.__folders[t]) throw new Error('You already have a folder in this GUI by the name "' + t + '"');
      var e = {name: t, parent: this};
      e.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[t] && (e.closed = this.load.folders[t].closed, e.load = this.load.folders[t]);
      var n = new Q(e);
      this.__folders[t] = n;
      var r = $(this, n.domElement);
      return T.addClass(r, "folder"), n
    }, removeFolder: function (t) {
      this.__ul.removeChild(t.domElement.parentElement), delete this.__folders[t.name], this.load && this.load.folders && this.load.folders[t.name] && delete this.load.folders[t.name], tt(t);
      var e = this;
      s.each(t.__folders, (function (e) {
        t.removeFolder(e)
      })), s.defer((function () {
        e.onResize()
      }))
    }, open: function () {
      this.closed = !1
    }, close: function () {
      this.closed = !0
    }, hide: function () {
      this.domElement.style.display = "none"
    }, show: function () {
      this.domElement.style.display = ""
    }, onResize: function () {
      var t = this.getRoot();
      if (t.scrollable) {
        var e = T.getOffset(t.__ul).top, n = 0;
        s.each(t.__ul.childNodes, (function (e) {
          t.autoPlace && e === t.__save_row || (n += T.getHeight(e))
        })), window.innerHeight - e - 20 < n ? (T.addClass(t.domElement, Q.CLASS_TOO_TALL), t.__ul.style.height = window.innerHeight - e - 20 + "px") : (T.removeClass(t.domElement, Q.CLASS_TOO_TALL), t.__ul.style.height = "auto")
      }
      t.__resize_handle && s.defer((function () {
        t.__resize_handle.style.height = t.__ul.offsetHeight + "px"
      })), t.__closeButton && (t.__closeButton.style.width = t.width + "px")
    }, onResizeDebounced: s.debounce((function () {
      this.onResize()
    }), 50), remember: function () {
      if (s.isUndefined(q) && ((q = new G).domElement.innerHTML = B), this.parent) throw new Error("You can only call remember on a top level GUI.");
      var t = this;
      s.each(Array.prototype.slice.call(arguments), (function (e) {
        0 === t.__rememberedObjects.length && at(t), -1 === t.__rememberedObjects.indexOf(e) && t.__rememberedObjects.push(e)
      })), this.autoPlace && lt(this, this.width)
    }, getRoot: function () {
      for (var t = this; t.parent;) t = t.parent;
      return t
    }, getSaveObject: function () {
      var t = this.load;
      return t.closed = this.closed, this.__rememberedObjects.length > 0 && (t.preset = this.preset, t.remembered || (t.remembered = {}), t.remembered[this.preset] = ut(this)), t.folders = {}, s.each(this.__folders, (function (e, n) {
        t.folders[n] = e.getSaveObject()
      })), t
    }, save: function () {
      this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = ut(this), et(this, !1), this.saveToLocalStorageIfPossible()
    }, saveAs: function (t) {
      this.load.remembered || (this.load.remembered = {}, this.load.remembered.Default = ut(this, !0)), this.load.remembered[t] = ut(this), this.preset = t, ot(this, t, !0), this.saveToLocalStorageIfPossible()
    }, revert: function (t) {
      s.each(this.__controllers, (function (e) {
        this.getRoot().load.remembered ? nt(t || this.getRoot(), e) : e.setValue(e.initialValue), e.__onFinishChange && e.__onFinishChange.call(e, e.getValue())
      }), this), s.each(this.__folders, (function (t) {
        t.revert(t)
      })), t || et(this.getRoot(), !1)
    }, listen: function (t) {
      var e = 0 === this.__listening.length;
      this.__listening.push(t), e && ht(this.__listening)
    }, updateDisplay: function () {
      s.each(this.__controllers, (function (t) {
        t.updateDisplay()
      })), s.each(this.__folders, (function (t) {
        t.updateDisplay()
      }))
    }
  });
  var ft = {
    color: {Color: _, math: f, interpret: u},
    controllers: {
      Controller: w,
      BooleanController: O,
      OptionController: H,
      StringController: A,
      NumberController: R,
      NumberControllerBox: L,
      NumberControllerSlider: k,
      FunctionController: D,
      ColorController: N
    },
    dom: {dom: T},
    gui: {GUI: Q},
    GUI: Q
  }, dt = n(91), pt = n.n(dt), mt = n(0), vt = 1e-4, gt = function () {
    if (mt.a.viewport.mobiledevice) return !1;
    if (!mt.a.html.classList.contains("has-gui")) return !1;
    var t = new ft.GUI;
    return t.close(), mt.a.html.classList.add("show-dat-gui"), window.addEventListener("load", (function () {
      (new pt.a).on("queue", (function () {
        mt.a.html.classList.add("show-dat-gui")
      }), {keys: [71, 85, 73]})
    })), t
  }()
}, function (t, e, n) {
  "use strict";
  var r = n(62), i = n(14), o = n(15), s = n.n(o), a = n(6), c = n.n(a), l = n(93), u = n.n(l), h = n(1), f = n(44),
    d = n(2), p = n(0), m = n(13);
  var v = n(53);
  var g = n(30);

  function y(t) {
    return y = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, y(t)
  }

  function _(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function b(t, e, n) {
    return b = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = M(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, b(t, e, n || t)
  }

  function x(t, e) {
    return x = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, x(t, e)
  }

  function w(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = M(t);
      if (e) {
        var i = M(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return S(this, n)
    }
  }

  function S(t, e) {
    if (e && ("object" === y(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function M(t) {
    return M = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, M(t)
  }

  var E = "2d", T = "3d", O = "2d,3d", H = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && x(t, e)
    }(o, t);
    var e, n, r, i = w(o);

    function o(t) {
      var e;
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, o), (e = i.call(this, t))._noRender = !1, e
    }

    return e = o, n = [{
      key: "defaultProp", get: function () {
        return c()(b(M(o.prototype), "defaultProp", this), {
          outerSelector: "#three-js",
          autoplay: !1,
          cameras: "2d",
          cameraFar: 800
        })
      }
    }, {
      key: "prop", get: function () {
        return this._prop
      }
    }, {
      key: "noRender", set: function (t) {
        this._noRender = t
      }
    }, {
      key: "canvas", get: function () {
        return this._canvas
      }
    }, {
      key: "outer", get: function () {
        return this._outer
      }
    }, {
      key: "renderer", get: function () {
        return this._renderer.renderer
      }
    }, {
      key: "scene2d", get: function () {
        return this._scene2d
      }
    }, {
      key: "scene3d", get: function () {
        return this._scene3d
      }
    }, {
      key: "camera2d", get: function () {
        return this._camera2d.camera
      }
    }, {
      key: "camera3d", get: function () {
        return this._camera3d.camera
      }
    }, {
      key: "width", get: function () {
        return this._width
      }
    }, {
      key: "height", get: function () {
        return this._height
      }
    }, {
      key: "_extra", value: function () {
        var t = this;
        b(M(o.prototype), "_extra", this).call(this), this._width = 1, this._height = 1, this._outer = Object(h.g)(this._prop.outerSelector), this._getCanvas();
        var e = this._prop.cameras;
        e !== E && e !== O || (this._scene2d = Object(f.a)()), e !== T && e !== O || (this._scene3d = Object(f.a)()), this._renderer = function (t, e) {
          var n = p.a.viewport,
            r = new d.rb({canvas: t, antialias: !1, alpha: !0, powerPreference: "high-performance", depth: !1});
          r.physicallyCorrectLights = !0;
          var i = p.a.viewport.mobiledevice ? Object(m.b)(n.dprMobile, [0, 1.5]) : n.dpr;

          function o() {
            var n = e.clientWidth, i = e.clientHeight;
            t.width = n, t.height = i, r.setSize(n, i)
          }

          return r.setPixelRatio(i), r.setSize(e.clientWidth, e.clientHeight), o(), {
            renderer: r,
            resize: o.bind(this),
            destroy: function () {
              r.dispose()
            }.bind(this)
          }
        }(this._canvas, this.outer), e !== E && e !== O || (this._camera2d = function () {
          var t, e, n = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          o();
          var r = new d.M(t / -2, t / 2, e / 2, e / -2, -20, 1e4);

          function i() {
            o(), r.left = t / -2, r.right = t / 2, r.top = e / 2, r.bottom = e / -2, r.updateProjectionMatrix()
          }

          function o() {
            t = window.innerWidth, e = window.innerHeight, n && (t = n.clientWidth, e = n.clientHeight)
          }

          function s() {
          }

          return i(), {camera: r, resize: i.bind(this), destroy: s.bind(this)}
        }()), e !== T && e !== O || (this._camera3d = Object(v.a)(this.outer, this._prop.cameraFar)), this._frame = new u.a({fps: 90}), this._frame.on("", (function () {
          t.render()
        })), this.render()
      }
    }, {
      key: "on", value: function (t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return b(M(o.prototype), "on", this).call(this, t, e, n)
      }
    }, {
      key: "_getCanvas", value: function () {
        var t = Object(h.g)("canvas", this.outer);
        null == t && (t = document.createElement("canvas"), this.outer.appendChild(t)), t instanceof HTMLCanvasElement && (this._canvas = t), t.addEventListener("webglcontextlost", (function () {
          throw new Error("Three.JS Webgl Context Lost")
        }), !1)
      }
    }, {
      key: "_setEvents", value: function () {
        this._viewportEvent = Object(g.a)(this.resize.bind(this), "Three.JS", 150), this.resize(), this.on("changeProp", this.resize.bind(this))
      }
    }, {
      key: "resize", value: function () {
        this._width = this._outer.clientWidth, this._height = this._outer.clientHeight, this._renderer.resize();
        var t = this._prop.cameras;
        t !== E && t !== O || this._camera2d.resize(), t !== T && t !== O || this._camera3d.resize(), this.lbt("resize"), this._prop.autoplay && this.play()
      }
    }, {
      key: "play", value: function () {
        this._frame.play()
      }
    }, {
      key: "pause", value: function () {
        this._frame.pause()
      }
    }, {
      key: "render", value: function () {
        if (this.lbt("frame"), this.lbt("prerender"), !this._noRender) {
          this.renderer.autoClear = !1, this.renderer.clear(), this.renderer.clearDepth();
          var t = this._prop.cameras;
          t === E ? this.renderer.render(this.scene2d, this.camera2d) : t === T ? this.renderer.render(this.scene3d, this.camera3d) : t === O && (this.renderer.render(this.scene3d, this.camera3d), this.renderer.autoClear = !1, this.renderer.render(this.scene2d, this.camera2d))
        }
        this.lbt("afterrender")
      }
    }, {
      key: "destroy", value: function () {
        this._renderer.destroy(), this._camera2d && this._camera2d.destroy(), this._camera3d && this._camera3d.destroy(), this._viewportEvent.destroy()
      }
    }], n && _(e.prototype, n), r && _(e, r), o
  }(s.a), A = new H({outerSelector: "#three-js", cameras: "3d", cameraFar: 2e3});
  e.a = A;
  r.a.on("hide", (function () {
    A.play()
  })), i.b && window.addEventListener("scroll", (function () {
    A.render()
  }), {passive: !1})
}, function (t, e, n) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var r = n(105), i = n(39);
  var o = function (t, e) {
    return r(t, e, (function (t, e) {
      if (i(t)) return e
    }))
  };
  e.default = o
}, function (t, e, n) {
  "use strict";
  var r = n(90), i = n.n(r), o = n(11), s = n(24), a = ".no-element", c = new i.a({
    selectors: {outer: ".app", links: ".v-al"},
    ajax: {method: "post"},
    timeouts: {load: o.d.load, update: o.d.update, done: o.d.done},
    pageChange: {default: o.d.default},
    changeSame: !0,
    menuLinks: {selectorNew: a, selectorOld: a},
    cache: !0,
    on: !1
  });
  e.a = c, c.on("prepare", (function () {
    Object(s.a)(!0)
  }))
}, function (t, e) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var n = function (t, e) {
    return (t - e[0]) / (e[1] - e[0])
  };
  e.default = n
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return l
  })), n.d(e, "c", (function () {
    return u
  })), n.d(e, "b", (function () {
    return h
  }));
  var r = n(1), i = n(0), o = n(14), s = n(28), a = n(18), c = i.a.viewport;

  function l() {
    var t = .1;
    return "macos" === i.a.os && (c.mobiledevice || (t = .2)), "edge" === i.a.browser && (t = .2), t
  }

  function u() {
    if (o.b) return i.a.html;
    if (o.a) {
      var t = s.a.get();
      if (Object(a.a)(t)) return t
    }
    return Object(r.g)("#custom-scroll")
  }

  function h() {
    return "#custom-scroll .custom-scroll__outer"
  }
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = o(n(6));

  function o(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function s(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function a(t, e, n) {
    return a = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = h(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, a(t, e, n || t)
  }

  function c(t, e) {
    return c = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, c(t, e)
  }

  function l(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = h(t);
      if (e) {
        var i = h(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return u(this, n)
    }
  }

  function u(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function h(t) {
    return h = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, h(t)
  }

  var f = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && c(t, e)
    }(u, t);
    var e, n, r, o = l(u);

    function u(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, u), o.call(this, t)
    }

    return e = u, n = [{
      key: "_extra", value: function () {
        a(h(u.prototype), "_extra", this).call(this), this._playing = !1, this._paused = !1, this._stopped = !1, this._reversed = !1, this._frame = null
      }
    }, {
      key: "_tickers", value: function () {
        a(h(u.prototype), "_tickers", this).call(this), this._ticker = 0, this._lastFrame = 0
      }
    }, {
      key: "defaultSettings", get: function () {
        return (0, i.default)(a(h(u.prototype), "defaultSettings", this), {duration: 750, autoDuration: !1})
      }
    }, {
      key: "playing", get: function () {
        return this._playing
      }
    }, {
      key: "reversed", get: function () {
        return this._reversed
      }
    }, {
      key: "data", get: function () {
        return (0, i.default)(a(h(u.prototype), "data", this), {duration: this._settings.duration})
      }
    }, {
      key: "_start", value: function () {
        this._lastFrame = Date.now(), this._playing = !0, this._paused = !1, this._stopped = !1, this._frame = window.requestAnimationFrame(this._animate.bind(this))
      }
    }, {
      key: "_stop", value: function () {
        this._playing = !1, null != this._frame && (cancelAnimationFrame(this._frame), this._frame = null)
      }
    }, {
      key: "play", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._settings;
        if (this._playing) return this;
        if (this._paused) return this.resume();
        this._reversed || this._tickers(), this._settings = (0, i.default)(this.defaultSettings, t);
        var e = this._settings, n = e.scope, r = Math.abs(n[0] - n[1]);
        return e.autoDuration && (e.duration *= r), this._start(), this.lbt("play", this.data), this
      }
    }, {
      key: "pause", value: function () {
        return this._playing ? (this._paused = !0, this._stop(), this.lbt("pause", this.data), this) : this
      }
    }, {
      key: "resume", value: function () {
        return this._playing ? this : this._paused ? (1 === this._absolute || (this._start(), this.lbt("resume", this.data)), this) : this
      }
    }, {
      key: "stop", value: function () {
        return this._stopReset(), this._reversed = !1, this._tickers(), this._stopped = !0, this.lbt("stop", this.data), this
      }
    }, {
      key: "_stopReset", value: function () {
        this._paused = !1, this._stopped = !1, this._stop()
      }
    }, {
      key: "reverse", value: function () {
        return this._reversed ? this._reversed = !1 : this._reversed = !0, this.lbt("reverse", this.data), this
      }
    }, {
      key: "_animate", value: function () {
        var t = Date.now(), e = t - this._lastFrame;
        this._reversed ? this._ticker -= e : this._ticker += e;
        var n = this._ticker / this._settings.duration;
        n > 1 && (n = 1), n < 0 && (n = 0), this.calc(n);
        var r = !1, i = !1;
        this._reversed ? 0 === this._progress && (r = !0, i = !0) : 1 === this._progress && (r = !0, i = !0), r && this._stopReset(), i && this.lbt("end"), r ? this._prop.destroyOnEnd && this.destroy() : (this._lastFrame = t, this._frame = window.requestAnimationFrame(this._animate.bind(this)))
      }
    }, {
      key: "destroy", value: function () {
        a(h(u.prototype), "destroy", this).call(this), null != this._frame && (cancelAnimationFrame(this._frame), this._frame = null)
      }
    }], n && s(e.prototype, n), r && s(e, r), u
  }(o(n(36)).default);
  e.default = f
}, function (t, e, n) {
  "use strict";
  n.d(e, "c", (function () {
    return r
  })), n.d(e, "e", (function () {
    return i
  })), n.d(e, "g", (function () {
    return o
  })), n.d(e, "b", (function () {
    return s
  })), n.d(e, "f", (function () {
    return a
  })), n.d(e, "a", (function () {
    return c
  })), n.d(e, "d", (function () {
    return l
  })), n.d(e, "h", (function () {
    return u
  }));
  var r = !1, i = 100, o = !0, s = r ? 100 : 550, a = 50, c = r ? 10 : 250,
    l = {default: "default-page", load: s, update: 10, done: a}, u = !0
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return p
  }));
  var r = n(3), i = n(82), o = n(48);

  function s(t) {
    return s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, s(t)
  }

  function a(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function c(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function l(t, e, n) {
    return l = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = d(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, l(t, e, n || t)
  }

  function u(t, e) {
    return u = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, u(t, e)
  }

  function h(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = d(t);
      if (e) {
        var i = d(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return f(this, n)
    }
  }

  function f(t, e) {
    if (e && ("object" === s(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function d(t) {
    return d = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, d(t)
  }

  var p = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && u(t, e)
    }(f, t);
    var e, n, r, s = h(f);

    function f() {
      var t;
      return a(this, f), (t = s.apply(this, arguments))._onPageCreated = !1, t._disconnected = !1, t
    }

    return e = f, (n = [{
      key: "createRenderRoot", value: function () {
        return this
      }
    }, {
      key: "connectedCallback", value: function () {
        var t = this;
        l(d(f.prototype), "connectedCallback", this).call(this), this._disconnected = !1, this._onPageCreated = Object(i.a)((function () {
          t._connectedCallback()
        })), this._updateThingsCallback = o.a.add((function () {
          t._updateThings()
        }))
      }
    }, {
      key: "disconnectedCallback", value: function () {
        l(d(f.prototype), "disconnectedCallback", this).call(this), this._disconnected = !0, this._onPageCreated && (this._onPageCreated.destroy(), this._onPageCreated = !1), this._updateThingsCallback && (this._updateThingsCallback.destroy(), this._updateThingsCallback = !1), this._disconnectedCallback()
      }
    }, {
      key: "_connectedCallback", value: function () {
      }
    }, {
      key: "_disconnectedCallback", value: function () {
      }
    }, {
      key: "_updateThings", value: function () {
      }
    }]) && c(e.prototype, n), r && c(e, r), f
  }(r.a)
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return i
  })), n.d(e, "b", (function () {
    return o
  }));
  var r = n(46);

  function i(t, e, n) {
    var i = r(t, e, n);
    return Math.abs(e - i) <= .001 ? e : i
  }

  function o(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [0, 1];
    return t < e[0] ? e[0] : t > e[1] ? e[1] : t
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return i
  })), n.d(e, "b", (function () {
    return o
  }));
  var r = n(0), i = (n(9), !0), o = !i;
  !i && o && document.documentElement.classList.add("use-native-scroll"), r.a.viewport.on("", (function () {
    o || (document.documentElement.scrollTop = 0, document.body.scrollTop = 0)
  }), {timeout: 650, name: "iOS scroll resize bug"}), o && (window.history.scrollRestoration = "manual")
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = l(n(23)), o = l(n(111)), s = l(n(112)), a = l(n(6)), c = l(n(113));

  function l(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function u(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function h(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function f(t, e) {
    return f = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, f(t, e)
  }

  function d(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = m(t);
      if (e) {
        var i = m(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return p(this, n)
    }
  }

  function p(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function m(t) {
    return m = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, m(t)
  }

  var v = n(39), g = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && f(t, e)
    }(l, t);
    var e, n, r, i = d(l);

    function l() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      return u(this, l), i.call(this, t, e)
    }

    return e = l, n = [{
      key: "_extra", value: function () {
        var t = this;
        this._destroyed = !1, this._allEvents = [], this._listeners = [], this._plugins = [], this._responsiveProp = new o.default(this._prop, this._changeProp.bind(this), this._changeProp.bind(this)), this._prop = this._responsiveProp._prop, this.on("destroy", (function () {
          t._responsiveProp.destroy()
        }));
        var e = this._prop.parent;
        e instanceof l && e.on("destroy", this.destroy.bind(this))
      }
    }, {
      key: "changeProp", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        this._responsiveProp.changeProp(t), this.lbt("changeProp")
      }
    }, {
      key: "_changeProp", value: function () {
      }
    }, {
      key: "addEvent", value: function (t, e) {
        var n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], r = [], i = [];
        if (v(t)) for (var o = 0; o < t.length; o++) {
          var s = this._addEventHelper(t[o], e, n);
          r.push([s, t[o]])
        } else {
          var a = this._addEventHelper(t, e, n);
          r.push([a, t])
        }
        for (var c = 0; c < r.length; c++) r[c][0] && (this._allEvents.push({
          id: r[c][0],
          name: r[c][1]
        }), i.push(r[c][0]));
        return v(t) ? i : i[0]
      }
    }, {
      key: "_addEventHelper", value: function (t, e, n) {
        return this._v[t].add(e, n)
      }
    }, {
      key: "_removeEvent", value: function (t) {
        for (var e = [], n = !1, r = 0; r < this._allEvents.length; r++) {
          var i = this._allEvents[r];
          t === i.id ? n = this._v[i.name].remove(i.id) : e.push(i)
        }
        return this._allEvents = e, n
      }
    }, {
      key: "_removeEvents", value: function () {
        for (; this._allEvents.length > 0;) {
          var t = this._allEvents[0].id;
          this._removeEvent(t)
        }
        return !0
      }
    }, {
      key: "listeners", get: function () {
        return this._listeners()
      }
    }, {
      key: "addEventListener", value: function (t) {
        var e = (0, s.default)(t);
        return this._listeners.push(e), e
      }
    }, {
      key: "listener", value: function (t, e, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
        return this.addEventListener((0, a.default)({el: t, target: e, do: n}, r))
      }
    }, {
      key: "removeEventListener", value: function (t) {
        for (var e = 0; e < this._listeners.length; e++) {
          var n = this._listeners[e];
          if (n.id === t.id) return (0, c.default)(n), this._listeners.splice(e, 1), !0
        }
        return !1
      }
    }, {
      key: "removeEventListeners", value: function () {
        for (; this._listeners.length > 0;) {
          var t = this._listeners[0];
          this.removeEventListener({el: t.el, id: t.id})
        }
      }
    }, {
      key: "addPlugin", value: function (t) {
        this._plugins.push(t), t.init(this)
      }
    }, {
      key: "removePlugins", value: function () {
        for (var t = 0; t < this._plugins.length; t++) this._plugins[t].destroy();
        this._plugins = []
      }
    }, {
      key: "_destroy", value: function () {
        this.lbt("destroy"), this.removeAll(), this._removeEvents(), this.removeEventListeners(), this.removePlugins(), this._destroyed = !0
      }
    }, {
      key: "destroy", value: function () {
        this._destroy()
      }
    }], n && h(e.prototype, n), r && h(e, r), l
  }(i.default);
  e.default = g
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return c
  }));
  var r = n(1), i = n(0), o = n(28), s = n(18), a = n(14);

  function c(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = i.a.vevetPage, c = [],
      l = Object(r.g)("#custom-scroll");
    Object(r.c)(l) && c.push(Object(r.a)(l, "scroll", (function () {
      a.a || a.b || t(l.scrollTop)
    })));
    var u = o.a.get(), h = !1;
    if (Object(s.a)(u)) {
      var f = u;
      h = f.on("update", (function () {
        a.a && t(f.scrollTop)
      }))
    }

    function d() {
      c.forEach((function (t) {
        t.remove()
      })), h && u && u.remove(h)
    }

    return c.push(Object(r.a)(window, "scroll", (function () {
      !a.a && a.b && t(window.pageYOffset)
    }), {passive: !1})), n && !e && n.on("destroy", (function () {
      d()
    }), {once: !0}), {destroy: d.bind(this)}
  }
}, function (t, e) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var n = function (t, e) {
    0 === e ? t() : setTimeout(t.bind(this), e)
  };
  e.default = n
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return o
  }));
  var r = n(22), i = n.n(r);

  function o(t) {
    return t instanceof i.a
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return a
  }));
  var r = n(1);

  function i(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function o(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  var s = n(0).a.viewport, a = function () {
    function t(e) {
      var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      i(this, t), this._parent = e, this._useDpr = n, this._width = 0, this._height = 0, this._dpr = 1, this._create()
    }

    var e, n, a;
    return e = t, (n = [{
      key: "canvas", get: function () {
        return this._canvas
      }
    }, {
      key: "ctx", get: function () {
        return this._ctx
      }
    }, {
      key: "width", get: function () {
        return this._width
      }
    }, {
      key: "height", get: function () {
        return this._height
      }
    }, {
      key: "dpr", get: function () {
        return this._dpr
      }
    }, {
      key: "_create", value: function () {
        this._canvas = Object(r.b)("canvas"), this._ctx = this._canvas.getContext("2d")
      }
    }, {
      key: "updateSize", value: function (t, e) {
        var n = 1;
        n = "boolean" == typeof this._useDpr ? this._useDpr ? s.dpr : s.dprMobile : this._useDpr, this._dpr = n;
        var r = 0, i = 0;
        t && e ? (r = t, i = e) : this._parent ? (r = this._parent.clientWidth * n, i = this._parent.clientHeight * n) : (r = s.size[0] * n, i = s.size[1] * n), this._width = r, this._height = i, this._canvas.width = r, this._canvas.height = i
      }
    }]) && o(e.prototype, n), a && o(e, a), t
  }()
}, function (t, e, n) {
  "use strict";
  var r = n(1), i = {app: Object(r.g)("#app"), page: Object(r.g)("#page")};
  e.a = i
}, function (t, e, n) {
  "use strict";
  n.d(e, "b", (function () {
    return i
  })), n.d(e, "a", (function () {
    return a
  }));
  var r = n(2);

  class i {
    constructor() {
      this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
    }

    setSize() {
    }

    render() {
      console.error("THREE.Pass: .render() must be implemented in derived pass.")
    }
  }

  const o = new r.M(-1, 1, 1, -1, 0, 1), s = new r.e;
  s.setAttribute("position", new r.q([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), s.setAttribute("uv", new r.q([0, 2, 0, 0, 2, 0], 2));

  class a {
    constructor(t) {
      this._mesh = new r.G(s, t)
    }

    dispose() {
      this._mesh.geometry.dispose()
    }

    render(t) {
      t.render(this._mesh, o)
    }

    get material() {
      return this._mesh.material
    }

    set material(t) {
      this._mesh.material = t
    }
  }
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = c(n(15)), o = c(n(6)), s = c(n(17)), a = c(n(42));

  function c(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function l(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function u(t, e, n) {
    return u = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = p(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, u(t, e, n || t)
  }

  function h(t, e) {
    return h = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, h(t, e)
  }

  function f(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = p(t);
      if (e) {
        var i = p(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return d(this, n)
    }
  }

  function d(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function p(t) {
    return p = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, p(t)
  }

  var m = n(54), v = n(25), g = n(46), y = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && h(t, e)
    }(c, t);
    var e, n, r, i = f(c);

    function c(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, c), i.call(this, t)
    }

    return e = c, n = [{
      key: "prefix", get: function () {
        return "".concat(this._v.prefix, "scroll")
      }
    }, {
      key: "defaultProp", get: function () {
        var t = this._prefix;
        return (0, o.default)(u(p(c.prototype), "defaultProp", this), {
          selectors: {
            outer: ".".concat(t),
            elements: ".".concat(t, "__el")
          },
          run: !0,
          frame: !1,
          resizeOnUpdate: !0,
          resizeTimeout: 0,
          scroll: !0,
          autoStop: !0,
          horizontal: !1,
          ease: .1,
          propagation: !1,
          willChange: !1,
          round: !1,
          useTransform: !0
        })
      }
    }, {
      key: "outer", get: function () {
        return this._outer
      }
    }, {
      key: "elements", get: function () {
        return this._el
      }
    }, {
      key: "sizes", get: function () {
        return [this._width, this._height]
      }
    }, {
      key: "scrollWidth", get: function () {
        return this._width
      }
    }, {
      key: "scrollHeight", get: function () {
        return this._height
      }
    }, {
      key: "outerSizes", get: function () {
        return [this._widthOuter, this._heightOuter]
      }
    }, {
      key: "width", get: function () {
        return this._widthOuter
      }
    }, {
      key: "height", get: function () {
        return this._heightOuter
      }
    }, {
      key: "scrollTop", get: function () {
        return this._scrollTop
      }, set: function (t) {
        this._targetTop = t, this._boundaries(!0), this._instant = !0, this.play()
      }
    }, {
      key: "scrollLeft", get: function () {
        return this._scrollLeft
      }, set: function (t) {
        this._targetLeft = t, this._boundaries(!1), this._instant = !0, this.play()
      }
    }, {
      key: "scrollValues", set: function (t) {
        this._targetLeft = t[0], this._targetTop = t[1], this._boundaries(!1), this._boundaries(), this._instant = !0, this.play()
      }
    }, {
      key: "targetLeft", get: function () {
        return this._targetLeft
      }, set: function (t) {
        this._targetLeft = t, this.play()
      }
    }, {
      key: "targetTop", get: function () {
        return this._targetTop
      }, set: function (t) {
        this._targetTop = t, this.play()
      }
    }, {
      key: "_extra", value: function () {
        u(p(c.prototype), "_extra", this).call(this);
        var t = this._prefix;
        this._data = {ease: "data-".concat(t, "-ease")}, this._properties = {
          current: "".concat(t, "-current"),
          ease: "".concat(t, "-ease")
        }, this._targetTop = 0, this._targetLeft = 0, this._scrollTop = 0, this._scrollLeft = 0, this._instant = !1, this._direction = 1, this._width = 1, this._height = 1, this._containerExists = !1, this._widthOuter = 1, this._heightOuter = 1, this._frame = !1, this._elGet(), this._elCreate()
      }
    }, {
      key: "_init", value: function () {
        u(p(c.prototype), "_init", this).call(this), this._run()
      }
    }, {
      key: "_changeProp", value: function (t) {
        u(p(c.prototype), "_changeProp", this).call(this, t), this._elGet(!0), this.setSize(), this._run()
      }
    }, {
      key: "_elGet", value: function () {
        var t = this._prop, e = t.selectors;
        this._outer = v.one(e.outer), this._outer.classList.add(this._prefix), this._el = v.all(e.elements);
        var n = this._el;
        this._length = n.length;
        var r = "";
        t.willChange && (r = t.useTransform ? "transform" : "top, left");
        for (var i = 0; i < n.length; i++) n[i].style.willChange = r
      }
    }, {
      key: "_elProp", value: function () {
        for (var t = 0; t < this._length; t++) {
          var e = this._el[t], n = this._properties, r = n.current, i = this._data.ease;
          e[r] = [this._scrollLeft, this.scrollTop];
          var o = e.getAttribute(i);
          i = o ? parseFloat(o) : this._prop.ease, e[n.ease] = i
        }
      }
    }, {
      key: "_elCreate", value: function () {
        var t = "".concat(this._prefix, "__container"), e = v.one("." + t, this._outer);
        if (e) this._container = e, this._containerExists = !0; else {
          for (this._container = m({
            selector: "div",
            styles: "".concat(this._prefix, "__container")
          }); this._outer.firstChild;) this._container.appendChild(this._outer.firstChild);
          this._outer.appendChild(this._container)
        }
      }
    }, {
      key: "_setEvents", value: function () {
        var t = this;
        this.setSize(), this.addEvent("viewport", {
          target: "", name: this.name, do: function () {
            (0, s.default)((function () {
              t.setSize(!0)
            }), t._prop.resizeTimeout)
          }
        }), this.addEventListener({
          el: this._outer,
          target: "wheel",
          do: this._wheel.bind(this),
          passive: !0
        }), this.addEventListener({el: this._outer, target: "scroll", do: this._onScroll.bind(this), passive: !0})
      }
    }, {
      key: "setSize", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        if (this._prop.run) {
          var e = this._container, n = this._outer;
          this._width = e.clientWidth, this._height = e.clientHeight, this._widthOuter = n.clientWidth, this._heightOuter = n.clientHeight, this._width < this._widthOuter && (this._width = this._widthOuter), this._height < this._heightOuter && (this._height = this._heightOuter), t && (this._instant = !0), t && (this._boundaries(!1), this._boundaries(!0)), this._elProp(), this.lbt("size")
        }
      }
    }, {
      key: "_wheel", value: function (t) {
        var e = this._prop;
        if (e.run & e.scroll) {
          e.propagation || t.stopPropagation();
          var n = (0, a.default)(t), r = n.pixelX, i = n.pixelY;
          e.horizontal && (r = n.pixelY, i = n.pixelX), this.targetLeft += r, this.targetTop += i, this._boundaries(!1), this._boundaries(!0);
          var o = "pixelY";
          e.horizontal && (o = "pixelX"), n[o] < 0 ? this._direction = -1 : this._direction = 1, this.play(), this.lbt("wheel", t)
        }
      }
    }, {
      key: "_onScroll", value: function () {
        this._prop.run && (this._outer.scrollTop = 0, this._outer.scrollLeft = 0)
      }
    }, {
      key: "_boundaries", value: function () {
        var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e = this._targetTop,
          n = this._targetLeft;
        if (t) {
          var r = this._height - this._heightOuter;
          e < 0 && (this.targetTop = 0), e > r && (this.targetTop = r)
        } else {
          var i = this._width - this._widthOuter;
          n < 0 && (this.targetLeft = 0), n > i && (this.targetLeft = i)
        }
      }
    }, {
      key: "_boundariesBoth", value: function () {
        this._boundaries(!1), this._boundaries()
      }
    }, {
      key: "_run", value: function () {
        this._prop.run ? this.play() : this.stop()
      }
    }, {
      key: "play", value: function () {
        !this._frame & this._prop.run && (this._prop.frame ? this._frame = this._prop.frame.on("frame", this.animate.bind(this)) : this._frame = window.requestAnimationFrame(this.animate.bind(this)))
      }
    }, {
      key: "stop", value: function () {
        var t = this._frame;
        t && (this._prop.frame ? this._prop.frame.remove(this._frame) : window.cancelAnimationFrame(t), this._frame = !1)
      }
    }, {
      key: "animate", value: function () {
        this._autoResize();
        var t = !1;
        this._instant && (t = !0, this._instant = !1), this._calcScrollValues(t), this._calcElValues(t), this._render(), this.lbt("update", {
          left: this._scrollLeft,
          top: this._scrollTop
        }), this._prop.frame || (this._frame = window.requestAnimationFrame(this.animate.bind(this))), Math.abs(this._targetTop - this._scrollTop) < .01 & Math.abs(this._targetLeft - this._scrollLeft) < .01 && (this._prop.autoStop && this.stop(), this.lbt("approximate"))
      }
    }, {
      key: "_autoResize", value: function () {
        var t = this._prop, e = this._container;
        if (t.resizeOnUpdate) {
          var n = e.clientHeight, r = e.clientWidth;
          n == this._height && r == this._width || this.setSize()
        }
      }
    }, {
      key: "_calcElValues", value: function (t) {
        for (var e = this._properties, n = 0; n < this._length; n++) {
          var r = this._el[n], i = this._getEase(r, t), o = r[e.current];
          i === this._prop.ease ? (o[0] = this._scrollLeft, o[1] = this._scrollTop) : (o[0] = this._r(g(o[0], this._targetLeft, i)), o[1] = this._r(g(o[1], this._targetTop, i)), this._prop.round && (o[0] = Math.round(o[0]), o[1] = Math.round(o[1])))
        }
      }
    }, {
      key: "_calcScrollValues", value: function (t) {
        var e = this._getEase(null, t);
        this._scrollLeft = this._r(g(this._scrollLeft, this._targetLeft, e)), this._scrollTop = this._r(g(this._scrollTop, this._targetTop, e)), this._prop.round && (this._scrollLeft = Math.round(this._scrollLeft), this._scrollTop = Math.round(this._scrollTop))
      }
    }, {
      key: "_r", value: function (t, e) {
        return e = void 0 !== e ? Math.pow(10, e) : 1e3, Math.round(t * e) / e
      }
    }, {
      key: "_getEase", value: function (t, e) {
        return e ? 1 : null == t ? this._prop.ease : t[this._properties.ease]
      }
    }, {
      key: "_render", value: function () {
        for (var t = 0; t < this._length; t++) {
          var e = this._el[t], n = e[this._properties.current], r = -n[0], i = -n[1];
          this._prop.useTransform ? e.style.transform = "\n                    matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0, ".concat(r, ", ").concat(i, ", 0,1)\n                ") : (e.style.left = r + "px", e.style.top = i + "px")
        }
      }
    }, {
      key: "destroy", value: function () {
        u(p(c.prototype), "destroy", this).call(this), this._prop.run = !1, this._run();
        var t = this._outer;
        if (!this._containerExists) {
          for (var e = this._container, n = e.children, r = 0; r < n.length; r++) t.appendChild(n[r]);
          t.removeChild(e)
        }
        t.classList.remove(this._prefix);
        for (var i = 0; i < this._el.length; i++) {
          var o = this._el[i];
          o.style.transform = "", o.style.willChange = ""
        }
      }
    }], n && l(e.prototype, n), r && l(e, r), c
  }(i.default);
  e.default = y
}, function (t, e, n) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var r = a(n(72)), i = a(n(6)), o = a(n(63)), s = a(n(17));

  function a(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function c(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function l(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  var u = function () {
    function t(e) {
      var n = this, o = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      c(this, t), e = (0, r.default)(e), this._v = e.v, this._vp = this._v.prop, this._prefix = this.prefix, this._prop = (0, i.default)(this.defaultProp, e), this._name = this.constructor.name, this._events = [], this.lbt = this.launchByTarget, this._prop.callbacks.forEach((function (t) {
        n.add(t)
      })), o && this._init()
    }

    var e, n, a;
    return e = t, n = [{
      key: "defaultProp", get: function () {
        return {v: window.vevetApplication, callbacks: []}
      }
    }, {
      key: "prop", get: function () {
        return this._prop
      }
    }, {
      key: "name", get: function () {
        return this._name
      }
    }, {
      key: "events", get: function () {
        return this._events
      }
    }, {
      key: "_extra", value: function () {
      }
    }, {
      key: "_init", value: function () {
        this._extra(), this._setEvents()
      }
    }, {
      key: "_setEvents", value: function () {
      }
    }, {
      key: "add", value: function (t) {
        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n = (0, o.default)(this.name),
          r = {id: n, on: e, data: t};
        return this._events.push(r), this._addCallback(n), n
      }
    }, {
      key: "_addCallback", value: function () {
      }
    }, {
      key: "on", value: function (t, e) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
          r = (0, i.default)(n, {target: t, do: e});
        return this.add(r)
      }
    }, {
      key: "remove", value: function (t) {
        for (var e = this._events, n = [], r = !1, i = 0; i < e.length; i++) {
          var o = e[i];
          if (o.id === t) {
            var s = !1, a = o.data.protected;
            "boolean" == typeof a && a && (s = !0), s ? n.push(o) : (this._removeCallback(t), r = !0)
          } else n.push(o)
        }
        return this._events = n, r
      }
    }, {
      key: "_removeCallback", value: function () {
      }
    }, {
      key: "removeAll", value: function () {
        for (; this._events.length > 0;) this.remove(this._events[0].id)
      }
    }, {
      key: "turn", value: function (t) {
        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n = this.get(t);
        return !!n && (n.on = e, this._turnCallback(t), !0)
      }
    }, {
      key: "_turnCallback", value: function () {
      }
    }, {
      key: "get", value: function (t) {
        for (var e = this._events, n = 0; n < e.length; n++) if (e[n].id === t) return e[n];
        return !1
      }
    }, {
      key: "_launch", value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        if (t.on) {
          var n = t.data, r = n.do, i = 0;
          n.timeout && (i = n.timeout), 0 === i ? this._launchCallback(r, e) : (0, s.default)(this._launchCallback.bind(this, r, e), i), "boolean" == typeof n.once && n.once && this.remove(t.id)
        }
      }
    }, {
      key: "_launchCallback", value: function (t, e) {
        e ? t(e) : t()
      }
    }, {
      key: "launchAll", value: function () {
        var t = this;
        this._events.forEach((function (e) {
          t._launch(e)
        }))
      }
    }, {
      key: "launchByTarget", value: function (t) {
        var e = this, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        this._events.forEach((function (r) {
          r.data.target === t && e._launch(r, n)
        }))
      }
    }], n && l(e.prototype, n), a && l(e, a), t
  }();
  e.default = u
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return i
  }));
  var r = n(0);

  function i() {
    var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    t ? r.a.html.classList.add("loading") : r.a.html.classList.remove("loading")
  }
}, function (t, e, n) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), Object.defineProperty(e, "one", {
    enumerable: !0,
    get: function () {
      return r.default
    }
  }), Object.defineProperty(e, "all", {
    enumerable: !0, get: function () {
      return i.default
    }
  }), Object.defineProperty(e, "isElement", {
    enumerable: !0, get: function () {
      return o.default
    }
  }), Object.defineProperty(e, "isHTMLElement", {
    enumerable: !0, get: function () {
      return s.default
    }
  }), Object.defineProperty(e, "isWindow", {
    enumerable: !0, get: function () {
      return a.default
    }
  }), Object.defineProperty(e, "selectElements", {
    enumerable: !0, get: function () {
      return c.default
    }
  }), Object.defineProperty(e, "exists", {
    enumerable: !0, get: function () {
      return l.default
    }
  });
  var r = u(n(56)), i = u(n(115)), o = u(n(47)), s = u(n(40)), a = u(n(74)), c = u(n(75)), l = u(n(116));

  function u(t) {
    return t && t.__esModule ? t : {default: t}
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return i
  }));
  var r = [];

  function i(t, e, n) {
    var i = function (t) {
      for (var e = 0; e < r.length; e++) {
        var n = r[e];
        if (n.src === t) return n.img
      }
      return !1
    }(t);
    if (i) e(i); else {
      var o = new Image;
      o.crossOrigin = "Anonymous", o.onload = function () {
        r.push({src: t, img: o}), e(o)
      }, o.onerror = function () {
        n && n()
      }, o.src = t
    }
  }
}, function (t, e, n) {
  "use strict";

  function r(t) {
    t.setAttribute("translate", "no")
  }

  n.d(e, "a", (function () {
    return r
  }))
}, function (t, e, n) {
  "use strict";
  var r = n(1), i = n(76), o = n.n(i), s = n(11), a = n(0), c = n(9), l = n(77), u = n(14), h = n(22);

  function f(t) {
    return f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, f(t)
  }

  function d(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function p(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function m(t, e, n) {
    return m = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = _(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, m(t, e, n || t)
  }

  function v(t, e) {
    return v = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, v(t, e)
  }

  function g(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = _(t);
      if (e) {
        var i = _(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return y(this, n)
    }
  }

  function y(t, e) {
    if (e && ("object" === f(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function _(t) {
    return _ = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, _(t)
  }

  var b = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && v(t, e)
    }(o, t);
    var e, n, r, i = g(o);

    function o() {
      var t;
      return d(this, o), (t = i.apply(this, arguments))._autoResizeFrames = 0, t
    }

    return e = o, (n = [{
      key: "_autoResize", value: function () {
        this._autoResizeFrames++, this._autoResizeFrames > 10 && (this._autoResizeFrames = 0, m(_(o.prototype), "_autoResize", this).call(this))
      }
    }]) && p(e.prototype, n), r && p(e, r), o
  }(n.n(h).a), x = n(41), w = n.n(x), S = n(57), M = n.n(S);

  function E(t) {
    return E = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, E(t)
  }

  function T(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function O(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function H(t, e, n) {
    return H = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = L(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, H(t, e, n || t)
  }

  function A(t, e) {
    return A = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, A(t, e)
  }

  function P(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = L(t);
      if (e) {
        var i = L(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return R(this, n)
    }
  }

  function R(t, e) {
    if (e && ("object" === E(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function L(t) {
    return L = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, L(t)
  }

  var C = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && A(t, e)
    }(o, t);
    var e, n, r, i = P(o);

    function o() {
      return T(this, o), i.apply(this, arguments)
    }

    return e = o, (n = [{
      key: "outer", get: function () {
        return this._outer
      }
    }, {
      key: "_extra", value: function () {
        H(L(o.prototype), "_extra", this).call(this), this._create()
      }
    }, {
      key: "_create", value: function () {
        this._outer = document.createElement("div"), this._outer.classList.add("v-scroll-line"), this._m.outer.appendChild(this._outer), this._line = document.createElement("div"), this._line.classList.add("v-scroll-line__progress"), this._outer.appendChild(this._line)
      }
    }, {
      key: "_setEvents", value: function () {
        H(L(o.prototype), "_setEvents", this).call(this), this._m.on("update", this._render.bind(this)), this._setDrag()
      }
    }, {
      key: "_setDrag", value: function () {
        var t = this, e = new M.a({outer: this._outer});
        e.on("move", (function (e) {
          t._move(e)
        })), e.on("start", (function (e) {
          t._move(e)
        }))
      }
    }, {
      key: "_move", value: function (t) {
        var e = this._outer.getBoundingClientRect(), n = t.inner.y / e.height,
          r = this._m.scrollHeight - this._m.height;
        this._m.targetTop = n * r, this._m._boundaries(!0)
      }
    }, {
      key: "_render", value: function () {
        var t = this._m.scrollTop / (this._m.scrollHeight - this._m.height);
        this._line.style.transform = "scale(1, ".concat(t, ")")
      }
    }, {
      key: "_destroy", value: function () {
        H(L(o.prototype), "_destroy", this).call(this), this._outer.remove()
      }
    }]) && O(e.prototype, n), r && O(e, r), o
  }(w.a), k = n(20), D = n(5), N = !1, z = function () {
    return {
      get: j.bind(this),
      create: I.bind(this),
      pause: U.bind(this),
      play: G.bind(this),
      toggle: B.bind(this),
      playAndSetClasses: V.bind(this)
    }
  }();
  e.a = z;

  function j() {
    return N
  }

  function I() {
    if (!u.a) {
      N = !1;
      var t = Object(r.g)("#custom-scroll");
      return t && t.classList.add("unactive"), !1
    }
    var e = !1, n = !0;
    "firefox" === a.a.browser && (e = !0, n = !1), "edge" === a.a.browser && (e = !0, n = !0);
    var i = new b({
      frame: D.a,
      selectors: {outer: "#custom-scroll", elements: Object(c.b)()},
      ease: Object(c.a)(),
      round: e,
      willChange: n,
      resizeTimeout: s.e,
      run: !1,
      resizeOnUpdate: !0
    });
    i.addPlugin(new o.a({
      on: !1,
      multiplier: .9,
      ease: .35,
      friction: .93,
      momentum: !0,
      responsive: [{breakpoint: "md", settings: {on: !0}}]
    })), a.a.vevetPage && a.a.vevetPage.on("destroy", (function () {
      i.destroy(), N = !1
    })), W(i, !1);
    var h = new C;
    return i.addPlugin(h), k.a.page.appendChild(h.outer), i.addPlugin(new l.a), a.a.vevetPage && a.a.vevetPage.addEvent("viewport", {
      target: "w_",
      do: B.bind(this, !0),
      name: "Custom Scroll"
    }), N = i, i
  }

  function B() {
    var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], e = j();
    if (e) {
      var n = u.a;
      F(e, !!n), t && W(e, n)
    }
  }

  function F(t) {
    var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    e && (t.outer.scrollTop = 0, t.outer.scrollLeft = 0), t.changeProp({run: e})
  }

  function U() {
    if (!u.a || !u.a) return !1;
    var t = j();
    return !!t && (F(t, !1), !0)
  }

  function G() {
    if (!u.a || !u.a) return !1;
    var t = j();
    return !!t && (F(t, !0), !0)
  }

  function V() {
    if (!u.a || !u.a) return !1;
    var t = j();
    return !!t && (W(t, !0), G(), !0)
  }

  function W(t, e) {
    var n = t.outer, i = Object(r.f)(Object(c.b)());
    if (e) n.classList.remove("unactive"), a.a.html.classList.add("use-custom-scroll"); else {
      n.classList.add("unactive"), a.a.html.classList.remove("use-custom-scroll");
      for (var o = 0, s = i.length; o < s; o++) {
        var l = i[o];
        l instanceof HTMLElement && (l.style.transform = "")
      }
    }
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "b", (function () {
    return i
  })), n.d(e, "a", (function () {
    return o
  }));
  var r = n(4), i = {tagName: "image-marquee", alwaysRender: !0, quantityMultiplier: 2},
    o = {paddingXRatio: .0833, parallaxFriction: .128, alpha: .4897, speed: -2, rotationY: .4168};
  if (r.b) {
    var s = r.b.addFolder(i.tagName);
    s.add(o, "parallaxFriction", r.a, .25, r.a), s.add(o, "alpha", r.a, 1, r.a), s.add(o, "speed", -5, 5, r.a), s.add(o, "rotationY", -Math.PI / 4, Math.PI / 4, r.a)
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return i
  }));
  var r = n(0);

  function i(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
      n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, i = [];

    function o() {
      i.forEach((function (t) {
        r.a.viewport.remove(t)
      }))
    }

    return r.a.viewport.mobiledevice || i.push(r.a.viewport.on("", (function () {
      t()
    }), {name: e, timeout: n})), r.a.viewport.mobiledevice && i.push(r.a.viewport.on("w_", (function () {
      t()
    }), {name: e, timeout: n})), {destroy: o.bind(this)}
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return y
  }));
  var r = n(15), i = n.n(r), o = n(6), s = n.n(o), a = n(10), c = n.n(a), l = n(2), u = n(5);

  function h(t) {
    return h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, h(t)
  }

  function f(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function d(t, e, n) {
    return d = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = g(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, d(t, e, n || t)
  }

  function p(t, e) {
    return p = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, p(t, e)
  }

  function m(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = g(t);
      if (e) {
        var i = g(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return v(this, n)
    }
  }

  function v(t, e) {
    if (e && ("object" === h(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function g(t) {
    return g = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, g(t)
  }

  var y = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && p(t, e)
    }(o, t);
    var e, n, r, i = m(o);

    function o(t) {
      var e;
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, o), (e = i.call(this, t))._renderedFrames = 0, e._uniforms = {}, e
    }

    return e = o, n = [{
      key: "defaultProp", get: function () {
        return s()(d(g(o.prototype), "defaultProp", this), {
          el: !1,
          autoRender: !0,
          three: u.a,
          scene: u.a.scene2d,
          autoRemove: !1,
          autoResize: !0,
          renderPosition: !0,
          zIndex: 1,
          zRotate: 0,
          texture: !1,
          alwaysNeedsUpdate: !1,
          material: l.H,
          materialProp: {},
          extendFragmentShader: !1,
          vertexShader: "",
          fragmentShader: "",
          uniformsData: []
        })
      }
    }, {
      key: "prop", get: function () {
        return this._prop
      }
    }, {
      key: "texture", get: function () {
        return this._texture
      }
    }, {
      key: "geometry", get: function () {
        return this._geometry
      }
    }, {
      key: "material", get: function () {
        return this._material
      }
    }, {
      key: "mesh", get: function () {
        return this._mesh
      }
    }, {
      key: "setDefaultProperties", value: function () {
        this._startSize = [0, 0], this._scale = [1, 1], this._threeEvents = [], this._texture = !1, this._material = l.H, this._onScene = !0, this._lastTimeRenderedPosition = !1
      }
    }, {
      key: "_extra", value: function () {
        d(g(o.prototype), "_extra", this).call(this), this.setDefaultProperties(), this._el = this.prop.el, this._data = this.prop.uniformsData
      }
    }, {
      key: "on", value: function (t, e, n) {
        return d(g(o.prototype), "on", this).call(this, t, e, n)
      }
    }, {
      key: "_setEvents", value: function () {
        this._createTHREE()
      }
    }, {
      key: "_createTHREE", value: function () {
        this._setStartSize(), this._createTexture(), this._createGeometry(), this._createMaterial(), this._createMesh(), this.resize(), this._prop.autoResize && this._setResize(), this.prop.scene && this.prop.scene.add(this._mesh), this._setRendering(), this.lbt("done")
      }
    }, {
      key: "_setStartSize", value: function () {
        var t = this._el, e = 0, n = 0, r = this.prop.three;
        t ? (0 === (e = t.clientWidth) && (e = r.width), 0 === (n = t.clientHeight) && (n = r.height)) : (e = r.width, n = r.height), this._startSize = [e, n]
      }
    }, {
      key: "resize", value: function () {
        var t = this._startSize[0], e = this._startSize[1], n = this._el, r = 0, i = 0;
        n ? (r = n.clientWidth, i = n.clientHeight) : (r = this.prop.three.width, i = this.prop.three.height), 0 === t && (t = r, this._startSize[0] = r), 0 === e && (e = i, this._startSize[1] = i);
        var o = r / t, s = i / e;
        this._scale = [o, s];
        var a = this._mesh;
        a.scale.x = o, a.scale.y = s
      }
    }, {
      key: "_setResize", value: function () {
        this._threeEvents.push(this.prop.three.on("resize", this.resize.bind(this)))
      }
    }, {
      key: "_createTexture", value: function () {
        var t = this.prop.texture;
        t && (this._texture = t)
      }
    }, {
      key: "_createGeometry", value: function () {
        var t = this._startSize[0], e = this._startSize[1], n = new l.Q(t, e, 150, 150);
        this._geometry = n, this.lbt("geometry")
      }
    }, {
      key: "_createMaterial", value: function () {
        var t = this._prop, e = this._prop.material;
        if (e instanceof l.ab) {
          var n = this._getMaterialUniforms();
          this._texture && (n = Object.assign(n, {
            map: {
              type: "t",
              value: this._texture
            }
          })), this._material = new l.ab(Object.assign({
            vertexShader: t.vertexShader,
            fragmentShader: t.fragmentShader,
            uniforms: n
          }, this._prop.materialProp)), this._uniforms = e.uniforms
        } else {
          var r = Object.assign({}, t.materialProp);
          this._texture && (r.map = this._texture), this._material = new e(r)
        }
        this._texture && (e.map = this._texture), e instanceof l.ab || t.extendFragmentShader && this._setMaterialDataOnExtendedMaterial(), this.lbt("material")
      }
    }, {
      key: "_getMaterialUniforms", value: function () {
        var t = {};
        return this._data.forEach((function (e) {
          t[e.key] = {type: e.type, value: e.value}
        })), t
      }
    }, {
      key: "_setMaterialDataOnExtendedMaterial", value: function () {
        this._setMaterialUserData(), this._setMaterialOnBeforeCompile()
      }
    }, {
      key: "_setMaterialUserData", value: function () {
        var t = this._material;
        this._data.forEach((function (e) {
          t.userData[e.key] = {type: e.type, value: e.value}
        }))
      }
    }, {
      key: "_setMaterialOnBeforeCompile", value: function () {
        var t = this;
        this._material.onBeforeCompile = function (e) {
          t._onMaterialBeforeCompile(e)
        }
      }
    }, {
      key: "_onMaterialBeforeCompile", value: function (t) {
        var e = this.prop.extendFragmentShader;
        e && (this._setShaderUniforms(t), t.fragmentShader = t.fragmentShader.replace("#include <map_fragment>", e))
      }
    }, {
      key: "_setShaderUniforms", value: function (t) {
        var e = this._material;
        this._data.forEach((function (n) {
          t.uniforms[n.key] = e.userData[n.key], t.fragmentShader = "uniform ".concat(n.type, " ").concat(n.key, "; \n ").concat(t.fragmentShader), t.vertexShader = "uniform ".concat(n.type, " ").concat(n.key, "; \n ").concat(t.vertexShader)
        })), this._uniforms = e.userData
      }
    }, {
      key: "_createMesh", value: function () {
        var t = new l.G(this._geometry, this._material);
        this._mesh = t, t.position.set(0, 0, this.prop.zIndex), t.rotation.z = this._prop.zRotate, this.lbt("mesh")
      }
    }, {
      key: "removeThreeEvents", value: function () {
        var t = this;
        this._threeEvents.forEach((function (e) {
          t.prop.three.remove(e)
        }))
      }
    }, {
      key: "destroy", value: function () {
        d(g(o.prototype), "destroy", this).call(this), this.removeThreeEvents(), this._geometry && this._geometry.dispose(), this._material && this._material.dispose(), this._texture && this._texture.dispose(), this.prop.scene && this.prop.scene.remove(this._mesh)
      }
    }, {
      key: "_setRendering", value: function () {
        this.prop.autoRender && this._threeEvents.push(this.prop.three.on("prerender", this.render.bind(this)))
      }
    }, {
      key: "render", value: function () {
        this.prop.renderPosition && this.renderPosition(), this._renderTexture(), this._renderedFrames += 1
      }
    }, {
      key: "renderPosition", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], e = this._prop, n = e.three,
          r = this._mesh, i = this._prop.scene;
        if (!t) if (e.renderPosition) this._lastTimeRenderedPosition = !1; else {
          if (this._lastTimeRenderedPosition) return;
          this._lastTimeRenderedPosition = !0
        }
        var o = this._getBounding(), s = this._getPosition(o);
        this._prop.autoRemove && (o.right < 0 || o.bottom < 0 || o.top > n.height || o.left > n.width ? (s.x = -5e3, s.y = -5e3, this._onScene && (i && i.remove(r), this._onScene = !1, r.matrixAutoUpdate = !1)) : this._onScene || (i && i.add(r), this._onScene = !0, r.matrixAutoUpdate = !0)), r.position.x = s.x, r.position.y = s.y
      }
    }, {
      key: "_getBounding", value: function () {
        return (this._el ? this._el : this._prop.three.outer).getBoundingClientRect()
      }
    }, {
      key: "_getPosition", value: function (t) {
        var e = this._prop.three, n = (e.width - t.width) / -2, r = (e.height - t.height) / 2;
        return {x: n + t.left, y: r - t.top}
      }
    }, {
      key: "_renderTexture", value: function () {
        this._prop.alwaysNeedsUpdate && this._texture && (this._texture.needsUpdate = !0)
      }
    }, {
      key: "hide", value: function (t) {
        var e = this;
        return new Promise((function (n) {
          var r = new c.a;
          r.on("progress", (function (t) {
            e.setAlpha(1 - t.se)
          })), r.on("end", (function () {
            n()
          })), r.play({duration: t})
        }))
      }
    }, {
      key: "show", value: function (t) {
        var e = this;
        return new Promise((function (n) {
          var r = new c.a;
          r.on("progress", (function (t) {
            e.setAlpha(t.se)
          })), r.on("end", (function () {
            n()
          })), r.play({duration: t})
        }))
      }
    }, {
      key: "setAlpha", value: function (t) {
        this.mesh.material.opacity = t
      }
    }], n && f(e.prototype, n), r && f(e, r), o
  }(i.a)
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return a
  })), n.d(e, "b", (function () {
    return c
  }));
  var r = n(10), i = n.n(r), o = (n(1), n(18)), s = n(9);

  function a(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 350,
      n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r = new Promise((function (r) {
        var a, c = (a = n || Object(s.c)()).scrollTop, l = t - c, u = new i.a;
        u.on("progress", (function (t) {
          Object(o.a)(n) && n.play();
          a instanceof HTMLElement && "html" === a.tagName.toLocaleLowerCase() && (document.body.scrollTop = c + l * t.se), a.scrollTop = c + l * t.se
        })), u.on("end", (function () {
          r()
        })), u.play({duration: e, easing: [.25, .1, .25, 1]})
      }));
    return r
  }

  function c() {
    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 350,
      e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return a(0, t, e)
  }
}, function (t, e, n) {
  "use strict";

  function r(t, e) {
    return function (t) {
      if (Array.isArray(t)) return t
    }(t) || function (t, e) {
      if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(t))) return;
      var n = [], r = !0, i = !1, o = void 0;
      try {
        for (var s, a = t[Symbol.iterator](); !(r = (s = a.next()).done) && (n.push(s.value), !e || n.length !== e); r = !0) ;
      } catch (c) {
        i = !0, o = c
      } finally {
        try {
          r || null == a.return || a.return()
        } finally {
          if (i) throw o
        }
      }
      return n
    }(t, e) || function (t, e) {
      if (!t) return;
      if ("string" == typeof t) return i(t, e);
      var n = Object.prototype.toString.call(t).slice(8, -1);
      "Object" === n && t.constructor && (n = t.constructor.name);
      if ("Map" === n || "Set" === n) return Array.from(t);
      if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return i(t, e)
    }(t, e) || function () {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }()
  }

  function i(t, e) {
    (null == e || e > t.length) && (e = t.length);
    for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
    return r
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var o = n(39);
  var s = function t(e, n) {
    if (o(n)) return function (t, e) {
      var n = r(t, 4), i = n[0], o = n[1], s = n[2], l = n[3];
      if (i === o && s === l) return e;
      for (var u = [], h = 0; h < 11; ++h) u[h] = c(.1 * h, i, s);
      if (0 === e) return 0;
      if (1 === e) return 1;
      return c(function (t, e, n) {
        for (var i = r(t, 4), o = i[0], s = (i[1], i[2]), l = (i[3], 0), u = 1; 10 !== u && n[u] <= e; ++u) l += .1;
        --u;
        var h = (e - n[u]) / (n[u + 1] - n[u]), f = l + .1 * h, d = a(f, o, s);
        return d >= .001 ? function (t, e, n, r) {
          for (var i = 0; i < 4; ++i) {
            var o = a(e, n, r);
            if (0 === o) return e;
            e -= (c(e, n, r) - t) / o
          }
          return e
        }(e, f, o, s) : 0 === d ? f : function (t, e, n, r, i) {
          var o, s, a = 0;
          do {
            (o = c(s = e + (n - e) / 2, r, i) - t) > 0 ? n = s : e = s
          } while (Math.abs(o) > 1e-7 && ++a < 10);
          return s
        }(e, l, l + .1, o, s)
      }(t, e, u), o, l)
    }(n, e);
    if ("string" == typeof n) switch (n) {
      case"easeInQuad":
        return 1 * (e /= 1) * e + 0;
      case"easeOutQuad":
        return -1 * (e /= 1) * (e - 2) + 0;
      case"easeInOutQuad":
        return (e /= .5) < 1 ? .5 * e * e + 0 : -.5 * (--e * (e - 2) - 1) + 0;
      case"easeInCubic":
        return 1 * (e /= 1) * e * e + 0;
      case"easeOutCubic":
        return 1 * ((e = e / 1 - 1) * e * e + 1) + 0;
      case"easeInOutCubic":
        return (e /= .5) < 1 ? .5 * e * e * e + 0 : .5 * ((e -= 2) * e * e + 2) + 0;
      case"easeInQuart":
        return 1 * (e /= 1) * e * e * e + 0;
      case"easeOutQuart":
        return -1 * ((e = e / 1 - 1) * e * e * e - 1) + 0;
      case"easeInOutQuart":
        return (e /= .5) < 1 ? .5 * e * e * e * e + 0 : -.5 * ((e -= 2) * e * e * e - 2) + 0;
      case"easeInQuint":
        return 1 * (e /= 1) * e * e * e * e + 0;
      case"easeOutQuint":
        return 1 * ((e = e / 1 - 1) * e * e * e * e + 1) + 0;
      case"easeInOutQuint":
        return (e /= .5) < 1 ? .5 * e * e * e * e * e + 0 : .5 * ((e -= 2) * e * e * e * e + 2) + 0;
      case"easeInSine":
        return -1 * Math.cos(e / 1 * (Math.PI / 2)) + 1 + 0;
      case"easeOutSine":
        return 1 * Math.sin(e / 1 * (Math.PI / 2)) + 0;
      case"easeInOutSine":
        return -.5 * (Math.cos(Math.PI * e / 1) - 1) + 0;
      case"easeInExpo":
        return 0 == e ? 0 : 1 * Math.pow(2, 10 * (e / 1 - 1)) + 0;
      case"easeOutExpo":
        return 1 == e ? 1 : 1 * (1 - Math.pow(2, -10 * e / 1)) + 0;
      case"easeInOutExpo":
        return 0 == e ? 0 : 1 == e ? 1 : (e /= .5) < 1 ? .5 * Math.pow(2, 10 * (e - 1)) + 0 : .5 * (2 - Math.pow(2, -10 * --e)) + 0;
      case"easeInCirc":
        return -1 * (Math.sqrt(1 - (e /= 1) * e) - 1) + 0;
      case"easeOutCirc":
        return 1 * Math.sqrt(1 - (e = e / 1 - 1) * e) + 0;
      case"easeInOutCirc":
        return (e /= .5) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) + 0 : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1) + 0;
      case"easeInElastic":
        var i = 1.70158;
        if (0 == e) return 0;
        if (1 == (e /= 1)) return 1;
        if ((s = 0) || (s = .3), (l = 1) < Math.abs(1)) {
          l = 1;
          i = s / 4
        } else i = s / (2 * Math.PI) * Math.asin(1 / l);
        return -l * Math.pow(2, 10 * (e -= 1)) * Math.sin((1 * e - i) * (2 * Math.PI) / s) + 0;
      case"easeOutElastic":
        i = 1.70158;
        if (0 == e) return 0;
        if (1 == (e /= 1)) return 1;
        if ((s = 0) || (s = .3), (l = 1) < Math.abs(1)) {
          l = 1;
          i = s / 4
        } else i = s / (2 * Math.PI) * Math.asin(1 / l);
        return l * Math.pow(2, -10 * e) * Math.sin((1 * e - i) * (2 * Math.PI) / s) + 1 + 0;
      case"easeInOutElastic":
        var s, l;
        i = 1.70158;
        if (0 == e) return 0;
        if (2 == (e /= .5)) return 1;
        if ((s = 0) || (s = .3 * 1.5 * 1), (l = 1) < Math.abs(1)) {
          l = 1;
          i = s / 4
        } else i = s / (2 * Math.PI) * Math.asin(1 / l);
        return e < 1 ? l * Math.pow(2, 10 * (e -= 1)) * Math.sin((1 * e - i) * (2 * Math.PI) / s) * -.5 + 0 : l * Math.pow(2, -10 * (e -= 1)) * Math.sin((1 * e - i) * (2 * Math.PI) / s) * .5 + 1 + 0;
      case"easeInBack":
        return null == i && (i = 1.70158), 1 * (e /= 1) * e * ((i + 1) * e - i) + 0;
      case"easeOutBack":
        return null == i && (i = 1.70158), 1 * ((e = e / 1 - 1) * e * ((i + 1) * e + i) + 1) + 0;
      case"easeInOutBack":
        return null == i && (i = 1.70158), (e /= .5) < 1 ? e * e * ((1 + (i *= 1.525)) * e - i) * .5 + 0 : .5 * ((e -= 2) * e * ((1 + (i *= 1.525)) * e + i) + 2) + 0;
      case"easeInBounce":
        return 1 - t(1 - e, "easeOutBounce") + 0;
      case"easeOutBounce":
        return (e /= 1) < 1 / 2.75 ? 7.5625 * e * e * 1 + 0 : e < 2 / 2.75 ? 1 * (7.5625 * (e -= 1.5 / 2.75) * e + .75) + 0 : e < 2.5 / 2.75 ? 1 * (7.5625 * (e -= 2.25 / 2.75) * e + .9375) + 0 : 1 * (7.5625 * (e -= 2.625 / 2.75) * e + .984375) + 0;
      case"easeInOutBounce":
        return e < .5 ? .5 * t(2 * e, "easeOutBounce") + 0 : .5 * t(2 * e - 1, "easeOutBounce") + .5 + 0;
      default:
        return e
    } else if ("function" == typeof n) return n(e);
    return e
  };

  function a(t, e, n) {
    return 3 * l(e, n) * t * t + 2 * u(e, n) * t + h(e)
  }

  function c(t, e, n) {
    return ((l(e, n) * t + u(e, n)) * t + h(e)) * t
  }

  function l(t, e) {
    return 1 - 3 * e + 3 * t
  }

  function u(t, e) {
    return 3 * e - 6 * t
  }

  function h(t) {
    return 3 * t
  }

  e.default = s
}, function (t, e, n) {
  "use strict";
  n.d(e, "c", (function () {
    return f
  })), n.d(e, "a", (function () {
    return r
  })), n.d(e, "b", (function () {
    return d
  }));
  var r, i = n(1), o = n(97), s = n.n(o), a = n(20), c = n(11), l = n(0), u = n(7), h = void 0, f = "data-cursor";
  !function (t) {
    t.Link315 = "link-315", t.Drag = "drag"
  }(r || (r = {}));
  var d = function () {
    if (l.a.viewport.mobiledevice) return !1;
    if (!c.h) return !1;
    var t = new s.a({selector: a.a.page, run: !1}), e = [];

    function n(e) {
      var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
      Object(i.b)("div", {class: "v-cursor__".concat(e), parent: t.cursor, html: n})
    }

    function o() {
      return Object(i.f)("*[".concat(f, "]"))
    }

    return u.a.on("loaded", (function () {
      e.forEach((function (e) {
        t.cursor.classList.remove(e)
      })), e = []
    })), n(r.Link315, '\n    <svg width="41" height="29" viewBox="0 0 41 29" fill="none" xmlns="http://www.w3.org/2000/svg">\n        <path d="M0.0415039 14.2427C0.0415039 14.2427 21.0732 14.2427 40.0415 14.2427M40.0415 14.2427C26.3389 14.2427 23.8096 28.2427 23.8096 28.2427M40.0415 14.2427C26.3389 14.2427 23.8096 0.242677 23.8096 0.242677" stroke="white" stroke-width="2"/>\n    </svg>\n'), n(r.Drag, '\n<svg width="46" height="19" viewBox="0 0 46 19" fill="none" xmlns="http://www.w3.org/2000/svg">\n<path fill-rule="evenodd" clip-rule="evenodd" d="M0 10.1805C4.04617 10.1805 6.40244 12.197 7.78747 14.2414C8.48826 15.2758 8.937 16.3169 9.21011 17.1026C9.34613 17.4939 9.4371 17.8175 9.49331 18.0394C9.52139 18.1502 9.5407 18.2353 9.55256 18.2903C9.55849 18.3177 9.56255 18.3377 9.5649 18.3495L9.56715 18.361C9.56708 18.3606 9.567 18.3602 10.5507 18.1805C11.5344 18.0008 11.5344 18.0003 11.5343 17.9998L11.534 17.9986L11.5335 17.9955L11.5318 17.9868L11.5266 17.9599C11.5222 17.9377 11.5159 17.9071 11.5076 17.8686C11.491 17.7918 11.4663 17.6835 11.4321 17.5482C11.3636 17.2779 11.2565 16.8984 11.0992 16.4459C10.7858 15.5441 10.2668 14.3352 9.44326 13.1196C8.74006 12.0817 7.81258 11.0388 6.609 10.1805H6.6169H6.68914H6.76135H6.83353H6.90568H6.97779H7.04987H7.12192H7.19393H7.2659H7.33784H7.40974H7.48161H7.55343H7.62522H7.69697H7.76867H7.84034H7.91196H7.98354H8.05508H8.12657H8.19802H8.26943H8.34078H8.4121H8.48336H8.55458H8.62575H8.69687H8.76793H8.83895H8.90992H8.98084H9.0517H9.12251H9.19327H9.26397H9.33462H9.40521H9.47574H9.54622H9.61664H9.687H9.7573H9.82754H9.89772H9.96784H10.0379H10.1079H10.1778H10.2477H10.3175H10.3872H10.4569H10.5265H10.5961H10.6655H10.7349H10.8043H10.8735H10.9427H11.0118H11.0809H11.1499H11.2188H11.2876H11.3563H11.425H11.4936H11.5621H11.6306H11.699H11.7673H11.8355H11.9036H11.9717H12.0396H12.1075H12.1753H12.243H12.3107H12.3782H12.4457H12.5131H12.5804H12.6476H12.7147H12.7817H12.8487H12.9155H12.9823H13.049H13.1155H13.182H13.2484H13.3147H13.3809H13.447H13.513H13.5789H13.6448H13.7105H13.7761H13.8416H13.907H13.9724H14.0376H14.1027H14.1677H14.2326H14.2974H14.3621H14.4267H14.4912H14.5556H14.6198H14.684H14.7481H14.812H14.8759H14.9396H15.0032H15.0667H15.1301H15.1934H15.2565H15.3196H15.3825H15.4453H15.508H15.5706H15.633H15.6954H15.7576H15.8197H15.8817H15.9436H16.0053H16.0669H16.1284H16.1898H16.251H16.3121H16.3731H16.434H16.4947H16.5553H16.6158H16.6761H16.7364H16.7965H16.8564H16.9162H16.9759H17.0355H17.0949H17.1542H17.2133H17.2723H17.3312H17.39H17.4486H17.507H17.5653H17.6235H17.6816H17.7395H17.7972H17.8548H17.9123H17.9696H18.0268H18.0838H18.1407H18.1975H18.2541H18.3105H18.3668H18.423H18.4789H18.5348H18.5905H18.646H18.7014H18.7566H18.8117H18.8666H18.9214H18.976H19.0305H19.0848H19.1389H19.1929H19.2467H19.3004H19.3538H19.4072H19.4604H19.5134H19.5662H19.6189H19.6714H19.7237H19.7759H19.8279H19.8798H19.9315H19.983H20.0002H20.0006H20.0014H20.0025H20.0039H20.0056H20.0076H20.01H20.0126H20.0155H20.0188H20.0223H20.0262H20.0304H20.0343H20.0348H20.0396H20.0447H20.05H20.0557H20.0617H20.068H20.0745H20.0814H20.0855H20.0886H20.096H20.1038H20.1118H20.1202H20.1288H20.1365H20.1378H20.147H20.1565H20.1664H20.1765H20.1869H20.1873H20.1975H20.2085H20.2198H20.2313H20.238H20.2432H20.2553H20.2677H20.2804H20.2884H20.2934H20.3066H20.3202H20.334H20.3387H20.3481H20.3625H20.3771H20.3889H20.3921H20.4073H20.4228H20.4386H20.4388H20.4546H20.471H20.4876H20.4886H20.5045H20.5216H20.5382H20.5391H20.5568H20.5747H20.5876H20.593H20.6115H20.6303H20.6369H20.6493H20.6687H20.6859H20.6882H20.7081H20.7282H20.7348H20.7486H20.7693H20.7835H20.7902H20.8114H20.8321H20.8328H20.8545H20.8765H20.8804H20.8988H20.9212H20.9286H20.944H20.967H20.9766H20.9903H21.0138H21.0244H21.0376H21.0616H21.072H21.0859H21.1105H21.1194H21.1353H21.1604H21.1666H21.1857H21.2113H21.2137H21.2371H21.2606H21.2631H21.2895H21.3073H21.316H21.3429H21.3538H21.3699H21.3973H21.4001H21.4248H21.4462H21.4526H21.4807H21.4921H21.509H21.5375H21.5378H21.5663H21.5834H21.5954H21.6246H21.6287H21.6542H21.6739H21.6839H21.7139H21.7189H21.7441H21.7636H21.7746H21.8053H21.8082H21.8363H21.8526H21.8675H21.8968H21.8989H21.9306H21.9408H21.9625H21.9846H21.9946H22.027H22.0282H22.0596H22.0716H22.0924H22.1148H22.1255H22.1578H22.1588H22.1923H22.2006H22.226H22.2431H22.26H22.2855H22.2942H22.3277H22.3287H22.3633H22.3697H22.3982H22.4115H22.4334H22.4531H22.4687H22.4944H22.5043H22.5356H22.5401H22.5761H22.5766H22.6123H22.6173H22.6488H22.6579H22.6854H22.6982H22.7223H22.7383H22.7595H22.7782H22.7968H22.8179H22.8344H22.8574H22.8721H22.8967H22.9101H22.9358H22.9483H22.9746H22.9868H23.0132H23.0254H23.0517H23.0642H23.0899H23.1033H23.1279H23.1426H23.1656H23.1821H23.2032H23.2218H23.2405H23.2617H23.2777H23.3018H23.3146H23.3421H23.3512H23.3827H23.3877H23.4234H23.4239H23.4599H23.4644H23.4957H23.5056H23.5313H23.5469H23.5666H23.5885H23.6018H23.6303H23.6367H23.6713H23.6723H23.7058H23.7145H23.74H23.7569H23.774H23.7994H23.8077H23.8412H23.8422H23.8745H23.8852H23.9076H23.9284H23.9404H23.9718H23.973H24.0054H24.0154H24.0375H24.0592H24.0694H24.1011H24.1032H24.1325H24.1474H24.1637H24.1918H24.1947H24.2254H24.2364H24.2559H24.2811H24.2861H24.3161H24.3261H24.3458H24.3713H24.3754H24.4046H24.4166H24.4337H24.4622H24.4625H24.491H24.5079H24.5193H24.5474H24.5538H24.5752H24.5999H24.6027H24.6301H24.6462H24.6571H24.684H24.6927H24.7105H24.7369H24.7394H24.7629H24.7863H24.7887H24.8143H24.8334H24.8396H24.8647H24.8806H24.8895H24.9141H24.928H24.9384H24.9624H24.9756H24.9862H25.0097H25.0234H25.033H25.056H25.0714H25.0788H25.1012H25.1196H25.1235H25.1455H25.1672H25.1679H25.1886H25.2098H25.2165H25.2307H25.2514H25.2652H25.2718H25.2919H25.3118H25.3141H25.3313H25.3507H25.3631H25.3697H25.3885H25.407H25.4124H25.4253H25.4432H25.4609H25.4618H25.4784H25.4955H25.5114H25.5124H25.529H25.5454H25.5612H25.5614H25.5772H25.5927H25.6079H25.6111H25.6229H25.6375H25.6519H25.6613H25.666H25.6798H25.6934H25.7066H25.7116H25.7196H25.7323H25.7447H25.7568H25.762H25.7687H25.7802H25.7915H25.8025H25.8127H25.8131H25.8235H25.8336H25.8435H25.853H25.8622H25.8635H25.8712H25.8798H25.8882H25.8962H25.904H25.9114H25.9145H25.9186H25.9255H25.932H25.9383H25.9443H25.95H25.9553H25.9604H25.9652H25.9657H25.9696H25.9738H25.9777H25.9812H25.9845H25.9874H25.99H25.9924H25.9944H25.9961H25.9975H25.9986H25.9994H25.9998H26.017H26.0685H26.1202H26.1721H26.2241H26.2763H26.3286H26.3811H26.4338H26.4866H26.5396H26.5928H26.6462H26.6996H26.7533H26.8071H26.8611H26.9152H26.9695H27.024H27.0786H27.1334H27.1883H27.2434H27.2986H27.354H27.4095H27.4652H27.5211H27.577H27.6332H27.6895H27.7459H27.8025H27.8593H27.9162H27.9732H28.0304H28.0877H28.1452H28.2028H28.2605H28.3184H28.3765H28.4347H28.493H28.5514H28.61H28.6688H28.7277H28.7867H28.8458H28.9051H28.9645H29.0241H29.0838H29.1436H29.2035H29.2636H29.3239H29.3842H29.4447H29.5053H29.566H29.6269H29.6879H29.749H29.8102H29.8716H29.9331H29.9947H30.0564H30.1183H30.1803H30.2424H30.3046H30.367H30.4294H30.492H30.5547H30.6175H30.6804H30.7435H30.8066H30.8699H30.9333H30.9968H31.0604H31.1241H31.188H31.2519H31.316H31.3801H31.4444H31.5088H31.5733H31.6379H31.7026H31.7674H31.8323H31.8973H31.9624H32.0276H32.093H32.1584H32.2239H32.2895H32.3552H32.4211H32.487H32.553H32.6191H32.6853H32.7516H32.818H32.8845H32.951H33.0177H33.0845H33.1513H33.2183H33.2853H33.3524H33.4196H33.4869H33.5543H33.6218H33.6893H33.757H33.8247H33.8925H33.9604H34.0283H34.0964H34.1645H34.2327H34.301H34.3694H34.4379H34.5064H34.575H34.6437H34.7124H34.7812H34.8501H34.9191H34.9882H35.0573H35.1265H35.1957H35.2651H35.3345H35.4039H35.4735H35.5431H35.6128H35.6825H35.7523H35.8222H35.8921H35.9621H36.0322H36.1023H36.1725H36.2427H36.313H36.3834H36.4538H36.5243H36.5948H36.6654H36.736H36.8067H36.8775H36.9483H37.0192H37.0901H37.161H37.2321H37.3031H37.3743H37.4454H37.5166H37.5879H37.6592H37.7306H37.802H37.8734H37.9449H38.0165H38.088H38.1597H38.2313H38.303H38.3748H38.4466H38.5184H38.5903H38.6622H38.7341H38.8061H38.8781H38.9501H39.0222H39.0943H39.1665H39.2386H39.3109H39.3831H39.391C38.1874 11.0388 37.2599 12.0817 36.5567 13.1196C35.7332 14.3352 35.2142 15.5441 34.9008 16.4459C34.7435 16.8984 34.6364 17.2779 34.5679 17.5482C34.5337 17.6835 34.509 17.7918 34.4924 17.8686C34.4841 17.9071 34.4778 17.9377 34.4734 17.9599L34.4682 17.9868L34.4665 17.9955L34.466 17.9986L34.4657 17.9998C34.4656 18.0003 34.4656 18.0008 35.4493 18.1805C36.433 18.3602 36.4329 18.3606 36.4328 18.361L36.4351 18.3495C36.4375 18.3377 36.4415 18.3177 36.4474 18.2903C36.4593 18.2353 36.4786 18.1502 36.5067 18.0394C36.5629 17.8175 36.6539 17.4939 36.7899 17.1026C37.063 16.3169 37.5117 15.2758 38.2125 14.2414C39.5976 12.197 41.9538 10.1805 46 10.1805V8.18052C41.9538 8.18052 39.5976 6.164 38.2125 4.11963C37.5117 3.08524 37.063 2.04411 36.7899 1.25843C36.6539 0.86714 36.5629 0.543501 36.5067 0.321636C36.4786 0.210823 36.4593 0.125769 36.4474 0.0707779C36.4415 0.043293 36.4375 0.0233555 36.4351 0.011507L36.4328 0C36.4329 0.000391006 36.433 0.000818253 35.4493 0.180517C34.4656 0.360216 34.4656 0.360712 34.4657 0.36124L34.466 0.362474L34.4665 0.365561L34.4682 0.374201L34.4734 0.401163C34.4778 0.423372 34.4841 0.453972 34.4924 0.492405C34.509 0.56925 34.5337 0.677555 34.5679 0.812836C34.6364 1.08316 34.7435 1.46264 34.9008 1.91511C35.2142 2.81693 35.7332 4.02579 36.5567 5.2414C37.2599 6.27935 38.1874 7.32226 39.391 8.18052H39.3831H39.3109H39.2386H39.1665H39.0943H39.0222H38.9501H38.8781H38.8061H38.7341H38.6622H38.5903H38.5184H38.4466H38.3748H38.303H38.2313H38.1597H38.088H38.0165H37.9449H37.8734H37.802H37.7306H37.6592H37.5879H37.5166H37.4454H37.3743H37.3031H37.2321H37.161H37.0901H37.0192H36.9483H36.8775H36.8067H36.736H36.6654H36.5948H36.5243H36.4538H36.3834H36.313H36.2427H36.1725H36.1023H36.0322H35.9621H35.8921H35.8222H35.7523H35.6825H35.6128H35.5431H35.4735H35.4039H35.3345H35.2651H35.1957H35.1265H35.0573H34.9882H34.9191H34.8501H34.7812H34.7124H34.6437H34.575H34.5064H34.4379H34.3694H34.301H34.2327H34.1645H34.0964H34.0283H33.9604H33.8925H33.8247H33.757H33.6893H33.6218H33.5543H33.4869H33.4196H33.3524H33.2853H33.2183H33.1513H33.0845H33.0177H32.951H32.8845H32.818H32.7516H32.6853H32.6191H32.553H32.487H32.4211H32.3552H32.2895H32.2239H32.1584H32.093H32.0276H31.9624H31.8973H31.8323H31.7674H31.7026H31.6379H31.5733H31.5088H31.4444H31.3801H31.316H31.2519H31.188H31.1241H31.0604H30.9968H30.9333H30.8699H30.8066H30.7435H30.6804H30.6175H30.5547H30.492H30.4294H30.367H30.3046H30.2424H30.1803H30.1183H30.0564H29.9947H29.9331H29.8716H29.8102H29.749H29.6879H29.6269H29.566H29.5053H29.4447H29.3842H29.3239H29.2636H29.2035H29.1436H29.0838H29.0241H28.9645H28.9051H28.8458H28.7867H28.7277H28.6688H28.61H28.5514H28.493H28.4347H28.3765H28.3184H28.2605H28.2028H28.1452H28.0877H28.0304H27.9732H27.9162H27.8593H27.8025H27.7459H27.6895H27.6332H27.577H27.5211H27.4652H27.4095H27.354H27.2986H27.2434H27.1883H27.1334H27.0786H27.024H26.9695H26.9152H26.8611H26.8071H26.7533H26.6996H26.6462H26.5928H26.5396H26.4866H26.4338H26.3811H26.3286H26.2763H26.2241H26.1721H26.1202H26.0685H26.017H25.9998H25.9994H25.9986H25.9975H25.9961H25.9944H25.9924H25.99H25.9874H25.9845H25.9812H25.9777H25.9738H25.9696H25.9657H25.9652H25.9604H25.9553H25.95H25.9443H25.9383H25.932H25.9255H25.9186H25.9145H25.9114H25.904H25.8962H25.8882H25.8798H25.8712H25.8635H25.8622H25.853H25.8435H25.8336H25.8235H25.8131H25.8127H25.8025H25.7915H25.7802H25.7687H25.762H25.7568H25.7447H25.7323H25.7196H25.7116H25.7066H25.6934H25.6798H25.666H25.6613H25.6519H25.6375H25.6229H25.6111H25.6079H25.5927H25.5772H25.5614H25.5612H25.5454H25.529H25.5124H25.5114H25.4955H25.4784H25.4618H25.4609H25.4432H25.4253H25.4124H25.407H25.3885H25.3697H25.3631H25.3507H25.3313H25.3141H25.3118H25.2919H25.2718H25.2652H25.2514H25.2307H25.2165H25.2098H25.1886H25.1679H25.1672H25.1455H25.1235H25.1196H25.1012H25.0788H25.0714H25.056H25.033H25.0234H25.0097H24.9862H24.9756H24.9624H24.9384H24.928H24.9141H24.8895H24.8806H24.8647H24.8396H24.8334H24.8143H24.7887H24.7863H24.7629H24.7394H24.7369H24.7105H24.6927H24.684H24.6571H24.6462H24.6301H24.6027H24.5999H24.5752H24.5538H24.5474H24.5193H24.5079H24.491H24.4625H24.4622H24.4337H24.4166H24.4046H24.3754H24.3713H24.3458H24.3261H24.3161H24.2861H24.2811H24.2559H24.2364H24.2254H24.1947H24.1918H24.1637H24.1474H24.1325H24.1032H24.1011H24.0694H24.0592H24.0375H24.0154H24.0054H23.973H23.9718H23.9404H23.9284H23.9076H23.8852H23.8745H23.8422H23.8412H23.8077H23.7994H23.774H23.7569H23.74H23.7145H23.7058H23.6723H23.6713H23.6367H23.6303H23.6018H23.5885H23.5666H23.5469H23.5313H23.5056H23.4957H23.4644H23.4599H23.4239H23.4234H23.3877H23.3827H23.3512H23.3421H23.3146H23.3018H23.2777H23.2617H23.2405H23.2218H23.2032H23.1821H23.1656H23.1426H23.1279H23.1033H23.0899H23.0642H23.0517H23.0254H23.0132H22.9868H22.9746H22.9483H22.9358H22.9101H22.8967H22.8721H22.8574H22.8344H22.8179H22.7968H22.7782H22.7595H22.7383H22.7223H22.6982H22.6854H22.6579H22.6488H22.6173H22.6123H22.5766H22.5761H22.5401H22.5356H22.5043H22.4944H22.4687H22.4531H22.4334H22.4115H22.3982H22.3697H22.3633H22.3287H22.3277H22.2942H22.2855H22.26H22.2431H22.226H22.2006H22.1923H22.1588H22.1578H22.1255H22.1148H22.0924H22.0716H22.0596H22.0282H22.027H21.9946H21.9846H21.9625H21.9408H21.9306H21.8989H21.8968H21.8675H21.8526H21.8363H21.8082H21.8053H21.7746H21.7636H21.7441H21.7189H21.7139H21.6839H21.6739H21.6542H21.6287H21.6246H21.5954H21.5834H21.5663H21.5378H21.5375H21.509H21.4921H21.4807H21.4526H21.4462H21.4248H21.4001H21.3973H21.3699H21.3538H21.3429H21.316H21.3073H21.2895H21.2631H21.2606H21.2371H21.2137H21.2113H21.1857H21.1666H21.1604H21.1353H21.1194H21.1105H21.0859H21.072H21.0616H21.0376H21.0244H21.0138H20.9903H20.9766H20.967H20.944H20.9286H20.9212H20.8988H20.8804H20.8765H20.8545H20.8328H20.8321H20.8114H20.7902H20.7835H20.7693H20.7486H20.7348H20.7282H20.7081H20.6882H20.6859H20.6687H20.6493H20.6369H20.6303H20.6115H20.593H20.5876H20.5747H20.5568H20.5391H20.5382H20.5216H20.5045H20.4886H20.4876H20.471H20.4546H20.4388H20.4386H20.4228H20.4073H20.3921H20.3889H20.3771H20.3625H20.3481H20.3387H20.334H20.3202H20.3066H20.2934H20.2884H20.2804H20.2677H20.2553H20.2432H20.238H20.2313H20.2198H20.2085H20.1975H20.1873H20.1869H20.1765H20.1664H20.1565H20.147H20.1378H20.1365H20.1288H20.1202H20.1118H20.1038H20.096H20.0886H20.0855H20.0814H20.0745H20.068H20.0617H20.0557H20.05H20.0447H20.0396H20.0348H20.0343H20.0304H20.0262H20.0223H20.0188H20.0155H20.0126H20.01H20.0076H20.0056H20.0039H20.0025H20.0014H20.0006H20.0002H19.983H19.9315H19.8798H19.8279H19.7759H19.7237H19.6714H19.6189H19.5662H19.5134H19.4604H19.4072H19.3538H19.3004H19.2467H19.1929H19.1389H19.0848H19.0305H18.976H18.9214H18.8666H18.8117H18.7566H18.7014H18.646H18.5905H18.5348H18.4789H18.423H18.3668H18.3105H18.2541H18.1975H18.1407H18.0838H18.0268H17.9696H17.9123H17.8548H17.7972H17.7395H17.6816H17.6235H17.5653H17.507H17.4486H17.39H17.3312H17.2723H17.2133H17.1542H17.0949H17.0355H16.9759H16.9162H16.8564H16.7965H16.7364H16.6761H16.6158H16.5553H16.4947H16.434H16.3731H16.3121H16.251H16.1898H16.1284H16.0669H16.0053H15.9436H15.8817H15.8197H15.7576H15.6954H15.633H15.5706H15.508H15.4453H15.3825H15.3196H15.2565H15.1934H15.1301H15.0667H15.0032H14.9396H14.8759H14.812H14.7481H14.684H14.6198H14.5556H14.4912H14.4267H14.3621H14.2974H14.2326H14.1677H14.1027H14.0376H13.9724H13.907H13.8416H13.7761H13.7105H13.6448H13.5789H13.513H13.447H13.3809H13.3147H13.2484H13.182H13.1155H13.049H12.9823H12.9155H12.8487H12.7817H12.7147H12.6476H12.5804H12.5131H12.4457H12.3782H12.3107H12.243H12.1753H12.1075H12.0396H11.9717H11.9036H11.8355H11.7673H11.699H11.6306H11.5621H11.4936H11.425H11.3563H11.2876H11.2188H11.1499H11.0809H11.0118H10.9427H10.8735H10.8043H10.7349H10.6655H10.5961H10.5265H10.4569H10.3872H10.3175H10.2477H10.1778H10.1079H10.0379H9.96784H9.89772H9.82754H9.7573H9.687H9.61664H9.54622H9.47574H9.40521H9.33462H9.26397H9.19327H9.12251H9.0517H8.98084H8.90992H8.83895H8.76793H8.69687H8.62575H8.55458H8.48336H8.4121H8.34078H8.26943H8.19802H8.12657H8.05508H7.98354H7.91196H7.84034H7.76867H7.69697H7.62522H7.55343H7.48161H7.40974H7.33784H7.2659H7.19393H7.12192H7.04987H6.97779H6.90568H6.83353H6.76135H6.68914H6.6169H6.609C7.81258 7.32226 8.74006 6.27935 9.44326 5.2414C10.2668 4.02579 10.7858 2.81693 11.0992 1.91511C11.2565 1.46264 11.3636 1.08316 11.4321 0.812836C11.4663 0.677555 11.491 0.56925 11.5076 0.492405C11.5159 0.453972 11.5222 0.423372 11.5266 0.401163L11.5318 0.374201L11.5335 0.365561L11.534 0.362474L11.5343 0.36124C11.5344 0.360712 11.5344 0.360216 10.5507 0.180517C9.567 0.000818253 9.56708 0.000391006 9.56715 0L9.5649 0.011507C9.56255 0.0233555 9.55849 0.043293 9.55256 0.0707779C9.5407 0.125769 9.52139 0.210823 9.49331 0.321636C9.4371 0.543501 9.34613 0.86714 9.21011 1.25843C8.937 2.04411 8.48826 3.08524 7.78747 4.11963C6.40244 6.164 4.04617 8.18052 0 8.18052V10.1805Z" fill="white"/>\n</svg>\n'), {
      updateElements: function () {
        o().forEach((function (n) {
          if (void 0 === n.cursorProceeded) {
            var r = n.getAttribute(f), i = "v-cursor_".concat(r);
            n.addEventListener("mouseenter", (function () {
              t.cursor.classList.add(i), e.push(i)
            })), n.addEventListener("mouseleave", (function () {
              t.cursor.classList.remove(i)
            })), n.cursorProceeded = !0
          }
        }))
      }.bind(h), play: function () {
        o().length > 0 && t.changeProp({run: !0})
      }.bind(h), pause: function () {
        t.changeProp({run: !1})
      }.bind(h)
    }
  }()
}, function (t, e, n) {
  "use strict";

  function r(t) {
    const e = function (t) {
      if ("container" in t) return {width: t.container.clientWidth, height: t.container.clientHeight};
      return {width: t.width, height: t.height}
    }(t), n = function (t) {
      const {source: e} = t;
      if (e instanceof HTMLVideoElement) return {width: e.videoWidth, height: e.videoHeight};
      return {width: e.width, height: e.height}
    }(t);
    let r;
    return "cover" === t.rule ? r = function (t, e, n) {
      let r = e.width * i(t), o = n.height * r / n.width;
      o / i(t) < e.height && (o = e.height * i(t), r = n.width * o / n.height);
      const s = (e.width - r) / 2, a = (e.height - o) / 2;
      return {width: r, height: o, x: s, y: a}
    }(t, e, n) : "contain" === t.rule ? r = function (t, e, n) {
      let r = 0, o = 0;
      const s = n.width / n.height;
      e.width > e.height ? (o = e.height, r = o * s, r > e.width && (r = e.width, o = r / s)) : e.height >= e.width && (r = e.width, o = r / s, o > e.height && (o = e.height, r = o * s));
      r *= i(t), o *= i(t);
      const a = (e.width - r) / 2, c = (e.height - o) / 2;
      return {width: r, height: o, x: a, y: c}
    }(t, e, n) : "top-left" === t.rule ? r = function (t, e) {
      const n = e.width * i(t), r = e.height * i(t);
      return {width: n, height: r, x: 0, y: 0}
    }(t, n) : "top-right" === t.rule ? r = function (t, e, n) {
      const r = n.width * i(t), o = n.height * i(t), s = e.width - n.width;
      return {width: r, height: o, x: s, y: 0}
    }(t, e, n) : "bottom-left" === t.rule ? r = function (t, e, n) {
      const r = n.width * i(t), o = n.height * i(t), s = e.height - n.height;
      return {width: r, height: o, x: 0, y: s}
    }(t, e, n) : "bottom-right" === t.rule ? r = function (t, e, n) {
      const r = n.width * i(t), o = n.height * i(t), s = e.width - n.width, a = e.height - n.height;
      return {width: r, height: o, x: s, y: a}
    }(t, e, n) : "center" === t.rule && (r = function (t, e, n) {
      const r = n.width * i(t), o = n.height * i(t), s = (e.width - n.width) / 2, a = (e.height - n.height) / 2;
      return {width: r, height: o, x: s, y: a}
    }(t, e, n)), Object.assign(r, {sourceWidth: n.width, sourceHeight: n.height})
  }

  function i(t) {
    return void 0 !== t.scale ? t.scale : 1
  }

  n.d(e, "a", (function () {
    return r
  }))
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = c(n(15)), o = c(n(6)), s = c(n(33)), a = c(n(8));

  function c(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function l(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function u(t, e, n) {
    return u = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = p(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, u(t, e, n || t)
  }

  function h(t, e) {
    return h = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, h(t, e)
  }

  function f(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = p(t);
      if (e) {
        var i = p(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return d(this, n)
    }
  }

  function d(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function p(t) {
    return p = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, p(t)
  }

  var m = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && h(t, e)
    }(c, t);
    var e, n, r, i = f(c);

    function c(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, c), i.call(this, t)
    }

    return e = c, n = [{
      key: "_extra", value: function () {
        u(p(c.prototype), "_extra", this).call(this), this._settings = (0, o.default)(this.defaultSettings, this._responsiveProp._propInit), this._tickers(), this._timelines = [], this._timelinesCount = 0
      }
    }, {
      key: "_tickers", value: function () {
        this._absolute = 0, this._progress = 0, this._easing = 0, this._scope = 0, this._scopeEasing = 0, this._scopeLine = 0
      }
    }, {
      key: "defaultSettings", get: function () {
        return {line: [0, 1], scope: [0, 1], easing: this._vp.easing}
      }
    }, {
      key: "data", get: function () {
        var t = this._settings;
        return {
          a: this._absolute,
          p: this._progress,
          e: this._easing,
          s: this._scope,
          se: this._scopeEasing,
          scope: t.scope,
          line: t.line
        }
      }
    }, {
      key: "absolute", get: function () {
        return this._absolute
      }
    }, {
      key: "progress", get: function () {
        return this._progress
      }
    }, {
      key: "easing", get: function () {
        return this._easing
      }
    }, {
      key: "scope", get: function () {
        return this._scope
      }
    }, {
      key: "scopeEasing", get: function () {
        return this._scopeEasing
      }
    }, {
      key: "calc", value: function (t) {
        var e = this._settings, n = e.line, r = e.easing, i = e.scope;
        if (this._absolute = t, 0 === n[0] & 1 === n[1] ? this._progress = t : t < n[0] ? this._progress = 0 : t >= n[0] & t <= n[1] ? this._progress = (0, a.default)(t, n) : this._progress = 1, this._easing = "linear" === r ? this._progress : (0, s.default)(this._progress, r), this._scopeLine = Math.abs(i[0] - i[1]), this._scope = this._getScopeProgress(this._progress), this._scopeEasing = this._getScopeProgress(this._easing), this.lbt("progress", this.data), this._timelinesCount > 0) for (var o = 0; o < this._timelinesCount; o++) this._timelines[o].imitate(this._progress)
      }
    }, {
      key: "_getScopeProgress", value: function (t) {
        var e = this._settings.scope;
        return t = e[0] < e[1] ? e[0] + t * this._scopeLine : e[0] - t * this._scopeLine
      }
    }, {
      key: "imitate", value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._settings;
        this._settings = (0, o.default)(this.defaultSettings, e), this.calc(t)
      }
    }, {
      key: "addTimeline", value: function (t) {
        this._timelines.push(t), this._timelinesCount++
      }
    }, {
      key: "destroy", value: function () {
        u(p(c.prototype), "destroy", this).call(this), this._timelines.forEach((function (t) {
          t.destroy()
        }))
      }
    }], n && l(e.prototype, n), r && l(e, r), c
  }(i.default);
  e.default = m
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return o
  })), n.d(e, "b", (function () {
    return s
  }));
  var r = n(9), i = n(20);

  function o() {
    return Object(r.c)() instanceof HTMLHtmlElement ? null : i.a.app
  }

  function s() {
    return "IntersectionObserver" in window
  }
}, function (t, e, n) {
  "use strict";

  function r(t, e) {
    const [n, r, o, s] = e;
    if (n === r && o === s) return t;
    const a = [];
    for (let c = 0; c < 11; ++c) a[c] = i(.1 * c, n, o);
    return 0 === t ? 0 : 1 === t ? 1 : i(function (t, e, n) {
      const r = t[0], o = t[2];
      let s = 0, a = 1;
      for (; 10 !== a && n[a] <= e; ++a) s += .1;
      --a;
      const l = (e - n[a]) / (n[a + 1] - n[a]), u = s + .1 * l, h = c(u, r, o);
      if (h >= .001) return function (t, e, n, r) {
        for (let o = 0; o < 4; ++o) {
          const o = c(e, n, r);
          if (0 === o) return e;
          e -= (i(e, n, r) - t) / o
        }
        return e
      }(e, u, r, o);
      if (0 === h) return u;
      return function (t, e, n, r, o) {
        let s, a, c = 0;
        do {
          a = e + (n - e) / 2, s = i(a, r, o) - t, s > 0 ? n = a : e = a
        } while (Math.abs(s) > 1e-7 && ++c < 10);
        return a
      }(e, s, s + .1, r, o)
    }(e, t, a), r, s)
  }

  function i(t, e, n) {
    return ((o(e, n) * t + s(e, n)) * t + a(e)) * t
  }

  function o(t, e) {
    return 1 - 3 * e + 3 * t
  }

  function s(t, e) {
    return 3 * e - 6 * t
  }

  function a(t) {
    return 3 * t
  }

  function c(t, e, n) {
    return 3 * o(e, n) * t * t + 2 * s(e, n) * t + a(e)
  }

  var l;

  function u(t) {
    const e = 7.5625, n = 2.75;
    return t < 1 / n ? e * t * t : t < 2 / n ? e * (t -= 1.5 / n) * t + .75 : t < 2.5 / n ? e * (t -= 2.25 / n) * t + .9375 : e * (t -= 2.625 / n) * t + .984375
  }

  function h(t, e) {
    switch (e) {
      case l.easeInSine:
        return n = t, 1 - Math.cos(n * Math.PI / 2);
      case l.easeOutSine:
        return function (t) {
          return Math.sin(t * Math.PI / 2)
        }(t);
      case l.easeInOutSine:
        return function (t) {
          return -(Math.cos(Math.PI * t) - 1) / 2
        }(t);
      case l.easeInQuad:
        return function (t) {
          return Math.pow(t, 2)
        }(t);
      case l.easeOutQuad:
        return function (t) {
          return 1 - Math.pow(1 - t, 2)
        }(t);
      case l.easeInOutQuad:
        return function (t) {
          return t < .5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2
        }(t);
      case l.easeInCubic:
        return function (t) {
          return Math.pow(t, 3)
        }(t);
      case l.easeOutCubic:
        return function (t) {
          return 1 - Math.pow(1 - t, 3)
        }(t);
      case l.easeInOutCubic:
        return function (t) {
          return t < .5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2
        }(t);
      case l.easeInQuart:
        return function (t) {
          return Math.pow(t, 4)
        }(t);
      case l.easeOutQuart:
        return function (t) {
          return 1 - Math.pow(1 - t, 4)
        }(t);
      case l.easeInOutQuart:
        return function (t) {
          return t < .5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2
        }(t);
      case l.easeInQuint:
        return function (t) {
          return Math.pow(t, 5)
        }(t);
      case l.easeOutQuint:
        return function (t) {
          return 1 - Math.pow(1 - t, 5)
        }(t);
      case l.easeInOutQuint:
        return function (t) {
          return t < .5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2
        }(t);
      case l.easeInExpo:
        return function (t) {
          return 0 === t ? 0 : Math.pow(2, 10 * t - 10)
        }(t);
      case l.easeOutExpo:
        return function (t) {
          return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
        }(t);
      case l.easeInOutExpo:
        return function (t) {
          return 0 === t ? 0 : 1 === t ? 1 : t < .5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2
        }(t);
      case l.easeInCirc:
        return function (t) {
          return 1 - Math.sqrt(1 - Math.pow(t, 2))
        }(t);
      case l.easeOutCirc:
        return function (t) {
          return Math.sqrt(1 - Math.pow(t - 1, 2))
        }(t);
      case l.easeInOutCirc:
        return function (t) {
          return t < .5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2
        }(t);
      case l.easeInBack:
        return function (t) {
          return 2.70158 * t * t * t - 1.70158 * t * t
        }(t);
      case l.easeOutBack:
        return function (t) {
          const e = 1.70158;
          return 1 + 2.70158 * Math.pow(t - 1, 3) + e * Math.pow(t - 1, 2)
        }(t);
      case l.easeInOutBack:
        return function (t) {
          const e = 2.5949095;
          return t < .5 ? Math.pow(2 * t, 2) * (7.189819 * t - e) / 2 : (Math.pow(2 * t - 2, 2) * ((e + 1) * (2 * t - 2) + e) + 2) / 2
        }(t);
      case l.easeInElastic:
        return function (t) {
          const e = 2 * Math.PI / 3;
          return 0 === t ? 0 : 1 === t ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((10 * t - 10.75) * e)
        }(t);
      case l.easeOutElastic:
        return function (t) {
          const e = 2 * Math.PI / 3;
          return 0 === t ? 0 : 1 === t ? 1 : Math.pow(2, -10 * t) * Math.sin((10 * t - .75) * e) + 1
        }(t);
      case l.easeInOutElastic:
        return function (t) {
          const e = 2 * Math.PI / 4.5;
          return 0 === t ? 0 : 1 === t ? 1 : t < .5 ? -Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * e) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * e) / 2 + 1
        }(t);
      case l.easeInBounce:
        return function (t) {
          return 1 - u(1 - t)
        }(t);
      case l.easeOutBounce:
        return u(t);
      case l.easeInOutBounce:
        return function (t) {
          return t < .5 ? (1 - u(1 - 2 * t)) / 2 : (1 + u(2 * t - 1)) / 2
        }(t);
      default:
        return t
    }
    var n
  }

  function f(t, e = !1) {
    return e ? Array.isArray(e) ? r(t, e) : "function" == typeof e ? e(t) : h(t, e) : t
  }

  n.d(e, "a", (function () {
    return l
  })), n.d(e, "b", (function () {
    return f
  })), function (t) {
    t.easeInSine = "easeInSine", t.easeOutSine = "easeOutSine", t.easeInOutSine = "easeInOutSine", t.easeInQuad = "easeInQuad", t.easeOutQuad = "easeOutQuad", t.easeInOutQuad = "easeInOutQuad", t.easeInCubic = "easeInCubic", t.easeOutCubic = "easeOutCubic", t.easeInOutCubic = "easeInOutCubic", t.easeInQuart = "easeInQuart", t.easeOutQuart = "easeOutQuart", t.easeInOutQuart = "easeInOutQuart", t.easeInQuint = "easeInQuint", t.easeOutQuint = "easeOutQuint", t.easeInOutQuint = "easeInOutQuint", t.easeInExpo = "easeInExpo", t.easeOutExpo = "easeOutExpo", t.easeInOutExpo = "easeInOutExpo", t.easeInCirc = "easeInCirc", t.easeOutCirc = "easeOutCirc", t.easeInOutCirc = "easeInOutCirc", t.easeInBack = "easeInBack", t.easeOutBack = "easeOutBack", t.easeInOutBack = "easeInOutBack", t.easeInElastic = "easeInElastic", t.easeOutElastic = "easeOutElastic", t.easeInOutElastic = "easeInOutElastic", t.easeInBounce = "easeInBounce", t.easeOutBounce = "easeOutBounce", t.easeInOutBounce = "easeInOutBounce"
  }(l || (l = {}))
}, function (t) {
  var e = {}.toString;
  t.exports = Array.isArray || function (t) {
    return "[object Array]" == e.call(t)
  }
}, function (t, e) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var n = function (t) {
    return t instanceof HTMLElement
  };
  e.default = n
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  var i;

  function o(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function s(t, e) {
    return s = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, s(t, e)
  }

  function a(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = l(t);
      if (e) {
        var i = l(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return c(this, n)
    }
  }

  function c(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function l(t) {
    return l = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, l(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var u = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && s(t, e)
    }(c, t);
    var e, n, r, i = a(c);

    function c(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, c), i.call(this, t, !1)
    }

    return e = c, n = [{
      key: "init", value: function (t) {
        this._m = t, this._init()
      }
    }], n && o(e.prototype, n), r && o(e, r), c
  }(((i = n(15)) && i.__esModule ? i : {default: i}).default);
  e.default = u
}, function (t, e) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var n = function (t) {
    var e = 0, n = 0, r = 0, i = 0;
    return "detail" in t && (n = t.detail), "wheelDelta" in t && (n = -t.wheelDelta / 120), "wheelDeltaY" in t && (n = -t.wheelDeltaY / 120), "wheelDeltaX" in t && (e = -t.wheelDeltaX / 120), "axis" in t && t.axis === t.HORIZONTAL_AXIS && (e = n, n = 0), r = 10 * e, i = 10 * n, "deltaY" in t && (i = t.deltaY), "deltaX" in t && (r = t.deltaX), (r || i) && t.deltaMode && (1 == t.deltaMode ? (r *= 40, i *= 40) : (r *= 800, i *= 800)), r && !e && (e = r < 1 ? -1 : 1), i && !n && (n = i < 1 ? -1 : 1), {
      spinX: e,
      spinY: n,
      pixelX: r,
      pixelY: i
    }
  };
  e.default = n
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return o
  }));
  var r = n(2), i = n(21);

  class o extends i.b {
    constructor(t, e) {
      super(), this.textureID = void 0 !== e ? e : "tDiffuse", t instanceof r.ab ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = r.kb.clone(t.uniforms), this.material = new r.ab({
        defines: Object.assign({}, t.defines),
        uniforms: this.uniforms,
        vertexShader: t.vertexShader,
        fragmentShader: t.fragmentShader
      })), this.fsQuad = new i.a(this.material)
    }

    render(t, e, n) {
      this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t))
    }
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return i
  }));
  var r = n(2);

  function i() {
    return new r.Z
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "b", (function () {
    return s
  })), n.d(e, "a", (function () {
    return a
  }));
  var r = n(23), i = new (n.n(r).a), o = !1;

  function s() {
    o = !0, i.launchAll()
  }

  function a(t) {
    var e = !1;
    return o ? t() : e = i.on("", (function () {
      t()
    })), {
      destroy: function () {
        e && i.remove(e)
      }
    }
  }
}, function (t) {
  t.exports = function (t, e, n) {
    return t * (1 - n) + e * n
  }
}, function (t, e, n) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var r = o(n(74)), i = o(n(40));

  function o(t) {
    return t && t.__esModule ? t : {default: t}
  }

  var s = function (t) {
    return !(!(0, r.default)(t) && !(0, i.default)(t))
  };
  e.default = s
}, function (t, e, n) {
  "use strict";
  var r, i = n(23), o = (r = new (n.n(i).a), {
    launchCallbacks: function () {
      r.launchAll()
    }, add: function (t) {
      var e = r.on("", (function () {
        t()
      }));
      return {
        destroy: function () {
          r.remove(e)
        }
      }
    }
  });
  e.a = o
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return s
  }));
  var r = n(16), i = n(0), o = n(37);

  function s(t, e, n) {
    var s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .001, a = !1, c = !1;
    if (Object(o.b)()) {
      var l = {root: Object(o.a)(), rootMargin: "0px", threshold: s};
      (c = new IntersectionObserver(u.bind(this), l)).observe(t)
    } else a = Object(r.a)(h.bind(this), !0);

    function u(t) {
      t.forEach((function (t) {
        t.isIntersecting ? e() : n()
      }))
    }

    function h() {
      var r = t.getBoundingClientRect(), o = i.a.viewport.size;
      r.bottom <= 0 || r.right <= 0 || r.top >= o[1] || r.left >= o[0] ? n() : e()
    }

    function f() {
      a && a.destroy(), c && c.disconnect()
    }

    return {destroy: f.bind(this)}
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "b", (function () {
    return o
  })), n.d(e, "a", (function () {
    return s
  }));
  var r = "v-viewed", i = ["v-view", r, "v-view_b", "v-view_a"];

  function o(t) {
    i.forEach((function (e) {
      t.classList.remove(e)
    })), t.querySelectorAll("*").forEach((function (t) {
      i.forEach((function (e) {
        t.classList.remove(e)
      }))
    }))
  }

  function s(t, e) {
    var n = t;
    if (n.classList.contains(r)) e(); else if ("function" == typeof n["v-view-callback"]) {
      var i = n["v-view-callback"];
      n["v-view-callback"] = function () {
        e(), i()
      }
    } else n["v-view-callback"] = function () {
      e()
    }
  }
}, function (t, e, n) {
  "use strict";
  var r = n(3), i = n(2), o = n(8), s = n.n(o), a = n(10), c = n.n(a), l = n(1), u = n(0), h = n(12), f = n(19),
    d = n(7), p = {duration: 500, step: 1, amp: 10, sine: .5};

  function m(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function v(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function g(t, e, n) {
    return g = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = x(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, g(t, e, n || t)
  }

  function y(t, e) {
    return y = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, y(t, e)
  }

  function _(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = x(t);
      if (e) {
        var i = x(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return b(this, n)
    }
  }

  function b(t, e) {
    if (e && ("object" === w(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function x(t) {
    return x = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, x(t)
  }

  function w(t) {
    return w = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, w(t)
  }

  var S = function (t, e, n, r) {
    var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
    if ("object" === ("undefined" == typeof Reflect ? "undefined" : w(Reflect)) && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--) (i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s);
    return o > 3 && s && Object.defineProperty(e, n, s), s
  }, M = "interactive-button", E = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && y(t, e)
    }(a, t);
    var e, n, r, o = _(a);

    function a() {
      var t, e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      return m(this, a), (t = o.call(this))._constructorHTML = e, t.classNames = "", t.type = "button", t.buttonType = "button", t._button = !1, t._listeners = [], t._viewportEvent = !1, t._hoverProgress = 0, t._timelineHover = !1, t._disabledProgress = 0, t._timelineDisabled = !1, t._mutationObserver = !1, t
    }

    return e = a, n = [{
      key: "createRenderRoot", value: function () {
        return this._html = this.innerHTML, this
      }
    }, {
      key: "_connectedCallback", value: function () {
        g(x(a.prototype), "_connectedCallback", this).call(this), this.classList.add(M), this._create()
      }
    }, {
      key: "_disconnectedCallback", value: function () {
        g(x(a.prototype), "_disconnectedCallback", this).call(this), this._destroy()
      }
    }, {
      key: "_create", value: function () {
        var t = this;
        this.innerHTML = "";
        var e = this._constructorHTML ? this._constructorHTML : this._html;
        this._html = e, this._button = Object(l.b)(this.type, {
          html: '\n                <span class="'.concat(M, '__outer">\n                    <span>').concat(e, '</span>\n                </span>\n                <span class="').concat(M, '__outer">\n                    <span>').concat(e, "</span>\n                </span>\n                "),
          parent: this,
          class: this.classNames
        }), "button" === this.type && this._button.setAttribute("type", this.buttonType), this.download && this._button.setAttribute("download", ""), this.href && this._button.setAttribute("href", this.href), this._ctx2d = new f.a(this._button), this._button.appendChild(this._ctx2d.canvas), this._hoverProgress = 0;
        var n = new c.a;
        n.on("progress", (function (e) {
          t._hoverProgress = e.e, t._render()
        })), this._timelineHover = n, this._disabledProgress = 0;
        var r = new c.a;
        r.on("progress", (function (e) {
          t._disabledProgress = e.e, t._render()
        })), this._timelineDisabled = r, this.resize();
        var i = u.a.vevetPage;
        i && i.onPageShown((function () {
          t.resize()
        })), this._viewportEvent = u.a.viewport.on("", (function () {
          t.resize()
        }), {name: M}), this._listeners.push(Object(l.a)(this, "click", this._handleClick.bind(this))), this._listeners.push(Object(l.a)(this, "mouseenter", this._toggleAnimation.bind(this, !0))), this._listeners.push(Object(l.a)(this, "mouseleave", this._toggleAnimation.bind(this, !1)));
        var o = new MutationObserver((function (e) {
          t._handleMutatonObserver(e)
        }));
        this._mutationObserver = o, o.observe(this, {attributes: !0})
      }
    }, {
      key: "_destroy", value: function () {
        this._timelineHover && this._timelineHover.destroy(), this._timelineDisabled && this._timelineDisabled.destroy(), this._button && this._button.remove(), this._viewportEvent && (u.a.viewport.remove(this._viewportEvent), this._viewportEvent = !1), this._listeners.forEach((function (t) {
          t.remove()
        })), this._listeners = [], this._mutationObserver && (this._mutationObserver.disconnect(), this._mutationObserver = !1), this.innerHTML = this._html
      }
    }, {
      key: "_handleClick", value: function (t) {
        "a" === this.type && this.useAjax && (t.preventDefault(), d.a.load({link: this.href}))
      }
    }, {
      key: "_handleMutatonObserver", value: function (t) {
        var e = this, n = this._timelineDisabled;
        n && t.forEach((function () {
          e.classList.contains("disabled") ? n.reversed && n.reverse() : n.reversed || n.reverse(), n.play({duration: p.duration})
        }))
      }
    }, {
      key: "_toggleAnimation", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        if (!u.a.viewport.mobiledevice && !this.classList.contains("disabled")) {
          t ? this._button && this._button.classList.add("hover") : this._button && this._button.classList.remove("hover");
          var e = this._timelineHover;
          e && (e.pause(), t ? e.reversed && e.reverse() : e.reversed || e.reverse(), e.play({duration: p.duration}))
        }
      }
    }, {
      key: "resize", value: function () {
        this._ctx2d.updateSize(), this._render()
      }
    }, {
      key: "_updateThings", value: function () {
        this.resize()
      }
    }, {
      key: "_render", value: function () {
        var t = this._ctx2d, e = t.ctx, n = t.width, r = t.height, o = t.dpr, a = this._hoverProgress, c = p.step * o,
          l = p.amp * o;
        e.save(), e.clearRect(0, 0, n, r);
        var u = (r + 2 * l) * (1 - a) - l,
          h = (new i.i).lerpColors(new i.i(this.hoverColor), new i.i(this.disabledColor), this._disabledProgress);
        e.beginPath(), e.moveTo(-c, u);
        for (var f = [], d = -c; d <= n + c; d += c) {
          var m = Math.abs(s()(d, [n / 2, n])), v = 1 - Math.cos(Math.PI * p.sine * m), g = u + v * l;
          e.lineTo(d, g), f.push(v)
        }
        e.lineTo(n, u), e.lineTo(n, r), e.lineTo(0, r), e.lineTo(-c, u), e.clip(), e.fillStyle = "#".concat(h.getHexString()), e.fillRect(0, 0, n, r), e.closePath(), e.restore()
      }
    }, {
      key: "hoverColor", get: function () {
        return this.classNames.includes("grey") ? "#ffffff" : this.classNames.includes("highlight") ? "#222222" : "#C24040"
      }
    }, {
      key: "disabledColor", get: function () {
        return "#181818"
      }
    }], n && v(e.prototype, n), r && v(e, r), a
  }(h.a);
  S([Object(r.c)({attribute: "class-names"})], E.prototype, "classNames", void 0), S([Object(r.c)({attribute: "type"})], E.prototype, "type", void 0), S([Object(r.c)({attribute: "button-type"})], E.prototype, "buttonType", void 0), S([Object(r.c)({
    attribute: "download",
    type: "boolean"
  })], E.prototype, "download", void 0), S([Object(r.c)({attribute: "href"})], E.prototype, "href", void 0), S([Object(r.c)({attribute: "use-ajax"})], E.prototype, "useAjax", void 0), E = S([Object(r.b)(M)], E);
  e.a = E
}, function (t, e, n) {
  "use strict";
  var r = n(1);
  e.a = function () {
    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "data-preload-in-preloader",
      e = Object(r.f)("*[".concat(t, "]")), n = e.length;
    if (0 === n) return 1;
    var i = 0, o = 0;
    return e.forEach((function (t) {
      "number" == typeof t.loadProgress && (i += t.loadProgress / n, 1 === t.loadProgress && o++)
    })), o === e.length && (i = 1), i
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return i
  }));
  var r = n(2);

  function i() {
    var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
      e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 800,
      n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
      i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e4, o = h(), s = u(), a = n, c = i,
      l = new r.O(s, o, a, c);

    function u() {
      return 2 * Math.atan(d() / 2 / e) * 180 / Math.PI
    }

    function h() {
      return f() / d()
    }

    function f() {
      return t ? t.clientWidth : window.innerWidth
    }

    function d() {
      return t ? t.clientHeight : window.innerHeight
    }

    function p() {
      l.fov = u(), l.aspect = h(), l.updateProjectionMatrix()
    }

    function m() {
    }

    return l.position.set(0, 0, e), p(), {camera: l, resize: p.bind(this), destroy: m.bind(this)}
  }
}, function (t) {
  t.exports = function (t) {
    t = t || {};
    var e = document.createElement(t.selector);
    if (t.attr) for (var n in t.attr) t.attr.hasOwnProperty(n) && e.setAttribute(n, t.attr[n]);
    return "a" == t.selector && t.link && (e.href = t.link, t.target && e.setAttribute("target", t.target)), "img" == t.selector && t.src && (e.src = t.src, t.lazyload && (e.style.opacity = 0, e.onload = function () {
      e.style.opacity = 1
    })), t.id && (e.id = t.id), t.styles && (e.className = t.styles), t.html && (e.innerHTML = t.html), t.children && e.appendChild(t.children), e
  }
}, function (t, e, n) {
  "use strict";
  var r = n(3), i = n(8), o = n.n(i), s = n(1), a = n(0), c = n(12), l = n(13), u = n(5), h = n(4),
    f = {ease: .1, move: .5, friction: .5};
  if (h.b) {
    var d = h.b.addFolder("sticky mouse element");
    d.add(f, "ease", h.a, .2, h.a), d.add(f, "move", h.a, 1, h.a), d.add(f, "friction", 0, .9, h.a)
  }

  function p(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function m(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function v(t, e, n) {
    return v = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = b(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, v(t, e, n || t)
  }

  function g(t, e) {
    return g = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, g(t, e)
  }

  function y(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = b(t);
      if (e) {
        var i = b(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return _(this, n)
    }
  }

  function _(t, e) {
    if (e && ("object" === x(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function b(t) {
    return b = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, b(t)
  }

  function x(t) {
    return x = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, x(t)
  }

  var w = function (t, e, n, r) {
    var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
    if ("object" === ("undefined" == typeof Reflect ? "undefined" : x(Reflect)) && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--) (i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s);
    return o > 3 && s && Object.defineProperty(e, n, s), s
  }, S = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && g(t, e)
    }(c, t);
    var e, n, r, i = y(c);

    function c() {
      var t;
      return p(this, c), (t = i.apply(this, arguments)).noAppend = !1, t._isHovered = !1, t._outer = !1, t._mouseCoords = {
        x: 0,
        y: 0
      }, t._currentProgress = {x: 0, y: 0}, t._coords = {x: 0, y: 0}, t._targetProgress = {
        x: 0,
        y: 0
      }, t._listeners = [], t._renderEvent = !1, t._friction = !1, t.useChildCoords = !1, t.handleMouseMove = !1, t
    }

    return e = c, n = [{
      key: "mouseCoords", get: function () {
        return this._mouseCoords
      }
    }, {
      key: "currentProgress", get: function () {
        return this._currentProgress
      }
    }, {
      key: "coords", get: function () {
        return this._coords
      }
    }, {
      key: "targetProgress", get: function () {
        return this._targetProgress
      }
    }, {
      key: "friction", get: function () {
        return 0 === this._friction || this._friction ? this._friction : f.friction
      }, set: function (t) {
        this._friction = t
      }
    }, {
      key: "createRenderRoot", value: function () {
        return this
      }
    }, {
      key: "_connectedCallback", value: function () {
        v(b(c.prototype), "_connectedCallback", this).call(this), a.a.viewport.mobiledevice || this._create()
      }
    }, {
      key: "disconnectedCallback", value: function () {
        v(b(c.prototype), "disconnectedCallback", this).call(this), this._destroy()
      }
    }, {
      key: "_create", value: function () {
        var t = this;
        if (this.noAppend) this._outer = this.children[0]; else {
          for (this._outer = Object(s.b)("div"); this.firstChild;) this._outer.appendChild(this.firstChild);
          this.appendChild(this._outer)
        }
        this._listeners.push(Object(s.a)(this._outer, "mouseenter", (function () {
          t._isHovered = !0, t._setRenderEvent()
        }))), this._listeners.push(Object(s.a)(this, "mousemove", (function (e) {
          if (t._isHovered) {
            var n = t.getBoundingClientRect();
            t._mouseCoords = {
              x: e.clientX - n.left,
              y: e.clientY - n.top
            }, t.handleMouseMove && t.handleMouseMove(t._mouseCoords.x, t._mouseCoords.y), t._setRenderEvent()
          }
        }))), this._listeners.push(Object(s.a)(this, "mouseleave", (function () {
          if (t._isHovered) {
            var e = t.getBoundingClientRect();
            t._mouseCoords = {x: e.width / 2, y: e.height / 2}, t._setRenderEvent(), t._isHovered = !1
          }
        })))
      }
    }, {
      key: "_destroy", value: function () {
        if (this._outer) {
          if (!this.noAppend) {
            for (; this._outer.firstChild;) this.appendChild(this._outer.firstChild);
            this._outer.remove(), this._outer = !1
          }
          this._listeners.forEach((function (t) {
            t.remove()
          })), this._listeners = [], this._removeRenderEvent()
        }
      }
    }, {
      key: "_render", value: function () {
        if (this._outer) {
          var t = this._outer, e = f.ease, n = f.move, r = this.getBoundingClientRect(),
            i = o()(this._mouseCoords.x, [r.width / 2, r.width]);
          i = this._normalizeProgress(Object(l.b)(i, [-1, 1]));
          var s = o()(this._mouseCoords.y, [r.height / 2, r.height]);
          s = this._normalizeProgress(Object(l.b)(s, [-1, 1])), this._targetProgress = {
            x: i,
            y: s
          }, this._currentProgress.x = Object(l.a)(this._currentProgress.x, this._targetProgress.x, e), this._currentProgress.y = Object(l.a)(this._currentProgress.y, this._targetProgress.y, e), this._currentProgress.x === this._targetProgress.x && this._currentProgress.x === this._targetProgress.x && this._removeRenderEvent();
          var a = this._currentProgress.x * n * r.width, c = this._currentProgress.y * n * r.height;
          this.useChildCoords && (a -= t.clientWidth / 2 * this._currentProgress.x, c -= t.clientHeight / 2 * this._currentProgress.y), this._coords = {
            x: a,
            y: c
          }, t.style.transform = "translate(".concat(a, "px, ").concat(c, "px)")
        }
      }
    }, {
      key: "_normalizeProgress", value: function (t) {
        var e = t < 0 ? -1 : 1;
        return (Math.abs(t) - Math.abs(t) * this.friction) * e
      }
    }, {
      key: "_setRenderEvent", value: function () {
        var t = this;
        a.a.viewport.mobiledevice || this._renderEvent || (this._renderEvent = u.a.on("prerender", (function () {
          t._render()
        })))
      }
    }, {
      key: "_removeRenderEvent", value: function () {
        this._renderEvent && (u.a.remove(this._renderEvent), this._renderEvent = !1)
      }
    }], n && m(e.prototype, n), r && m(e, r), c
  }(c.a);
  w([Object(r.c)({attribute: "no-append"})], S.prototype, "noAppend", void 0), w([Object(r.c)({attribute: "use-child-coords"})], S.prototype, "useChildCoords", void 0), w([Object(r.c)()], S.prototype, "handleMouseMove", void 0), S = w([Object(r.b)("sticky-mouse-el")], S);
  e.a = S
}, function (t, e, n) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var r = o(n(47)), i = o(n(40));

  function o(t) {
    return t && t.__esModule ? t : {default: t}
  }

  var s = function t(e) {
    var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return (0, r.default)(e) ? e : "string" == typeof e ? n ? (n = t(n), (0, i.default)(n) ? n.querySelector(e) : null) : document.querySelector(e) : null
  };
  e.default = s
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = s(n(15)), o = s(n(6));

  function s(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function a(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function c(t, e, n) {
    return c = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = f(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, c(t, e, n || t)
  }

  function l(t, e) {
    return l = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, l(t, e)
  }

  function u(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = f(t);
      if (e) {
        var i = f(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return h(this, n)
    }
  }

  function h(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function f(t) {
    return f = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, f(t)
  }

  var d = n(25), p = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && l(t, e)
    }(s, t);
    var e, n, r, i = u(s);

    function s(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, s), i.call(this, t)
    }

    return e = s, n = [{
      key: "defaultProp", get: function () {
        return (0, o.default)(c(f(s.prototype), "defaultProp", this), {
          on: !0,
          outer: "",
          min: 100,
          momentum: !1,
          momentumStopThreshold: .01,
          friction: .95,
          thresholdPropagation: !1,
          preventDefault: !1,
          stopPropagation: !1
        })
      }
    }, {
      key: "_extra", value: function () {
        c(f(s.prototype), "_extra", this).call(this), this._start = {x: 0, y: 0}, this._global = {
          x: 0,
          y: 0
        }, this._prev = {x: 0, y: 0}, this._diff = {
          x: 0,
          y: 0
        }, this._dragging = !1, this._prevent = !1, this._decelerating = !1, this._deceleration = {
          x: 0,
          y: 0
        }, this._pointerID = !1, this._trackingPoints = [], this._runningListeners = [], this._getElements()
      }
    }, {
      key: "_getElements", value: function () {
        this._outer = d.one(this._prop.outer)
      }
    }, {
      key: "_changeProp", value: function () {
        this.removeEventListeners(), this._getElements(), this._setEvents()
      }
    }, {
      key: "_setEvents", value: function () {
        this._prop.on && this._setStartEvents()
      }
    }, {
      key: "_setStartEvents", value: function () {
        this.listener(this._outer, "mousedown", this._onStart.bind(this)), this.listener(this._outer, "touchstart", this._onStart.bind(this))
      }
    }, {
      key: "_addRunningEvents", value: function () {
        this._removeRunningEvents();
        var t = this._runningListeners, e = this._outer;
        t.push(this.listener(e, "touchmove", this._onMove.bind(this), {passive: !1})), t.push(this.listener(e, "touchend", this._onEnd.bind(this), {passive: !1})), t.push(this.listener(e, "touchcancel", this._onStop.bind(this), {passive: !1})), t.push(this.listener(window, "mousemove", this._onMove.bind(this), {passive: !1})), t.push(this.listener(window, "mouseup", this._onEnd.bind(this), {passive: !1})), t.push(this.listener(window, "blur", this._onStop.bind(this), {passive: !1}))
      }
    }, {
      key: "_removeRunningEvents", value: function () {
        var t = this;
        this._runningListeners.forEach((function (e) {
          t.removeEventListener({id: e.id, el: e.el})
        })), this._runningListeners = []
      }
    }, {
      key: "_onStart", value: function (t) {
        var e = this._normalizeEvent(t);
        if (this._prop.preventDefault && t.preventDefault(), this._prop.stopPropagation && t.stopPropagation(), !this._dragging) {
          if ("mousedown" == t.type) {
            if (1 != t.which) return;
            t.stopPropagation()
          }
          this._dragging = !0, this._decelerating = !1, this._prevent = !1, this._pointerID = e.id, this._diff.x = 0, this._diff.y = 0, this._global.x = this._prev.x = this._start.x = e.x, this._global.y = this._prev.y = this._start.y = e.y, this._trackingPoints = [], this._addTrackingPoint(e.x, e.y), this._addRunningEvents(), this._callEvents("start")
        }
      }
    }, {
      key: "_onMove", value: function (t) {
        this._prop.preventDefault && t.preventDefault(), this._prop.stopPropagation && t.stopPropagation();
        var e = this._normalizeEvent(t);
        if (this._dragging && e.id === this._pointerID) {
          this._diff.x += Math.abs(e.x - this._global.x);
          var n = this._diff.x;
          this._diff.y += Math.abs(e.y - this._global.y);
          var r = this._diff.y;
          this._global.x = e.x, this._global.y = e.y;
          var i = this._prop.thresholdPropagation;
          if (i) {
            var o = i.value;
            if (!("x" == i.dir & n > o & n > r || "y" == i.dir & r > o & r > n)) return this._start.x = e.x, void(this._start.y = e.y);
            t.stopPropagation(), t.preventDefault(), this._prevent = !0
          }
          this._addTrackingPoint(this._prev.x, this._prev.y), this._callEvents("move")
        }
      }
    }, {
      key: "_onEnd", value: function (t) {
        this._prop.preventDefault && t.preventDefault(), this._prop.stopPropagation && t.stopPropagation();
        var e = this._normalizeEvent(t);
        this._dragging && e.id === this._pointerID && (this.stopDrag(!1), this._prop.momentum ? this._startDeceleration() : this._callEvents("end"))
      }
    }, {
      key: "_onStop", value: function () {
        this._dragging && this.stopDrag()
      }
    }, {
      key: "stopDrag", value: function () {
        var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
        this._dragging = !1, this._decelerating = !1, this._prevent = !1, this._removeRunningEvents(), t && this._callEvents("end")
      }
    }, {
      key: "_normalizeEvent", value: function (t) {
        if ("touchmove" === t.type || "touchstart" === t.type || "touchend" === t.type) {
          var e = t.targetTouches[0] || t.changedTouches[0];
          return {x: e.clientX, y: e.clientY, id: e.identifier}
        }
        return {x: t.clientX, y: t.clientY, id: null}
      }
    }, {
      key: "_addTrackingPoint", value: function (t, e) {
        for (var n = Date.now(), r = this._trackingPoints; r.length > 0 && !(n - r[0].time <= 100);) r.shift();
        r.push({x: t, y: e, time: n}), this._trackingPoints = r
      }
    }, {
      key: "_startDeceleration", value: function () {
        var t = this._trackingPoints, e = t[0], n = t[t.length - 1], r = n.x - e.x, i = n.y - e.y,
          o = (n.time - e.time) / 35, s = this._deceleration;
        s.x = r / o || 0, s.y = i / o || 0, Math.abs(s.x) > 1 || Math.abs(s.y) > 1 ? (this._decelerating = !0, window.requestAnimationFrame(this._decelerationAnim.bind(this))) : this.stopDrag()
      }
    }, {
      key: "_decelerationAnim", value: function () {
        if (this._decelerating) {
          var t = this._prop.momentumStopThreshold, e = this._prop.friction;
          this._deceleration.x *= e;
          var n = this._deceleration.x;
          this._deceleration.y *= e;
          var r = this._deceleration.y;
          this._global.x += n, this._global.y += r, this._callEvents("move"), Math.abs(n) > t & Math.abs(r) > t ? window.requestAnimationFrame(this._decelerationAnim.bind(this)) : this.stopDrag()
        }
      }
    }, {
      key: "_callEvents", value: function (t) {
        var e = this._calcCoords();
        "start" == t ? this.lbt("start", e) : "move" == t ? this.lbt("move", e) : (this.lbt("end", e), this._callOnceEvents(e)), this._prev.x = this._global.x, this._prev.y = this._global.y
      }
    }, {
      key: "_callOnceEvents", value: function (t) {
        var e = t.global, n = this._start.x, r = this._start.y, i = this._prop.min;
        n > e.x && Math.abs(n - e.x) > Math.abs(i) && this.lbt("left"), n < e.x && Math.abs(n - e.x) > Math.abs(i) && this.lbt("right"), r > e.y && Math.abs(r - e.y) > Math.abs(i) && this.lbt("up"), r < e.y && Math.abs(r - e.y) > Math.abs(i) && this.lbt("down")
      }
    }, {
      key: "_calcCoords", value: function () {
        var t = this._outer, e = this._global, n = {top: 0, left: 0}, r = {x: 0, y: 0}, i = {x: 0, y: 0},
          o = {x: 0, y: 0};
        return t instanceof Window || t instanceof Document ? (r.x = e.x, r.y = e.y) : (n = t.getBoundingClientRect(), r.x = e.x - n.left, r.y = e.y - n.top), i.x = r.x - (this._start.x - n.left), i.y = r.y - (this._start.y - n.top), o.x = e.x - this._prev.x, o.y = e.y - this._prev.y, {
          global: e,
          inner: r,
          diff: i,
          step: o
        }
      }
    }], n && a(e.prototype, n), r && a(e, r), s
  }(i.default);
  e.default = p
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return o
  }));
  var r = n(0), i = n(13);

  function o() {
    return r.a.viewport.mobiledevice ? Object(i.b)(r.a.viewport.dprMobile, [0, 1.75]) : "safari" === r.a.browser ? 1.25 : 1.5
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "b", (function () {
    return o
  })), n.d(e, "a", (function () {
    return s
  }));
  var r = n(8), i = n.n(r);

  function o(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 40, n = t.gamma;
    n < -1 * e ? n = -1 * e : n > e && (n = e);
    var r = 0;
    return n < 0 ? r = -1 * (1 - i()(n, [-e, 0])) : n > 0 && (r = i()(n, [0, e])), r
  }

  function s(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 40, n = t.beta;
    n < -1 * e ? n = -1 * e : n > e && (n = e);
    var r = 0;
    return n < 0 ? r = -1 * (1 - i()(n, [-e, 0])) : n > 0 && (r = i()(n, [0, e])), r
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return r
  }));
  var r = {
    uniforms: {tDiffuse: {value: null}, opacity: {value: 1}},
    vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader: "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\t\t}"
  }
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = a(n(15)), o = a(n(6)), s = a(n(121));

  function a(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function c(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function l(t, e, n) {
    return l = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = d(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, l(t, e, n || t)
  }

  function u(t, e) {
    return u = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, u(t, e)
  }

  function h(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = d(t);
      if (e) {
        var i = d(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return f(this, n)
    }
  }

  function f(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function d(t) {
    return d = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, d(t)
  }

  var p = n(25), m = n(54), v = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && u(t, e)
    }(a, t);
    var e, n, r, i = h(a);

    function a(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, a), i.call(this, t)
    }

    return e = a, (n = [{
      key: "prefix", get: function () {
        return "".concat(this._v.prefix, "text-split")
      }
    }, {
      key: "defaultProp", get: function () {
        return (0, o.default)(l(d(a.prototype), "defaultProp", this), {
          selector: ".".concat(this._prefix),
          resizeTimeout: 0,
          appendLetters: !0,
          appendWords: !0,
          appendLines: !1
        })
      }
    }, {
      key: "letters", get: function () {
        return this._el.letters
      }
    }, {
      key: "words", get: function () {
        return this._el.words
      }
    }, {
      key: "lines", get: function () {
        return this._el.lines
      }
    }, {
      key: "elements", get: function () {
        return this._el
      }
    }, {
      key: "outer", get: function () {
        return this._outer
      }
    }, {
      key: "_extra", value: function () {
        l(d(a.prototype), "_extra", this).call(this), this._outer = p.one(this._prop.selector);
        var t = this._outer;
        t.classList.add("".concat(this._prefix)), this._text = t.innerText, 0 == this._text.length && (this._text = t.textContent), this._text = this._text.replace(/\s+\n/gm, "\n"), this._html = t.innerHTML, this._splitBool = !1, this._el = {
          letters: [],
          words: [],
          lines: []
        }, this.split()
      }
    }, {
      key: "_setEvents", value: function () {
        var t = this;
        l(d(a.prototype), "_setEvents", this).call(this), this.addEvent("viewport", {
          target: "w_",
          name: this.name,
          do: function () {
            t._resize()
          }
        })
      }
    }, {
      key: "_resize", value: function () {
        var t = this;
        setTimeout((function () {
          t._resizeFunc()
        }), this._prop.resizeTimeout)
      }
    }, {
      key: "_resizeFunc", value: function () {
        this.split(), this.lbt("resize")
      }
    }, {
      key: "split", value: function () {
        var t = this._prop;
        this._outer.classList.add("".concat(this._prefix, "_splitting")), this._splitBool || (this._wordsSplit(), this._lettersSplit(), this._outer.innerHTML = "", this._lettersAppend(), this._wordsAppend()), this._splitBool && this._linesRemove(), t.appendLines || this._splitBool || this._appendSpaces(), t.appendLines ? (this._appendSpaces(), this._linesSplit(), this._removeBr(), this._linesAppend(), this._appendSpaces()) : this._linesSplit(), this._splitBool = !0, this._outer.classList.remove("".concat(this._prefix, "_splitting")), this.lbt("split", this._el)
      }
    }, {
      key: "_wordsSplit", value: function () {
        var t = this, e = this._text.split(""), n = [], r = [], i = 0;
        e.forEach((function (t) {
          var o = !1, s = !1, a = t.charCodeAt(0), c = !1, l = i == e.length - 1;
          32 === a || 160 === a ? o = !0 : 10 === a && (s = !0), (s || o || l) && (c = !0, l && r.push(t)), c ? (r.length > 0 && n.push({
            el: !1,
            children: r,
            newline: s,
            content: r.join(""),
            type: "word"
          }), r = []) : r.push(t), i++
        })), this._prop.appendWords && n.forEach((function (e) {
          e.el = m({
            selector: "span",
            styles: "".concat(t._prefix, "__word")
          }), e.el.classList.add(), t._prop.appendLetters || (e.el.innerHTML = e.content)
        })), this._el.words = n
      }
    }, {
      key: "_wordsAppend", value: function () {
        var t = this;
        this._prop.appendWords && this._el.words.forEach((function (e) {
          t._outer.appendChild(e.el)
        }))
      }
    }, {
      key: "_lettersSplit", value: function () {
        var t = this;
        this._el.words.forEach((function (e) {
          var n = e.children, r = [], i = 0;
          n.forEach((function (o) {
            var s = i == n.length - 1,
              a = {el: !1, content: o, whitespace: s, newline: !(!s || !e.newline), type: "letter"};
            t._prop.appendLetters && (a.el = m({
              selector: "span",
              styles: "".concat(t._prefix, "__letter")
            }), a.el.innerHTML = o), r.push(a), t._el.letters.push(a), i++
          })), e.children = r
        }))
      }
    }, {
      key: "_lettersAppend", value: function () {
        var t = this;
        this._prop.appendLetters && (this._prop.appendWords ? this._el.words.forEach((function (t) {
          t.children.forEach((function (e) {
            t.el.appendChild(e.el)
          }))
        })) : this._prop.appendWords || this._el.letters.forEach((function (e) {
          t._outer.appendChild(e.el)
        })))
      }
    }, {
      key: "_appendSpaces", value: function () {
        var t = this._prop, e = this._el;
        t.appendWords ? this._appendSpacesType(e.words) : t.appendLetters && this._appendSpacesType(e.letters)
      }
    }, {
      key: "_appendSpacesType", value: function (t) {
        t.forEach((function (t) {
          var e = !1;
          if (("word" == t.type || t.whitespace) && (e = !0), e && (e = document.createTextNode(" "), (0, s.default)(e, t.el)), t.newline) {
            var n = m({selector: "br"});
            (0, s.default)(n, t.el)
          }
        }))
      }
    }, {
      key: "_removeBr", value: function () {
        this._outer.querySelectorAll("br").forEach((function (t) {
          t.remove()
        }))
      }
    }, {
      key: "_linesSplit", value: function () {
        var t = this, e = this._prop, n = [];
        e.appendWords ? n = this._el.words : e.appendLetters && (n = this._el.letters);
        for (var r = [], i = [], o = 0, s = !1, a = 0; a < n.length; a++) {
          var c = n[a], l = c.el.offsetTop;
          s = l !== o, o = l, s & i.length > 0 && (r.push(i), i = []), i.push(c)
        }
        r.push(i);
        var u = this._el.lines;
        r.forEach((function (n) {
          var r = {el: !1, children: n, content: "", type: "line"};
          n.forEach((function (t) {
            r.content += t.content, ("word" == t.type || t.whitespace) && (r.content += " ")
          })), e.appendLines && (r.el = m({selector: "span", styles: "".concat(t._prefix, "__line")})), u.push(r)
        }))
      }
    }, {
      key: "_linesAppend", value: function () {
        var t = this;
        this._prop.appendLines && this._el.lines.forEach((function (e) {
          t._outer.appendChild(e.el), e.children.forEach((function (t) {
            e.el.appendChild(t.el)
          }))
        }))
      }
    }, {
      key: "_linesRemove", value: function () {
        var t = this._prop, e = this._el, n = this._outer;
        t.appendLines && (t.appendWords ? e.words.forEach((function (t) {
          n.appendChild(t.el)
        })) : t.appendLetters && e.letters.forEach((function (t) {
          n.appendChild(t.el)
        }))), e.lines.forEach((function (t) {
          t.el && t.el.remove()
        })), e.lines = []
      }
    }, {
      key: "destroy", value: function () {
        l(d(a.prototype), "destroy", this).call(this), this._outer.innerHTML = this._html
      }
    }]) && c(e.prototype, n), r && c(e, r), a
  }(i.default);
  e.default = v
}, function (t, e, n) {
  "use strict";
  var r = n(73), i = n.n(r), o = n(17), s = n.n(o), a = n(1), c = n(0), l = n(11), u = n(45), h = n(52), f = n(3),
    d = n(33), p = n.n(d), m = n(8), v = n.n(m), g = n(10), y = n.n(g), _ = n(19), b = n(13), x = n(7);

  function w(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function S(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function M(t, e, n) {
    return M = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = H(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, M(t, e, n || t)
  }

  function E(t, e) {
    return E = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, E(t, e)
  }

  function T(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = H(t);
      if (e) {
        var i = H(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return O(this, n)
    }
  }

  function O(t, e) {
    if (e && ("object" === A(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function H(t) {
    return H = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, H(t)
  }

  function A(t) {
    return A = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, A(t)
  }

  var P = function (t, e, n, r) {
    var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
    if ("object" === ("undefined" == typeof Reflect ? "undefined" : A(Reflect)) && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--) (i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s);
    return o > 3 && s && Object.defineProperty(e, n, s), s
  }, R = "page-ajax-loading", L = 10, C = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && E(t, e)
    }(o, t);
    var e, n, r, i = T(o);

    function o() {
      var t;
      return w(this, o), (t = i.apply(this, arguments))._ctx2d = !1, t._appearProgress = 0, t._disappearProgress = 0, t._timeline = !1, t._pageAjaxEvents = [], t._viewportEvents = [], t
    }

    return e = o, n = [{
      key: "createRenderRoot", value: function () {
        return this
      }
    }, {
      key: "firstUpdated", value: function () {
        this.classList.add(R), this.style.display = "none"
      }
    }, {
      key: "connectedCallback", value: function () {
        var t = this;
        M(H(o.prototype), "connectedCallback", this).call(this), this._ctx2d = new _.a(this), this.appendChild(this._ctx2d.canvas), this._viewportEvents.push(c.a.viewport.on("", (function () {
          t._resize()
        }), {name: R})), this._pageAjaxEvents.push(x.a.on("prepare", (function () {
          t.show(x.a.prop.timeouts.load)
        })))
      }
    }, {
      key: "disconnectedCallback", value: function () {
        M(H(o.prototype), "disconnectedCallback", this).call(this), this._ctx2d && (this._ctx2d.canvas.remove(), this._ctx2d = !1), this._viewportEvents.forEach((function (t) {
          c.a.viewport.remove(t)
        })), this._pageAjaxEvents.forEach((function (t) {
          x.a.remove(t)
        })), this._pageAjaxEvents = [], this._destroyTimeline()
      }
    }, {
      key: "_destroyTimeline", value: function () {
        this._timeline && (this._timeline.destroy(), this._timeline = !1)
      }
    }, {
      key: "_resize", value: function () {
        this._ctx2d && (this._ctx2d.updateSize(), this._render())
      }
    }, {
      key: "show", value: function () {
        var t = this, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 500;
        this._destroyTimeline(), this._appearProgress = 0, this._disappearProgress = 0;
        var n = new y.a;
        n.on("progress", (function (e) {
          t._appearProgress = e.p, t._disappearProgress = 0, t._render()
        })), n.on("play", (function () {
          t.style.display = "block", t._resize()
        })), n.play({duration: e, easing: "linear"})
      }
    }, {
      key: "hide", value: function () {
        var t = this, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 500;
        this._destroyTimeline(), this._appearProgress = 1, this._disappearProgress = 0;
        var n = new y.a;
        n.on("progress", (function (e) {
          t._appearProgress = 1, t._disappearProgress = e.p, t._render()
        })), n.on("play", (function () {
          t.style.display = "block", t._resize()
        })), n.on("end", (function () {
          t.style.display = "none"
        })), n.play({duration: e, easing: "linear"})
      }
    }, {
      key: "_render", value: function () {
        if (this._ctx2d) {
          var t = this._ctx2d, e = t.ctx, n = t.width, r = t.height;
          if (!(n <= 0 || r <= 0)) {
            var i = p()(Object(b.b)(v()(this._appearProgress, [0, .25])), c.a.prop.easing),
              o = p()(v()(this._appearProgress, [0, 1]), c.a.prop.easing), s = 1;
            this._appearProgress < 1 ? s = i : this._disappearProgress > 0 && (s = 1 - this._disappearProgress), e.save(), e.clearRect(0, 0, n, r), e.beginPath(), e.globalAlpha = s;
            var a = .5 * n, l = r, u = Math.sqrt(Math.pow(a, 2) + Math.pow(l, 2)),
              h = e.createLinearGradient(0, 0, a, u);
            h.addColorStop(0, "rgba(".concat(L, ", ").concat(L, ", ").concat(L, ", 1)")), h.addColorStop(1, "rgba(".concat(L, ", ").concat(L, ", ").concat(L, ", ").concat(o, ")")), e.rect(0, 0, n, r), e.fillStyle = h, e.fill(), e.closePath(), e.restore()
          }
        }
      }
    }], n && S(e.prototype, n), r && S(e, r), o
  }(f.a), k = (C = P([Object(f.b)(R)], C), function () {
    var t = 0, e = Object(a.g)("#preloader"), n = Object(a.g)(".v-preloader__progress"), r = new i.a({
      selector: e,
      hide: !1,
      animation: l.c ? 0 : 500,
      progress: {
        on: !0,
        forceEnd: !0,
        k: l.c ? 1 : .05,
        forceEndDuration: l.c ? 10 : 500,
        images: !1,
        videos: !1,
        resources: 100
      }
    });
    return r.add({
      target: "progress", do: function (t) {
        n && (n.style.transform = "scale(".concat(t.easing, ", 1)"))
      }.bind(this)
    }), function e() {
      var n = Object(h.a)(), i = Math.floor(100 * n), o = i - t;
      r.resourcesAddLoaded(o), t = i, n < 1 && setTimeout((function () {
        e()
      }), 25)
    }(), r.add({
      target: "hide", do: function () {
        c.a.vevetPage && c.a.vevetPage.show();
        r.hide()
      }.bind(this)
    }), r.add({
      target: "hidden", do: function () {
        e.style.display = "none"
      }
    }), s()((function () {
      Object(u.b)()
    }), l.c ? 0 : 100), r
  }());
  e.a = k
}, function (t, e) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var n = function () {
    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "id",
      e = "".concat(+new Date, "_").concat(Math.round(1e3 * Math.random()));
    return "".concat(t, "_").concat(e)
  };
  e.default = n
}, function (t, e, n) {
  "use strict";
  n.d(e, "c", (function () {
    return o
  })), n.d(e, "a", (function () {
    return r
  })), n.d(e, "b", (function () {
    return i
  }));
  var r, i, o = {
    visibleCount: 20,
    tagName: "filtered-content",
    tagNameHead: "filtered-content-head",
    tagNameFilter: "filtered-content-filter",
    tagNameItems: "filtered-content-items"
  };
  !function (t) {
    t.ASC = "asc", t.DESC = "desc", t.EMPTY = "empty"
  }(r || (r = {})), function (t) {
    t.NUM = "num", t.STRING = "string"
  }(i || (i = {}))
}, function (t, e, n) {
  "use strict";
  var r = {
    tagName: "gl-advanced-letter",
    useLightVersion: n(0).a.viewport.mobiledevice,
    mirrorStartSize: 1e3,
    mirrorScaleMultiplier: 1,
    bloom: {objIndex: 0, layer: 10}
  };
  e.a = r
}, function (t, e, n) {
  "use strict";
  n.d(e, "b", (function () {
    return i
  })), n.d(e, "a", (function () {
    return o
  }));
  var r = n(4), i = "interactive-image", o = {
    showDuration: 1500,
    hoverDelay: 100,
    scaleEase: .05,
    scale: 1,
    blurStrength: .2,
    blurDuration: 1e3,
    blurProgressEdge: .25
  };
  if (r.b) {
    var s = r.b.addFolder("interactive image");
    s.add(o, "scaleEase", r.a, .25, r.a), s.add(o, "scale", 1, 2, r.a), s.add(o, "blurStrength", 0, 1, r.a), s.add(o, "blurDuration", 100, 5e3, 100), s.add(o, "blurProgressEdge", r.a, .5, r.a)
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return g
  }));
  var r = n(6), i = n.n(r), o = n(2), s = n(35), a = n(31), c = n(26), l = n(19);

  function u(t) {
    return u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, u(t)
  }

  function h(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function f(t, e, n) {
    return f = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = v(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, f(t, e, n || t)
  }

  function d(t, e) {
    return d = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, d(t, e)
  }

  function p(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = v(t);
      if (e) {
        var i = v(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return m(this, n)
    }
  }

  function m(t, e) {
    if (e && ("object" === u(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function v(t) {
    return v = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, v(t)
  }

  var g = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && d(t, e)
    }(u, t);
    var e, n, r, a = p(u);

    function u(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, u), a.call(this, t)
    }

    return e = u, (n = [{
      key: "defaultProp", get: function () {
        return i()(f(v(u.prototype), "defaultProp", this), {src: "", resource: !1, posRule: !1, coverVideo: !0})
      }
    }, {
      key: "prop", get: function () {
        return this._prop
      }
    }, {
      key: "_extra", value: function () {
        f(v(u.prototype), "_extra", this).call(this), this._resource = !1, this._loaded = !1, this._prop.uniformsData.push({
          key: "u_video_repeatX",
          value: 1,
          type: "float"
        }), this._prop.uniformsData.push({key: "u_video_repeatY", value: 1, type: "float"}), this._isVideo = !1
      }
    }, {
      key: "loaded", get: function () {
        return this._loaded
      }
    }, {
      key: "on", value: function (t, e, n) {
        return f(v(u.prototype), "on", this).call(this, t, e, n)
      }
    }, {
      key: "_createTHREE", value: function () {
        this._loadRes(f(v(u.prototype), "_createTHREE", this).bind(this))
      }
    }, {
      key: "_loadRes", value: function (t) {
        var e = this, n = this._prop.resource;
        n ? (this._resource = n, this._resLoaded(t)) : Object(c.a)(this._prop.src, (function (n) {
          e._resource = n, e._resLoaded(t)
        }), (function () {
          e._resource = !1, e._prop.materialProp.color = 5855577, e._resLoaded(t)
        }))
      }
    }, {
      key: "_resLoaded", value: function (t) {
        this._loaded || this.lbt("loaded"), this._loaded = !0, t()
      }
    }, {
      key: "_createTexture", value: function () {
        var t, e = this, n = this._resource;
        n instanceof HTMLVideoElement ? (this._isVideo = !0, t = new o.pb(n), n.addEventListener("loadedmetadata", (function () {
          e.resize()
        }))) : n instanceof HTMLCanvasElement ? (t = new o.f(n)).mapping = o.j : n instanceof HTMLImageElement ? t = this._prop.posRule ? this._createCanvasTexture(n) : new o.hb(n) : this._texture = void 0, t && (n instanceof HTMLVideoElement || (t.needsUpdate = !0, t.magFilter = o.z, t.minFilter = o.z), this._texture = t)
      }
    }, {
      key: "_createCanvasTexture", value: function (t) {
        var e = this;
        this._ctx2D = new l.a(this._prop.el, !0), this._ctx2D.updateSize(), this._drawCanvasTexture(t);
        var n = new o.f(this._ctx2D.canvas);
        return this._threeEvents.push(this._prop.three.on("resize", (function () {
          e._ctx2D.updateSize(), e._drawCanvasTexture(t), n.needsUpdate = !0
        }))), n
      }
    }, {
      key: "_drawCanvasTexture", value: function (t) {
        var e = this._ctx2D, n = e.width, r = e.height, i = e.ctx;
        i.clearRect(0, 0, n, r);
        var o = Object(s.a)({source: t, rule: this.prop.posRule || "top-left", scale: 1, width: n, height: r});
        i.drawImage(t, 0, 0, o.sourceWidth, o.sourceHeight, o.x, o.y, o.width, o.height)
      }
    }, {
      key: "resize", value: function () {
        f(v(u.prototype), "resize", this).call(this), this._resizeVideoTexture()
      }
    }, {
      key: "_resizeVideoTexture", value: function () {
        if (this.prop.coverVideo) {
          var t = this._prop.resource;
          if (t instanceof HTMLVideoElement) {
            var e = this.texture;
            if (e) {
              var n, r, i = this._startSize[0] * this._scale[0], o = this._startSize[1] * this._scale[1],
                s = t.videoWidth, a = t.videoHeight;
              (n = i * a / (o * s)) > 1 ? (n = 1, r = o * s / (i * a), e.repeat.set(n, r), e.offset.y = (r - 1) / 2 * -1) : (n = i * a / (o * s), r = 1, e.repeat.set(n, r), e.offset.x = (n - 1) / 2 * -1);
              var c = this._material.userData;
              c.u_video_repeatX && (c.u_video_repeatX.value = n), c.u_video_repeatX && (c.u_video_repeatY.value = r)
            }
          }
        }
      }
    }, {
      key: "_renderTexture", value: function () {
        f(v(u.prototype), "_renderTexture", this).call(this)
      }
    }, {
      key: "destroy", value: function () {
        if (this.prop.resource instanceof HTMLVideoElement) try {
          this.prop.resource.pause()
        } catch (t) {
        }
        f(v(u.prototype), "destroy", this).call(this)
      }
    }]) && h(e.prototype, n), r && h(e, r), u
  }(a.a)
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return H
  }));
  var r = n(15), i = n.n(r), o = n(6), s = n.n(o), a = n(2), c = n(88), l = n(84), u = n(21);
  const h = {
    defines: {SMAA_THRESHOLD: "0.1"},
    uniforms: {tDiffuse: {value: null}, resolution: {value: new a.mb(1 / 1024, 1 / 512)}},
    vertexShader: "\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 3 ];\n\n\t\tvoid SMAAEdgeDetectionVS( vec2 texcoord ) {\n\t\t\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 ); // WebGL port note: Changed sign in W component\n\t\t\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component\n\t\t\tvOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 ); // WebGL port note: Changed sign in W component\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tSMAAEdgeDetectionVS( vUv );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader: "\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 3 ];\n\n\t\tvec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\n\t\t\tvec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );\n\n\t\t\t// Calculate color deltas:\n\t\t\tvec4 delta;\n\t\t\tvec3 C = texture2D( colorTex, texcoord ).rgb;\n\n\t\t\tvec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;\n\t\t\tvec3 t = abs( C - Cleft );\n\t\t\tdelta.x = max( max( t.r, t.g ), t.b );\n\n\t\t\tvec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;\n\t\t\tt = abs( C - Ctop );\n\t\t\tdelta.y = max( max( t.r, t.g ), t.b );\n\n\t\t\t// We do the usual threshold:\n\t\t\tvec2 edges = step( threshold, delta.xy );\n\n\t\t\t// Then discard if there is no edge:\n\t\t\tif ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )\n\t\t\t\tdiscard;\n\n\t\t\t// Calculate right and bottom deltas:\n\t\t\tvec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;\n\t\t\tt = abs( C - Cright );\n\t\t\tdelta.z = max( max( t.r, t.g ), t.b );\n\n\t\t\tvec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;\n\t\t\tt = abs( C - Cbottom );\n\t\t\tdelta.w = max( max( t.r, t.g ), t.b );\n\n\t\t\t// Calculate the maximum delta in the direct neighborhood:\n\t\t\tfloat maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );\n\n\t\t\t// Calculate left-left and top-top deltas:\n\t\t\tvec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;\n\t\t\tt = abs( C - Cleftleft );\n\t\t\tdelta.z = max( max( t.r, t.g ), t.b );\n\n\t\t\tvec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;\n\t\t\tt = abs( C - Ctoptop );\n\t\t\tdelta.w = max( max( t.r, t.g ), t.b );\n\n\t\t\t// Calculate the final maximum delta:\n\t\t\tmaxDelta = max( max( maxDelta, delta.z ), delta.w );\n\n\t\t\t// Local contrast adaptation in action:\n\t\t\tedges.xy *= step( 0.5 * maxDelta, delta.xy );\n\n\t\t\treturn vec4( edges, 0.0, 0.0 );\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );\n\n\t\t}"
  }, f = {
    defines: {
      SMAA_MAX_SEARCH_STEPS: "8",
      SMAA_AREATEX_MAX_DISTANCE: "16",
      SMAA_AREATEX_PIXEL_SIZE: "( 1.0 / vec2( 160.0, 560.0 ) )",
      SMAA_AREATEX_SUBTEX_SIZE: "( 1.0 / 7.0 )"
    },
    uniforms: {
      tDiffuse: {value: null},
      tArea: {value: null},
      tSearch: {value: null},
      resolution: {value: new a.mb(1 / 1024, 1 / 512)}
    },
    vertexShader: "\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 3 ];\n\t\tvarying vec2 vPixcoord;\n\n\t\tvoid SMAABlendingWeightCalculationVS( vec2 texcoord ) {\n\t\t\tvPixcoord = texcoord / resolution;\n\n\t\t\t// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n\t\t\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 ); // WebGL port note: Changed sign in Y and W components\n\t\t\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 ); // WebGL port note: Changed sign in Y and W components\n\n\t\t\t// And these for the searches, they indicate the ends of the loops:\n\t\t\tvOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tSMAABlendingWeightCalculationVS( vUv );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader: "\n\n\t\t#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tArea;\n\t\tuniform sampler2D tSearch;\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[3];\n\t\tvarying vec2 vPixcoord;\n\n\t\t#if __VERSION__ == 100\n\t\tvec2 round( vec2 x ) {\n\t\t\treturn sign( x ) * floor( abs( x ) + 0.5 );\n\t\t}\n\t\t#endif\n\n\t\tfloat SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\n\t\t\t// Not required if searchTex accesses are set to point:\n\t\t\t// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);\n\t\t\t// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +\n\t\t\t//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;\n\t\t\te.r = bias + e.r * scale;\n\t\t\treturn 255.0 * texture2D( searchTex, e, 0.0 ).r;\n\t\t}\n\n\t\tfloat SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\t/**\n\t\t\t\t* @PSEUDO_GATHER4\n\t\t\t\t* This texcoord has been offset by (-0.25, -0.125) in the vertex shader to\n\t\t\t\t* sample between edge, thus fetching four edges in a row.\n\t\t\t\t* Sampling with different offsets in each direction allows to disambiguate\n\t\t\t\t* which edges are active from the four fetched ones.\n\t\t\t\t*/\n\t\t\tvec2 e = vec2( 0.0, 1.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord -= vec2( 2.0, 0.0 ) * resolution;\n\t\t\t\tif ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\t// We correct the previous (-0.25, -0.125) offset we applied:\n\t\t\ttexcoord.x += 0.25 * resolution.x;\n\n\t\t\t// The searches are bias by 1, so adjust the coords accordingly:\n\t\t\ttexcoord.x += resolution.x;\n\n\t\t\t// Disambiguate the length added by the last step:\n\t\t\ttexcoord.x += 2.0 * resolution.x; // Undo last step\n\t\t\ttexcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\n\n\t\t\treturn texcoord.x;\n\t\t}\n\n\t\tfloat SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\tvec2 e = vec2( 0.0, 1.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord += vec2( 2.0, 0.0 ) * resolution;\n\t\t\t\tif ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\ttexcoord.x -= 0.25 * resolution.x;\n\t\t\ttexcoord.x -= resolution.x;\n\t\t\ttexcoord.x -= 2.0 * resolution.x;\n\t\t\ttexcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\n\n\t\t\treturn texcoord.x;\n\t\t}\n\n\t\tfloat SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\tvec2 e = vec2( 1.0, 0.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord += vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign\n\t\t\t\tif ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\ttexcoord.y -= 0.25 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y -= resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y -= 2.0 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 ); // WebGL port note: Changed sign\n\n\t\t\treturn texcoord.y;\n\t\t}\n\n\t\tfloat SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\tvec2 e = vec2( 1.0, 0.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord -= vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign\n\t\t\t\tif ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\ttexcoord.y += 0.25 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y += resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y += 2.0 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 ); // WebGL port note: Changed sign\n\n\t\t\treturn texcoord.y;\n\t\t}\n\n\t\tvec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\n\t\t\t// Rounding prevents precision errors of bilinear filtering:\n\t\t\tvec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\n\n\t\t\t// We do a scale and bias for mapping to texel space:\n\t\t\ttexcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n\n\t\t\t// Move to proper place, according to the subpixel offset:\n\t\t\ttexcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n\n\t\t\treturn texture2D( areaTex, texcoord, 0.0 ).rg;\n\t\t}\n\n\t\tvec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\n\t\t\tvec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\n\n\t\t\tvec2 e = texture2D( edgesTex, texcoord ).rg;\n\n\t\t\tif ( e.g > 0.0 ) { // Edge at north\n\t\t\t\tvec2 d;\n\n\t\t\t\t// Find the distance to the left:\n\t\t\t\tvec2 coords;\n\t\t\t\tcoords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\n\t\t\t\tcoords.y = offset[ 1 ].y; // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)\n\t\t\t\td.x = coords.x;\n\n\t\t\t\t// Now fetch the left crossing edges, two at a time using bilinear\n\t\t\t\t// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to\n\t\t\t\t// discern what value each edge has:\n\t\t\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).r;\n\n\t\t\t\t// Find the distance to the right:\n\t\t\t\tcoords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\n\t\t\t\td.y = coords.x;\n\n\t\t\t\t// We want the distances to be in pixel units (doing this here allow to\n\t\t\t\t// better interleave arithmetic and memory accesses):\n\t\t\t\td = d / resolution.x - pixcoord.x;\n\n\t\t\t\t// SMAAArea below needs a sqrt, as the areas texture is compressed\n\t\t\t\t// quadratically:\n\t\t\t\tvec2 sqrt_d = sqrt( abs( d ) );\n\n\t\t\t\t// Fetch the right crossing edges:\n\t\t\t\tcoords.y -= 1.0 * resolution.y; // WebGL port note: Added\n\t\t\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;\n\n\t\t\t\t// Ok, we know how this pattern looks like, now it is time for getting\n\t\t\t\t// the actual area:\n\t\t\t\tweights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\n\t\t\t}\n\n\t\t\tif ( e.r > 0.0 ) { // Edge at west\n\t\t\t\tvec2 d;\n\n\t\t\t\t// Find the distance to the top:\n\t\t\t\tvec2 coords;\n\n\t\t\t\tcoords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\n\t\t\t\tcoords.x = offset[ 0 ].x; // offset[1].x = texcoord.x - 0.25 * resolution.x;\n\t\t\t\td.x = coords.y;\n\n\t\t\t\t// Fetch the top crossing edges:\n\t\t\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).g;\n\n\t\t\t\t// Find the distance to the bottom:\n\t\t\t\tcoords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\n\t\t\t\td.y = coords.y;\n\n\t\t\t\t// We want the distances to be in pixel units:\n\t\t\t\td = d / resolution.y - pixcoord.y;\n\n\t\t\t\t// SMAAArea below needs a sqrt, as the areas texture is compressed\n\t\t\t\t// quadratically:\n\t\t\t\tvec2 sqrt_d = sqrt( abs( d ) );\n\n\t\t\t\t// Fetch the bottom crossing edges:\n\t\t\t\tcoords.y -= 1.0 * resolution.y; // WebGL port note: Added\n\t\t\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;\n\n\t\t\t\t// Get the area for this direction:\n\t\t\t\tweights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\n\t\t\t}\n\n\t\t\treturn weights;\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );\n\n\t\t}"
  }, d = {
    uniforms: {tDiffuse: {value: null}, tColor: {value: null}, resolution: {value: new a.mb(1 / 1024, 1 / 512)}},
    vertexShader: "\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 2 ];\n\n\t\tvoid SMAANeighborhoodBlendingVS( vec2 texcoord ) {\n\t\t\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 ); // WebGL port note: Changed sign in W component\n\t\t\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tSMAANeighborhoodBlendingVS( vUv );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader: "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tColor;\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 2 ];\n\n\t\tvec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\n\t\t\t// Fetch the blending weights for current pixel:\n\t\t\tvec4 a;\n\t\t\ta.xz = texture2D( blendTex, texcoord ).xz;\n\t\t\ta.y = texture2D( blendTex, offset[ 1 ].zw ).g;\n\t\t\ta.w = texture2D( blendTex, offset[ 1 ].xy ).a;\n\n\t\t\t// Is there any blending weight with a value greater than 0.0?\n\t\t\tif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {\n\t\t\t\treturn texture2D( colorTex, texcoord, 0.0 );\n\t\t\t} else {\n\t\t\t\t// Up to 4 lines can be crossing a pixel (one through each edge). We\n\t\t\t\t// favor blending by choosing the line with the maximum weight for each\n\t\t\t\t// direction:\n\t\t\t\tvec2 offset;\n\t\t\t\toffset.x = a.a > a.b ? a.a : -a.b; // left vs. right\n\t\t\t\toffset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom // WebGL port note: Changed signs\n\n\t\t\t\t// Then we go in the direction that has the maximum weight:\n\t\t\t\tif ( abs( offset.x ) > abs( offset.y )) { // horizontal vs. vertical\n\t\t\t\t\toffset.y = 0.0;\n\t\t\t\t} else {\n\t\t\t\t\toffset.x = 0.0;\n\t\t\t\t}\n\n\t\t\t\t// Fetch the opposite color and lerp by hand:\n\t\t\t\tvec4 C = texture2D( colorTex, texcoord, 0.0 );\n\t\t\t\ttexcoord += sign( offset ) * resolution;\n\t\t\t\tvec4 Cop = texture2D( colorTex, texcoord, 0.0 );\n\t\t\t\tfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\n\n\t\t\t\t// WebGL port note: Added gamma correction\n\t\t\t\tC.xyz = pow(C.xyz, vec3(2.2));\n\t\t\t\tCop.xyz = pow(Cop.xyz, vec3(2.2));\n\t\t\t\tvec4 mixed = mix(C, Cop, s);\n\t\t\t\tmixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));\n\n\t\t\t\treturn mixed;\n\t\t\t}\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );\n\n\t\t}"
  };

  class p extends u.b {
    constructor(t, e) {
      super(), this.edgesRT = new a.qb(t, e, {
        depthBuffer: !1,
        generateMipmaps: !1,
        minFilter: a.z,
        format: a.X
      }), this.edgesRT.texture.name = "SMAAPass.edges", this.weightsRT = new a.qb(t, e, {
        depthBuffer: !1,
        generateMipmaps: !1,
        minFilter: a.z,
        format: a.U
      }), this.weightsRT.texture.name = "SMAAPass.weights";
      const n = this, r = new Image;
      r.src = this.getAreaTexture(), r.onload = function () {
        n.areaTexture.needsUpdate = !0
      }, this.areaTexture = new a.hb, this.areaTexture.name = "SMAAPass.area", this.areaTexture.image = r, this.areaTexture.format = a.X, this.areaTexture.minFilter = a.z, this.areaTexture.generateMipmaps = !1, this.areaTexture.flipY = !1;
      const i = new Image;
      i.src = this.getSearchTexture(), i.onload = function () {
        n.searchTexture.needsUpdate = !0
      }, this.searchTexture = new a.hb, this.searchTexture.name = "SMAAPass.search", this.searchTexture.image = i, this.searchTexture.magFilter = a.L, this.searchTexture.minFilter = a.L, this.searchTexture.generateMipmaps = !1, this.searchTexture.flipY = !1, void 0 === h && console.error("THREE.SMAAPass relies on SMAAShader"), this.uniformsEdges = a.kb.clone(h.uniforms), this.uniformsEdges.resolution.value.set(1 / t, 1 / e), this.materialEdges = new a.ab({
        defines: Object.assign({}, h.defines),
        uniforms: this.uniformsEdges,
        vertexShader: h.vertexShader,
        fragmentShader: h.fragmentShader
      }), this.uniformsWeights = a.kb.clone(f.uniforms), this.uniformsWeights.resolution.value.set(1 / t, 1 / e), this.uniformsWeights.tDiffuse.value = this.edgesRT.texture, this.uniformsWeights.tArea.value = this.areaTexture, this.uniformsWeights.tSearch.value = this.searchTexture, this.materialWeights = new a.ab({
        defines: Object.assign({}, f.defines),
        uniforms: this.uniformsWeights,
        vertexShader: f.vertexShader,
        fragmentShader: f.fragmentShader
      }), this.uniformsBlend = a.kb.clone(d.uniforms), this.uniformsBlend.resolution.value.set(1 / t, 1 / e), this.uniformsBlend.tDiffuse.value = this.weightsRT.texture, this.materialBlend = new a.ab({
        uniforms: this.uniformsBlend,
        vertexShader: d.vertexShader,
        fragmentShader: d.fragmentShader
      }), this.needsSwap = !1, this.fsQuad = new u.a(null)
    }

    render(t, e, n) {
      this.uniformsEdges.tDiffuse.value = n.texture, this.fsQuad.material = this.materialEdges, t.setRenderTarget(this.edgesRT), this.clear && t.clear(), this.fsQuad.render(t), this.fsQuad.material = this.materialWeights, t.setRenderTarget(this.weightsRT), this.clear && t.clear(), this.fsQuad.render(t), this.uniformsBlend.tColor.value = n.texture, this.fsQuad.material = this.materialBlend, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(), this.fsQuad.render(t))
    }

    setSize(t, e) {
      this.edgesRT.setSize(t, e), this.weightsRT.setSize(t, e), this.materialEdges.uniforms.resolution.value.set(1 / t, 1 / e), this.materialWeights.uniforms.resolution.value.set(1 / t, 1 / e), this.materialBlend.uniforms.resolution.value.set(1 / t, 1 / e)
    }

    getAreaTexture() {
      return "data:image/png;base64,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"
    }

    getSearchTexture() {
      return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII="
    }
  }

  var m = n(43);
  const v = {
    uniforms: {tDiffuse: {value: null}},
    vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader: "\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 tex = texture2D( tDiffuse, vUv );\n\n\t\t\tgl_FragColor = LinearTosRGB( tex ); // optional: LinearToGamma( tex, float( GAMMA_FACTOR ) );\n\n\t\t}"
  };
  var g = n(53), y = n(44), _ = n(5);

  function b(t) {
    return b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, b(t)
  }

  function x(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function w(t, e, n) {
    return w = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = T(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, w(t, e, n || t)
  }

  function S(t, e) {
    return S = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, S(t, e)
  }

  function M(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = T(t);
      if (e) {
        var i = T(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return E(this, n)
    }
  }

  function E(t, e) {
    if (e && ("object" === b(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function T(t) {
    return T = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, T(t)
  }

  var O = n(0).a.viewport, H = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && S(t, e)
    }(o, t);
    var e, n, r, i = M(o);

    function o(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, o), i.call(this, t)
    }

    return e = o, (n = [{
      key: "defaultProp", get: function () {
        return s()(w(T(o.prototype), "defaultProp", this), {
          el: !1,
          autoRender: !0,
          dpr: !1,
          three: _.a,
          useComposer: !1,
          useGammaCorrection: !1,
          cameraSettings: {far: 800},
          renderSettings: {}
        })
      }
    }, {
      key: "prop", get: function () {
        return this._prop
      }
    }, {
      key: "scene", get: function () {
        return this._scene
      }
    }, {
      key: "camera", get: function () {
        return this._camera.camera
      }
    }, {
      key: "renderer", get: function () {
        return this._renderer
      }
    }, {
      key: "_extra", value: function () {
        w(T(o.prototype), "_extra", this).call(this), this._threeEvents = [], this._useComposer = this._prop.useComposer, this._scene = Object(y.a)(), this._camera = Object(g.a)(this._prop.el, this._prop.cameraSettings.far), this._renderer = this._createRenderTarget(), this._useComposer && this._createEffectComposer()
      }
    }, {
      key: "_createRenderTarget", value: function () {
        var t = this._getRenderSizes();
        return new a.qb(t.width, t.height, Object.assign({minFilter: a.z, magFilter: a.z}, this.prop.renderSettings))
      }
    }, {
      key: "_getRenderSizes", value: function () {
        var t = this._prop.dpr ? this._prop.dpr : O.dprMobile;
        return {
          width: (this._prop.el ? this._prop.el.clientWidth : O.size[0]) * t,
          height: (this._prop.el ? this._prop.el.clientHeight : O.size[1]) * t
        }
      }
    }, {
      key: "toggleAutoRender", value: function (t) {
        this._prop.autoRender = t
      }
    }, {
      key: "_createEffectComposer", value: function () {
        this._composer = new c.a(this.prop.three.renderer, this._renderer);
        var t = new l.a(this._scene, this.camera);
        if (this._composer.addPass(t), this.prop.useGammaCorrection) {
          var e = new m.a(v);
          this._composer.addPass(e)
        }
        this._createComposerAntialiasing()
      }
    }, {
      key: "_createComposerAntialiasing", value: function () {
        var t = this._getRenderSizes(), e = new p(t.width, t.height);
        this._composer.addPass(e)
      }
    }, {
      key: "_setEvents", value: function () {
        var t = this, e = this.prop.three.on("resize", (function () {
          t._updateSizes()
        }));
        this._threeEvents.push(e);
        var n = this.prop.three.on("prerender", (function () {
          t._prop.autoRender && t.render()
        }));
        this._threeEvents.push(n)
      }
    }, {
      key: "_updateSizes", value: function () {
        var t = this._getRenderSizes();
        this._renderer.setSize(t.width, t.height), this._camera.resize()
      }
    }, {
      key: "render", value: function () {
        var t = this._prop.three.renderer;
        this._useComposer ? (this._composer.renderToScreen = !1, this._composer.render()) : (t.autoClear = !0, t.setRenderTarget(this._renderer), t.render(this._scene, this._camera.camera), t.setRenderTarget(null))
      }
    }, {
      key: "_destroy", value: function () {
        w(T(o.prototype), "_destroy", this).call(this), this._scene = null, this._camera = null, this._renderer.dispose(), this._renderer = null;
        for (var t = 0; t < this._threeEvents.length; t++) this._prop.three.remove(this._threeEvents[t])
      }
    }]) && x(e.prototype, n), r && x(e, r), o
  }(i.a)
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return i
  })), n.d(e, "c", (function () {
    return o
  })), n.d(e, "b", (function () {
    return s
  }));
  var r = n(1);

  function i(t) {
    for (var e = t.querySelectorAll("*"), n = 0, i = e.length; n < i; n++) Object(r.e)(e[n], "button", 5) || e[n].setAttribute("tabindex", "-1")
  }

  function o(t) {
    t.setAttribute("tabindex", "0")
  }

  function s(t) {
    for (var e = t.children, n = 0; n < e.length; n++) e[0].setAttribute("tabindex", "-1")
  }
}, function (t, e, n) {
  "use strict";
  var r = n(4), i = {
    tagName: "wave-hover-image",
    ticker: .0709,
    yDistortionRange: 10.7196,
    yDistortionStrength: .8095,
    moveEase: .16,
    hoverDelay: 50,
    duration: 200,
    alpha: .75
  };
  if (e.a = i, r.b) {
    var o = r.b.addFolder("".concat(i.tagName));
    o.add(i, "ticker", 0, .125, r.a), o.add(i, "yDistortionRange", 0, 30, r.a), o.add(i, "yDistortionStrength", r.a, .99999, r.a), o.add(i, "moveEase", r.a, .25, .01), o.add(i, "duration", 100, 1e3, 1), o.add(i, "alpha", 0, 1, r.a)
  }
}, function (t, e, n) {
  "use strict";
  var r = n(0), i = n(4), o = "next-project-image", s = {
    tagName: o,
    friction: .1032,
    length: r.a.viewport.mobiledevice ? 10 : 50,
    easeReduce: r.a.viewport.mobiledevice ? .0906 : .0189,
    showHoverArea: !1,
    hoverAreaX: .9,
    hoverAreaY: 1,
    handleHoverAreaChange: function () {
    },
    ratio: 1.16,
    desktopMaxWidth: .25,
    desktopMaxHeight: .65625,
    tabletMaxWidth: .325,
    tabletMaxHeight: .65625,
    mobileMaxWidth: .549,
    mobileMaxHeight: .6
  };
  if (e.a = s, i.b) {
    var a = i.b.addFolder(o);
    a.add(s, "friction", 0, .9, i.a);
    var c = a.add(s, "easeReduce", 0, l(), i.a);
    a.add(s, "length", 1, 100, 1).onChange((function () {
      c.max(l()), c.setValue(l()), s.handleHoverAreaChange()
    })), a.add(s, "showHoverArea"), a.add(s, "hoverAreaX", i.a, 1, i.a).onChange((function () {
      s.handleHoverAreaChange()
    })), a.add(s, "hoverAreaY", i.a, 1, i.a).onChange((function () {
      s.handleHoverAreaChange()
    }))
  }

  function l() {
    return 1 / (s.length + 1)
  }
}, function (t, e) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = function (t) {
    var e = window.vevetApplication;
    void 0 === t ? t = {v: e} : void 0 === t.v && (t.v = e);
    return t
  }
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = l(n(15)), o = l(n(6)), s = l(n(33)), a = l(n(17)), c = l(n(10));

  function l(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function u(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function h(t, e, n) {
    return h = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = m(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, h(t, e, n || t)
  }

  function f(t, e) {
    return f = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, f(t, e)
  }

  function d(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = m(t);
      if (e) {
        var i = m(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return p(this, n)
    }
  }

  function p(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function m(t) {
    return m = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, m(t)
  }

  var v = n(25), g = n(46), y = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && f(t, e)
    }(l, t);
    var e, n, r, i = d(l);

    function l(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, l), i.call(this, t)
    }

    return e = l, n = [{
      key: "prefix", get: function () {
        return "".concat(this._v.prefix, "preloader")
      }
    }, {
      key: "defaultProp", get: function () {
        return (0, o.default)(h(m(l.prototype), "defaultProp", this), {
          selector: "." + this._prefix,
          animation: 750,
          animationInner: 25,
          progress: {
            on: !1,
            k: .01,
            forceEnd: !1,
            forceEndDuration: 3e3,
            easing: this._vp.easing,
            images: !0,
            bgSelector: "*:not(script)",
            videos: !0,
            resources: 0
          },
          hide: !0
        })
      }
    }, {
      key: "loaded", get: function () {
        return this._v.load.loaded
      }
    }, {
      key: "resourcesTotal", get: function () {
        return this._resourcesTotal
      }
    }, {
      key: "resourcesLoaded", get: function () {
        return this._resourcesLoaded
      }
    }, {
      key: "hidden", get: function () {
        return this._hidden
      }
    }, {
      key: "outer", get: function () {
        return this._outer
      }
    }, {
      key: "_extra", value: function () {
        h(m(l.prototype), "_extra", this).call(this);
        var t = this._prop;
        this._outer = v.one(t.selector), this._outer.classList.add(this._prefix), this._time = +new Date, this._hidden = !1, this._images = [], this._videos = [], this._resourcesTotal = t.progress.resources, this._resourcesLoaded = 0, this._progressLoad = 0, this._progressAnim = 0, this._progressFrameId = null, this._progressBool = !0, this._setStyles()
      }
    }, {
      key: "_setStyles", value: function () {
        var t = this._outer;
        return t.style.opacity = "1", t.style.transition = "".concat(this._prop.animation / 1e3, "s"), t.classList.add("".concat(this._prefix, "_animate")), !0
      }
    }, {
      key: "_setEvents", value: function () {
        var t = this;
        this.addEvent("load", {
          name: this._name, do: function () {
            t._onloaded()
          }
        });
        var e = this._prop.progress;
        e.on && (e.images && (this._resourcesTotal += this._getImages()), e.videos && (this._resourcesTotal += this._getVideos()), this._resourcesTotal > 0 ? (this._resourcesLoad(), this._frameLaunch()) : this._onloaded())
      }
    }, {
      key: "_getImages", value: function () {
        var t = this._images;
        document.querySelectorAll("img").forEach((function (e) {
          t.push(e.src)
        }));
        var e = this._prop.progress.bgSelector;
        if (e) for (var n = document.querySelectorAll(e), r = 0; r < n.length; r++) {
          var i = getComputedStyle(n[r]).backgroundImage;
          if (-1 == i.indexOf("none") & -1 == i.indexOf("-gradient")) {
            if (-1 != i.indexOf("url")) {
              var o = i.match(/url\((.*?)\)/);
              i = o[1].replace(/"/g, ""), t.push(i)
            }
          } else "IMG" == n[r].tagName && t.push(n[r].src)
        }
        return t.length
      }
    }, {
      key: "_getVideos", value: function () {
        for (var t = this._videos, e = document.querySelectorAll("video"), n = 0; n < e.length; n++) t.push(e[n]);
        return t.length
      }
    }, {
      key: "_resourcesLoad", value: function () {
        for (var t = this, e = this._images, n = this._videos, r = 0; r < e.length; r++) {
          var i = new Image;
          i.onload = function () {
            t._resourcesOnLoaded()
          }, i.onerror = function () {
            t._resourcesOnLoaded()
          }, i.src = e[r]
        }
        for (var o = 0; o < n.length; o++) n[o].load(), n[o].onloadeddata = function () {
          t._resourcesOnLoaded()
        }
      }
    }, {
      key: "_resourcesOnLoaded", value: function () {
        var t = this._resourcesTotal;
        this._resourcesLoaded++;
        var e = this._resourcesLoaded;
        this._progressLoad = e / t, e == t && this._onloaded()
      }
    }, {
      key: "resourcesAddTotal", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
        this._resourcesTotal += t
      }
    }, {
      key: "resourcesAddLoaded", value: function () {
        for (var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, e = 0; e < t; e++) this._resourcesOnLoaded()
      }
    }, {
      key: "_frameLaunch", value: function () {
        this._progressFrameId = window.requestAnimationFrame(this._frame.bind(this))
      }
    }, {
      key: "_frame", value: function () {
        if (this._progressBool) {
          var t = this._prop;
          this._progressAnim = g(this._progressAnim, this._progressLoad, t.progress.k);
          var e = this._progressAnim;
          if (e >= .999 && (e = 1), this.lbt("progress", {
            progress: e,
            easing: (0, s.default)(e, t.progress.easing),
            loaded: this._resourcesLoaded,
            total: this._resourcesTotal
          }), 1 == e) return cancelAnimationFrame(this._progressFrameId), void this._onloaded();
          this._progressFrameId = window.requestAnimationFrame(this._frame.bind(this))
        }
      }
    }, {
      key: "_progressFrameForce", value: function (t) {
        this._progressAnim = t.s, this.lbt("progress", {
          progress: this._progressAnim,
          easing: (0, s.default)(t.s, this._prop.progress.easing),
          loaded: this.resourcesLoaded,
          total: this.resourcesTotal
        }), 1 !== t.p || this._onloaded()
      }
    }, {
      key: "_onloaded", value: function () {
        if (this.loaded) {
          var t = this._prop.progress;
          if (t.on) {
            if (this._resourcesTotal > this._resourcesLoaded) return;
            if (this._progressAnim < 1) {
              if (t.forceEnd) {
                cancelAnimationFrame(this._progressFrameId), this._progressBool = !1;
                var e = new c.default({destroyOnEnd: !0});
                return e.add({
                  target: "progress",
                  do: this._progressFrameForce.bind(this)
                }), void e.play({duration: t.forceEndDuration, easing: "linear", scope: [this._progressAnim, 1]})
              }
              return
            }
          }
          this._hide()
        }
      }
    }, {
      key: "hide", value: function () {
        var t = this._interval();
        (0, a.default)(this._hideAnimate.bind(this), t)
      }
    }, {
      key: "_hide", value: function () {
        this.lbt("hide"), this._prop.hide && this.hide()
      }
    }, {
      key: "_interval", value: function () {
        var t = +new Date - this._time, e = this._prop.animationInner, n = 0;
        return t < e && (n = e - t), n
      }
    }, {
      key: "_hideAnimate", value: function () {
        var t = this, e = this._outer, n = this._prefix;
        e.style.opacity = "0", e.classList.add("".concat(n, "_hide")), setTimeout((function () {
          e.classList.add("".concat(n, "_hidden")), t._onhidden()
        }), this._prop.animation)
      }
    }, {
      key: "_onhidden", value: function () {
        this._hidden = !0, this.lbt("hidden")
      }
    }], n && u(e.prototype, n), r && u(e, r), l
  }(i.default);
  e.default = y
}, function (t, e) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var n = function (t) {
    return t instanceof Window
  };
  e.default = n
}, function (t, e, n) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var r, i = (r = n(47)) && r.__esModule ? r : {default: r};
  var o = function (t) {
    for (var e = [], n = 0; n < t.length; n++) (0, i.default)(t[n]) && e.push(t[n]);
    return e
  };
  e.default = o
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = s(n(6)), o = s(n(57));

  function s(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function a(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function c(t, e, n) {
    return c = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = f(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, c(t, e, n || t)
  }

  function l(t, e) {
    return l = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, l(t, e)
  }

  function u(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = f(t);
      if (e) {
        var i = f(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return h(this, n)
    }
  }

  function h(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function f(t) {
    return f = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, f(t)
  }

  var d = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && l(t, e)
    }(h, t);
    var e, n, r, s = u(h);

    function h(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, h), s.call(this, t, !1)
    }

    return e = h, n = [{
      key: "defaultProp", get: function () {
        return (0, i.default)(c(f(h.prototype), "defaultProp", this), {
          on: !0,
          multiplier: 1,
          momentum: !0,
          momentumStopThreshold: .01,
          friction: .95,
          thresholdPropagation: !1,
          ease: .15,
          disableListeners: !0,
          timeoutListeners: 10,
          draggable: !0
        })
      }
    }, {
      key: "_extra", value: function () {
        c(f(h.prototype), "_extra", this).call(this), this._vars(), this._prop.draggable && this._preventInnerDrag(), this._moduleEvents = [], this._overrideGetEase()
      }
    }, {
      key: "_vars", value: function () {
        this._dragging = !1, this._dragger = !1
      }
    }, {
      key: "_preventInnerDrag", value: function () {
        this._m.outer.querySelectorAll("img, a").forEach((function (t) {
          t.draggable = !1, t.ondragstart = function () {
            return !1
          }
        }))
      }
    }, {
      key: "_changeProp", value: function (t) {
        c(f(h.prototype), "_changeProp", this).call(this, t), this._destroyDrag(), this._setEvents()
      }
    }, {
      key: "_setEvents", value: function () {
        var t = this._m, e = new o.default({
          on: this._prop.on,
          parent: this,
          outer: t.outer,
          momentum: this._prop.momentum,
          momentumStopThreshold: this._prop.momentumStopThreshold,
          friction: this._prop.friction,
          thresholdPropagation: this._prop.thresholdPropagation
        });
        this._dragger = e, e.on("move", this._start.bind(this)), e.on("move", this._move.bind(this)), e.on("end", this._end.bind(this));
        var n = t.on("wheel", (function () {
          e.stopDrag()
        }));
        this._moduleEvents.push(n)
      }
    }, {
      key: "_start", value: function () {
        this._m.prop.run && this._prop.on && (this._dragging = !0, this.lbt("start"))
      }
    }, {
      key: "_move", value: function (t) {
        var e = this._prop, n = this._m;
        if (n.prop.run && e.on && this._dragging) {
          this._m.play();
          var r = t.step, i = e.multiplier, o = r.x * i, s = r.y * i;
          n.targetLeft -= o, n.targetTop -= s, n._boundariesBoth();
          var a = "y";
          n._prop.horizontal && (a = "x"), t.diff[a] > 0 ? n._direction = -1 : n._direction = 1, e.disableListeners && n.outer.classList.add("".concat(n._prefix, "_dragging")), this.lbt("move")
        }
      }
    }, {
      key: "_end", value: function () {
        var t = this, e = this._prop, n = this._m;
        n.prop.run && e.on && (this._dragging = !1, e.disableListeners && setTimeout((function () {
          t._dragging || n.outer.classList.remove("".concat(n._prefix, "_dragging"))
        }), e.timeoutListeners), this.lbt("end"))
      }
    }, {
      key: "_overrideGetEase", value: function () {
        var t = this, e = this._m, n = e._getEase.bind(e);
        e._getEase = function (e, r) {
          var i = n(e, r);
          return t._dragging ? t._prop.ease : i
        }
      }
    }, {
      key: "_destroyDrag", value: function () {
        var t = this;
        this._dragger && (this._dragger.destroy(), this._dragger = !1), this._moduleEvents.forEach((function (e) {
          t._m.remove(e)
        })), this._moduleEvents = []
      }
    }, {
      key: "destroy", value: function () {
        c(f(h.prototype), "destroy", this).call(this), this._destroyDrag()
      }
    }], n && a(e.prototype, n), r && a(e, r), h
  }(s(n(41)).default);
  e.default = d
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return y
  }));
  var r = n(41), i = n.n(r), o = n(17), s = n.n(o), a = n(78), c = n.n(a);

  function l(t) {
    return l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, l(t)
  }

  function u(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function h(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function f(t, e, n) {
    return f = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = v(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, f(t, e, n || t)
  }

  function d(t, e) {
    return d = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, d(t, e)
  }

  function p(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = v(t);
      if (e) {
        var i = v(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return m(this, n)
    }
  }

  function m(t, e) {
    if (e && ("object" === l(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function v(t) {
    return v = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, v(t)
  }

  !function () {
    var t = "tab-highlight", e = !1;

    function n() {
      e && (e.classList.remove(t), e = !1)
    }

    window.addEventListener("keydown", function (r) {
      if (9 !== r.keyCode) return;
      n(), s()((function () {
        (e = document.activeElement) instanceof HTMLElement && e.classList.add(t)
      }), 50)
    }.bind(this)), window.addEventListener("click", function (t) {
      t.target !== e && n()
    }.bind(this))
  }();
  var g = 40, y = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && d(t, e)
    }(o, t);
    var e, n, r, i = p(o);

    function o() {
      return u(this, o), i.apply(this, arguments)
    }

    return e = o, (n = [{
      key: "_setEvents", value: function () {
        f(v(o.prototype), "_setEvents", this).call(this), this.listener(window, "keydown", this._onkeydown.bind(this))
      }
    }, {
      key: "_onkeydown", value: function (t) {
        if (9 !== t.keyCode) {
          var e = document.activeElement;
          if (!e || !(e instanceof HTMLInputElement || e instanceof HTMLTextAreaElement)) {
            var n = this._m;
            if (n.prop.run) {
              switch (t.keyCode) {
                case 40:
                  n.targetTop += g;
                  break;
                case 34:
                  n.targetTop += 400;
                  break;
                case 35:
                  n.targetTop = n.scrollHeight;
                  break;
                case 38:
                  n.targetTop -= g;
                  break;
                case 33:
                  n.targetTop -= 400;
                  break;
                case 36:
                  n.targetTop = 0;
                  break;
                case 32:
                  n.targetTop += 200;
                  break;
                case 39:
                  n.targetLeft += g;
                  break;
                case 37:
                  n.targetLeft -= g;
                  break;
                default:
                  return
              }
              36 === t.keyCode && (n.targetTop = 0), n._boundaries(!0), n._boundaries(!1)
            }
          }
        } else this._onTab()
      }
    }, {
      key: "_onTab", value: function () {
        var t = this._m;
        t.prop.run && s()((function () {
          var e = document.activeElement;
          if (e instanceof HTMLElement) {
            if (!c()(e, t.outer)) return;
            var n = t.scrollTop, r = t.scrollLeft, i = e.getBoundingClientRect(), o = t.width / 2 - i.width / 2,
              s = r + (i.left - o), a = t.height / 2 - i.height / 2, l = n + (i.top - a);
            t.targetTop = l, t.targetLeft = s, t.play(), t._boundaries(!0), t._boundaries(!1)
          }
        }), 120)
      }
    }]) && h(e.prototype, n), r && h(e, r), o
  }(i.a)
}, function (t, e) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var n = function (t, e) {
    return function t(e, n) {
      var r = !1;
      return e === n && (r = !0), !0 === r || null !== e && t(e.parentNode, n)
    }(t, e)
  };
  e.default = n
}, function (t, e) {
  "use strict";
  e.a = {tagName: "play-video-button"}
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return o
  }));
  var r = n(1), i = n(24);

  function o() {
    var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
      e = Object(r.f)(".js-open-popup", t || void 0);
    e.forEach((function (t) {
      var e = t.getAttribute("data-popup");
      e && void 0 === t["popup-proceeded"] && (t.addEventListener("click", (function (t) {
        t.preventDefault(), t.stopPropagation(), s(e)
      })), t["popup-proceeded"] = !0)
    }))
  }

  function s(t) {
    Object(i.a)(!0), n.e(0).then(n.bind(null, 126)).then((function (e) {
      e.default("#".concat(t)), Object(i.a)(!1)
    }))
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return i
  }));
  var r = n(2);

  class i extends r.G {
    constructor(t, e = {}) {
      super(t), this.type = "Reflector";
      const n = this, o = void 0 !== e.color ? new r.i(e.color) : new r.i(8355711), s = e.textureWidth || 512,
        a = e.textureHeight || 512, c = e.clipBias || 0, l = e.shader || i.ReflectorShader, u = new r.P, h = new r.nb,
        f = new r.nb, d = new r.nb, p = new r.F, m = new r.nb(0, 0, -1), v = new r.ob, g = new r.nb, y = new r.nb,
        _ = new r.ob, b = new r.F, x = new r.O, w = {minFilter: r.z, magFilter: r.z, format: r.X},
        S = new r.qb(s, a, w);
      r.E.isPowerOfTwo(s) && r.E.isPowerOfTwo(a) || (S.texture.generateMipmaps = !1);
      const M = new r.ab({
        uniforms: r.kb.clone(l.uniforms),
        fragmentShader: l.fragmentShader,
        vertexShader: l.vertexShader
      });
      M.uniforms.tDiffuse.value = S.texture, M.uniforms.color.value = o, M.uniforms.textureMatrix.value = b, this.material = M, this.onBeforeRender = function (t, e, r) {
        if (f.setFromMatrixPosition(n.matrixWorld), d.setFromMatrixPosition(r.matrixWorld), p.extractRotation(n.matrixWorld), h.set(0, 0, 1), h.applyMatrix4(p), g.subVectors(f, d), g.dot(h) > 0) return;
        g.reflect(h).negate(), g.add(f), p.extractRotation(r.matrixWorld), m.set(0, 0, -1), m.applyMatrix4(p), m.add(d), y.subVectors(f, m), y.reflect(h).negate(), y.add(f), x.position.copy(g), x.up.set(0, 1, 0), x.up.applyMatrix4(p), x.up.reflect(h), x.lookAt(y), x.far = r.far, x.updateMatrixWorld(), x.projectionMatrix.copy(r.projectionMatrix), b.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), b.multiply(x.projectionMatrix), b.multiply(x.matrixWorldInverse), b.multiply(n.matrixWorld), u.setFromNormalAndCoplanarPoint(h, f), u.applyMatrix4(x.matrixWorldInverse), v.set(u.normal.x, u.normal.y, u.normal.z, u.constant);
        const i = x.projectionMatrix;
        _.x = (Math.sign(v.x) + i.elements[8]) / i.elements[0], _.y = (Math.sign(v.y) + i.elements[9]) / i.elements[5], _.z = -1, _.w = (1 + i.elements[10]) / i.elements[14], v.multiplyScalar(2 / v.dot(_)), i.elements[2] = v.x, i.elements[6] = v.y, i.elements[10] = v.z + 1 - c, i.elements[14] = v.w, S.texture.encoding = t.outputEncoding, n.visible = !1;
        const o = t.getRenderTarget(), s = t.xr.enabled, a = t.shadowMap.autoUpdate;
        t.xr.enabled = !1, t.shadowMap.autoUpdate = !1, t.setRenderTarget(S), t.state.buffers.depth.setMask(!0), !1 === t.autoClear && t.clear(), t.render(e, x), t.xr.enabled = s, t.shadowMap.autoUpdate = a, t.setRenderTarget(o);
        const l = r.viewport;
        void 0 !== l && t.state.viewport(l), n.visible = !0
      }, this.getRenderTarget = function () {
        return S
      }
    }
  }

  i.prototype.isReflector = !0, i.ReflectorShader = {
    uniforms: {
      color: {value: null},
      tDiffuse: {value: null},
      textureMatrix: {value: null}
    },
    vertexShader: "\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader: "\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}"
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return i
  }));
  var r = n(0);

  function i(t) {
    var e = !1;
    return function n() {
      if (e) return;
      var i = r.a.vevetPage;
      if (i && i.pageCreated) return void t();
      setTimeout((function () {
        n()
      }), 30)
    }(), {
      destroy: function () {
        e = !0
      }
    }
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return i
  }));
  var r = n(1);

  function i(t) {
    return new Promise((function (e) {
      if ("undefined" != typeof DeviceMotionEvent) if ("function" == typeof DeviceMotionEvent.requestPermission) DeviceMotionEvent.requestPermission().then((function (n) {
        if ("granted" === n) {
          var i = Object(r.a)(window, "deviceorientation", t);
          e(i)
        }
      })); else {
        var n = Object(r.a)(window, "deviceorientation", t);
        e(n)
      }
    }))
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return o
  }));
  var r = n(2), i = n(21);

  class o extends i.b {
    constructor(t, e, n, i, o) {
      super(), this.scene = t, this.camera = e, this.overrideMaterial = n, this.clearColor = i, this.clearAlpha = void 0 !== o ? o : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new r.i
    }

    render(t, e, n) {
      const r = t.autoClear;
      let i, o;
      t.autoClear = !1, void 0 !== this.overrideMaterial && (o = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (t.getClearColor(this._oldClearColor), i = t.getClearAlpha(), t.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && t.clearDepth(), t.setRenderTarget(this.renderToScreen ? null : n), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), t.render(this.scene, this.camera), this.clearColor && t.setClearColor(this._oldClearColor, i), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = o), t.autoClear = r
    }
  }
}, function (t, e) {
  "use strict";
  e.a = {tagName: "gl-sphere-core", traceBoundingFrames: 30, movementMultiplier: 1.5}
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = l(n(61)), o = l(n(6)), s = l(n(10)), a = l(n(8)), c = l(n(33));

  function l(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function u(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function h(t, e, n) {
    return h = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = m(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, h(t, e, n || t)
  }

  function f(t, e) {
    return f = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, f(t, e)
  }

  function d(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = m(t);
      if (e) {
        var i = m(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return p(this, n)
    }
  }

  function p(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function m(t) {
    return m = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, m(t)
  }

  var v = n(39), g = n(122), y = n(123), _ = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && f(t, e)
    }(l, t);
    var e, n, r, i = d(l);

    function l(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, l), i.call(this, t)
    }

    return e = l, (n = [{
      key: "prefix", get: function () {
        return "".concat(this._v.prefix, "text")
      }
    }, {
      key: "playing", get: function () {
        return this._playing
      }
    }, {
      key: "_extra", value: function () {
        this._playing = !1, this._timeline = !1, h(m(l.prototype), "_extra", this).call(this)
      }
    }, {
      key: "_resize", value: function () {
        var t = this;
        setTimeout((function () {
          t._resizeText()
        }), this._prop.resizeTimeout)
      }
    }, {
      key: "_resizeText", value: function () {
        var t = this;
        this._playing ? this._timeline.add({
          target: "end", do: function () {
            t._resizeFunc()
          }, once: !0
        }) : this._resizeFunc()
      }
    }, {
      key: "play", value: function (t) {
        if (this._playing) return this._timeline;
        var e = {
          types: ["letter"],
          durationElement: 250,
          durationAuto: !0,
          duration: 2500,
          easing: "linear",
          easingEl: this._vp.easing,
          letter: [],
          word: [],
          line: [],
          shift: .2,
          shiftLine: .2,
          reverse: !1,
          reverseComposite: !1,
          shuffle: !1,
          center: !1,
          callbacks: []
        };
        (e = (0, o.default)(e, t)).letter = this._mergeSettingStyle(e.letter), e.word = this._mergeSettingStyle(e.word), e.line = this._mergeSettingStyle(e.line);
        for (var n = [], r = 0; r < e.types.length; r++) {
          var i = e.types[r], s = i;
          "letter" !== i && "word" !== i && "line" !== i || (s = "elementary"), "lineletter" !== i && "lineword" !== i && "wordletter" !== i || (s = "composite_elementary"), void 0 !== this["animate_".concat(s)] && n.push(this["animate_".concat(s)](e, i))
        }
        if (0 === n.length) return !1;
        var a = this._calcTypesTime(n);
        return this._timeline = this._animate(a, e), this._timeline
      }
    }, {
      key: "_mergeSettingStyle", value: function (t) {
        for (var e = 0; e < t.length; e++) {
          var n = t[e];
          void 0 === n.scope && (n.scope = [0, 1]), void 0 === n.remove && (n.remove = !1)
        }
        return t
      }
    }, {
      key: "_animationInfo", value: function (t) {
        var e = t.el.length, n = t.el.slice(), r = t.duration, i = [];
        if (t.durationAuto) {
          r = e * t.durationElement - (e - 1) * t.shift * t.durationElement;
          for (var o = 0; o < e; o++) {
            var s = t.durationElement * (1 - t.shift) * o, a = s + t.durationElement;
            i.push({start: s / r, end: a / r})
          }
        } else for (var c = 1 / (e - t.shift * (e - 1)), l = 0; l < e; l++) {
          var u = c * (1 - t.shift) * l, h = u + c;
          i.push({start: u, end: h})
        }
        for (var f = 0; f < i.length; f++) i[f].el = n[f];
        return {duration: r, timelines: i, styles: t.styles}
      }
    }, {
      key: "_calcTypesTime", value: function (t) {
        for (var e = [], n = 0; n < t.length; n++) e.push(t[n].duration);
        for (var r = Math.max.apply(Math, e), i = 0; i < t.length; i++) t[i].scope = [0, t[i].duration / r];
        return {animations: t, duration: r}
      }
    }, {
      key: "_animate", value: function (t, e) {
        var n = this, r = new s.default;
        r.add({target: "progress", do: this._animateTypes.bind(this, t, e)});
        for (var i = e.callbacks.slice(), o = 0; o < i.length; o++) i[o].proceeded = !1;
        return r.add({target: "progress", do: this._callbacks.bind(this, i)}), r.add({
          target: "end", do: function () {
            n._playing = !1
          }
        }), this._playing = !0, r.play({duration: t.duration, easing: e.easing}), r
      }
    }, {
      key: "_animateTypes", value: function (t, e, n) {
        for (var r = t.animations, i = 0; i < r.length; i++) {
          var o = 0, s = r[i].scope;
          n.se >= s[0] & n.se <= s[1] ? o = (0, a.default)(n.se, s) : n.se > s[1] && (o = 1), this._animateType(o, r[i], e)
        }
      }
    }, {
      key: "_animateType", value: function (t, e, n) {
        for (var r = 0; r < e.timelines.length; r++) {
          var i = 0, o = e.timelines[r];
          t >= o.start & t <= o.end ? i = (0, a.default)(t, [o.start, o.end]) : t > o.end && (i = 1);
          var s = {styles: e.styles, p: i, prop: n, position: r, total: e.timelines.length}, c = o.el;
          if (v(c)) for (var l = 0; l < c.length; l++) this._animateTypeChildren(Object.assign(s, {el: c[l]})); else this._animateTypeChildren(Object.assign(s, {el: c}))
        }
      }
    }, {
      key: "_animateTypeChildren", value: function (t) {
        this._animateEl({el: t.el, styles: t.styles, p: t.p, prop: t.prop, position: t.position, total: t.total})
      }
    }, {
      key: "_animateEl", value: function (t) {
        for (var e = t.p, n = t.el.el, r = t.prop, i = 0; i < t.styles.length; i++) {
          var o = t.styles[i], s = o.scope, l = o.property, u = o.value, h = o.remove, f = 0, d = 0;
          e >= s[0] & e <= s[1] ? (f = (0, a.default)(e, s), d = (0, c.default)(f, r.easingEl)) : e > s[1] && (f = 1, d = 1);
          var p = !1;
          if (1 == f & h && (p = !0), p) l && (n.style[l] = ""); else {
            var m = u({p: f, e: d, position: t.position, total: t.total, el: n});
            l && (n.style[l] = m)
          }
        }
      }
    }, {
      key: "_callbacks", value: function (t, e) {
        for (var n = 0; n < t.length; n++) {
          var r = t[n];
          e.se >= r.target && (r.proceeded || (r.proceeded = !0, r.do()))
        }
      }
    }]) && u(e.prototype, n), r && u(e, r), l
  }(i.default);
  e.default = _, _.prototype.animate_elementary = g, _.prototype.animate_composite_elementary = y
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return ai
  }));
  var r = n(35);

  function i(t) {
    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t
  }

  function o(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
  }

  var s, a, c, l, u, h, f, d, p, m, v, g, y, _, b, x, w, S, M, E, T, O, H, A, P, R, L, C,
    k = {autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: {lineHeight: ""}},
    D = {duration: .5, overwrite: !1, delay: 0}, N = 1e8, z = 1e-8, j = 2 * Math.PI, I = j / 4, B = 0, F = Math.sqrt,
    U = Math.cos, G = Math.sin, V = function (t) {
      return "string" == typeof t
    }, W = function (t) {
      return "function" == typeof t
    }, X = function (t) {
      return "number" == typeof t
    }, q = function (t) {
      return void 0 === t
    }, Y = function (t) {
      return "object" == typeof t
    }, Z = function (t) {
      return !1 !== t
    }, J = function () {
      return "undefined" != typeof window
    }, K = function (t) {
      return W(t) || V(t)
    }, Q = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () {
    }, $ = Array.isArray, tt = /(?:-?\.?\d|\.)+/gi, et = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    nt = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, rt = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, it = /[+-]=-?[.\d]+/,
    ot = /[^,'"\[\]\s]+/gi, st = /[\d.+\-=]+(?:e[-+]\d*)*/i, at = {}, ct = {}, lt = function (t) {
      return (ct = kt(t, at)) && wn
    }, ut = function (t, e) {
      return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
    }, ht = function (t, e) {
      return !e && console.warn(t)
    }, ft = function (t, e) {
      return t && (at[t] = e) && ct && (ct[t] = e) || at
    }, dt = function () {
      return 0
    }, pt = {}, mt = [], vt = {}, gt = {}, yt = {}, _t = 30, bt = [], xt = "", wt = function (t) {
      var e, n, r = t[0];
      if (Y(r) || W(r) || (t = [t]), !(e = (r._gsap || {}).harness)) {
        for (n = bt.length; n-- && !bt[n].targetTest(r);) ;
        e = bt[n]
      }
      for (n = t.length; n--;) t[n] && (t[n]._gsap || (t[n]._gsap = new Xe(t[n], e))) || t.splice(n, 1);
      return t
    }, St = function (t) {
      return t._gsap || wt(he(t))[0]._gsap
    }, Mt = function (t, e, n) {
      return (n = t[e]) && W(n) ? t[e]() : q(n) && t.getAttribute && t.getAttribute(e) || n
    }, Et = function (t, e) {
      return (t = t.split(",")).forEach(e) || t
    }, Tt = function (t) {
      return Math.round(1e5 * t) / 1e5 || 0
    }, Ot = function (t, e) {
      for (var n = e.length, r = 0; t.indexOf(e[r]) < 0 && ++r < n;) ;
      return r < n
    }, Ht = function () {
      var t, e, n = mt.length, r = mt.slice(0);
      for (vt = {}, mt.length = 0, t = 0; t < n; t++) (e = r[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
    }, At = function (t, e, n, r) {
      mt.length && Ht(), t.render(e, n, r), mt.length && Ht()
    }, Pt = function (t) {
      var e = parseFloat(t);
      return (e || 0 === e) && (t + "").match(ot).length < 2 ? e : V(t) ? t.trim() : t
    }, Rt = function (t) {
      return t
    }, Lt = function (t, e) {
      for (var n in e) n in t || (t[n] = e[n]);
      return t
    }, Ct = function (t, e) {
      for (var n in e) n in t || "duration" === n || "ease" === n || (t[n] = e[n])
    }, kt = function (t, e) {
      for (var n in e) t[n] = e[n];
      return t
    }, Dt = function t(e, n) {
      for (var r in n) "__proto__" !== r && "constructor" !== r && "prototype" !== r && (e[r] = Y(n[r]) ? t(e[r] || (e[r] = {}), n[r]) : n[r]);
      return e
    }, Nt = function (t, e) {
      var n, r = {};
      for (n in t) n in e || (r[n] = t[n]);
      return r
    }, zt = function (t) {
      var e = t.parent || a, n = t.keyframes ? Ct : Lt;
      if (Z(t.inherit)) for (; e;) n(t, e.vars.defaults), e = e.parent || e._dp;
      return t
    }, jt = function (t, e, n, r) {
      void 0 === n && (n = "_first"), void 0 === r && (r = "_last");
      var i = e._prev, o = e._next;
      i ? i._next = o : t[n] === e && (t[n] = o), o ? o._prev = i : t[r] === e && (t[r] = i), e._next = e._prev = e.parent = null
    }, It = function (t, e) {
      t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t), t._act = 0
    }, Bt = function (t, e) {
      if (t && (!e || e._end > t._dur || e._start < 0)) for (var n = t; n;) n._dirty = 1, n = n.parent;
      return t
    }, Ft = function (t) {
      for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
      return t
    }, Ut = function t(e) {
      return !e || e._ts && t(e.parent)
    }, Gt = function (t) {
      return t._repeat ? Vt(t._tTime, t = t.duration() + t._rDelay) * t : 0
    }, Vt = function (t, e) {
      var n = Math.floor(t /= e);
      return t && n === t ? n - 1 : n
    }, Wt = function (t, e) {
      return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
    }, Xt = function (t) {
      return t._end = Tt(t._start + (t._tDur / Math.abs(t._ts || t._rts || z) || 0))
    }, qt = function (t, e) {
      var n = t._dp;
      return n && n.smoothChildTiming && t._ts && (t._start = Tt(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), Xt(t), n._dirty || Bt(n, t)), t
    }, Yt = function (t, e) {
      var n;
      if ((e._time || e._initted && !e._dur) && (n = Wt(t.rawTime(), e), (!e._dur || se(0, e.totalDuration(), n) - e._tTime > z) && e.render(n, !0)), Bt(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
        if (t._dur < t.duration()) for (n = t; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
        t._zTime = -1e-8
      }
    }, Zt = function (t, e, n, r) {
      return e.parent && It(e), e._start = Tt((X(n) ? n : n || t !== a ? re(t, n, e) : t._time) + e._delay), e._end = Tt(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), function (t, e, n, r, i) {
        void 0 === n && (n = "_first"), void 0 === r && (r = "_last");
        var o, s = t[r];
        if (i) for (o = e[i]; s && s[i] > o;) s = s._prev;
        s ? (e._next = s._next, s._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[r] = e, e._prev = s, e.parent = e._dp = t
      }(t, e, "_first", "_last", t._sort ? "_start" : 0), $t(e) || (t._recent = e), r || Yt(t, e), t
    }, Jt = function (t, e) {
      return (at.ScrollTrigger || ut("scrollTrigger", e)) && at.ScrollTrigger.create(e, t)
    }, Kt = function (t, e, n, r) {
      return $e(t, e), t._initted ? !n && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && f !== Ce.frame ? (mt.push(t), t._lazy = [e, r], 1) : void 0 : 1
    }, Qt = function t(e) {
      var n = e.parent;
      return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n))
    }, $t = function (t) {
      var e = t.data;
      return "isFromStart" === e || "isStart" === e
    }, te = function (t, e, n, r) {
      var i = t._repeat, o = Tt(e) || 0, s = t._tTime / t._tDur;
      return s && !r && (t._time *= o / t._dur), t._dur = o, t._tDur = i ? i < 0 ? 1e10 : Tt(o * (i + 1) + t._rDelay * i) : o, s && !r ? qt(t, t._tTime = t._tDur * s) : t.parent && Xt(t), n || Bt(t.parent, t), t
    }, ee = function (t) {
      return t instanceof Ye ? Bt(t) : te(t, t._dur)
    }, ne = {_start: 0, endTime: dt, totalDuration: dt}, re = function t(e, n, r) {
      var i, o, s, a = e.labels, c = e._recent || ne, l = e.duration() >= N ? c.endTime(!1) : e._dur;
      return V(n) && (isNaN(n) || n in a) ? (o = n.charAt(0), s = "%" === n.substr(-1), i = n.indexOf("="), "<" === o || ">" === o ? (i >= 0 && (n = n.replace(/=/, "")), ("<" === o ? c._start : c.endTime(c._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (s ? (i < 0 ? c : r).totalDuration() / 100 : 1)) : i < 0 ? (n in a || (a[n] = l), a[n]) : (o = parseFloat(n.charAt(i - 1) + n.substr(i + 1)), s && r && (o = o / 100 * ($(r) ? r[0] : r).totalDuration()), i > 1 ? t(e, n.substr(0, i - 1), r) + o : l + o)) : null == n ? l : +n
    }, ie = function (t, e, n) {
      var r, i, o = X(e[1]), s = (o ? 2 : 1) + (t < 2 ? 0 : 1), a = e[s];
      if (o && (a.duration = e[1]), a.parent = n, t) {
        for (r = a, i = n; i && !("immediateRender" in r);) r = i.vars.defaults || {}, i = Z(i.vars.inherit) && i.parent;
        a.immediateRender = Z(r.immediateRender), t < 2 ? a.runBackwards = 1 : a.startAt = e[s - 1]
      }
      return new rn(e[0], a, e[s + 1])
    }, oe = function (t, e) {
      return t || 0 === t ? e(t) : e
    }, se = function (t, e, n) {
      return n < t ? t : n > e ? e : n
    }, ae = function (t) {
      if ("string" != typeof t) return "";
      var e = st.exec(t);
      return e ? t.substr(e.index + e[0].length) : ""
    }, ce = [].slice, le = function (t, e) {
      return t && Y(t) && "length" in t && (!e && !t.length || t.length - 1 in t && Y(t[0])) && !t.nodeType && t !== c
    }, ue = function (t, e, n) {
      return void 0 === n && (n = []), t.forEach((function (t) {
        var r;
        return V(t) && !e || le(t, 1) ? (r = n).push.apply(r, he(t)) : n.push(t)
      })) || n
    }, he = function (t, e, n) {
      return !V(t) || n || !l && ke() ? $(t) ? ue(t, n) : le(t) ? ce.call(t, 0) : t ? [t] : [] : ce.call((e || u).querySelectorAll(t), 0)
    }, fe = function (t) {
      return t.sort((function () {
        return .5 - Math.random()
      }))
    }, de = function (t) {
      if (W(t)) return t;
      var e = Y(t) ? t : {each: t}, n = Fe(e.ease), r = e.from || 0, i = parseFloat(e.base) || 0, o = {},
        s = r > 0 && r < 1, a = isNaN(r) || s, c = e.axis, l = r, u = r;
      return V(r) ? l = u = {
        center: .5,
        edges: .5,
        end: 1
      }[r] || 0 : !s && a && (l = r[0], u = r[1]), function (t, s, h) {
        var f, d, p, m, v, g, y, _, b, x = (h || e).length, w = o[x];
        if (!w) {
          if (!(b = "auto" === e.grid ? 0 : (e.grid || [1, N])[1])) {
            for (y = -N; y < (y = h[b++].getBoundingClientRect().left) && b < x;) ;
            b--
          }
          for (w = o[x] = [], f = a ? Math.min(b, x) * l - .5 : r % b, d = a ? x * u / b - .5 : r / b | 0, y = 0, _ = N, g = 0; g < x; g++) p = g % b - f, m = d - (g / b | 0), w[g] = v = c ? Math.abs("y" === c ? m : p) : F(p * p + m * m), v > y && (y = v), v < _ && (_ = v);
          "random" === r && fe(w), w.max = y - _, w.min = _, w.v = x = (parseFloat(e.amount) || parseFloat(e.each) * (b > x ? x - 1 : c ? "y" === c ? x / b : b : Math.max(b, x / b)) || 0) * ("edges" === r ? -1 : 1), w.b = x < 0 ? i - x : i, w.u = ae(e.amount || e.each) || 0, n = n && x < 0 ? Ie(n) : n
        }
        return x = (w[t] - w.min) / w.max || 0, Tt(w.b + (n ? n(x) : x) * w.v) + w.u
      }
    }, pe = function (t) {
      var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
      return function (n) {
        var r = Math.round(parseFloat(n) / t) * t * e;
        return (r - r % 1) / e + (X(n) ? 0 : ae(n))
      }
    }, me = function (t, e) {
      var n, r, i = $(t);
      return !i && Y(t) && (n = i = t.radius || N, t.values ? (t = he(t.values), (r = !X(t[0])) && (n *= n)) : t = pe(t.increment)), oe(e, i ? W(t) ? function (e) {
        return r = t(e), Math.abs(r - e) <= n ? r : e
      } : function (e) {
        for (var i, o, s = parseFloat(r ? e.x : e), a = parseFloat(r ? e.y : 0), c = N, l = 0, u = t.length; u--;) (i = r ? (i = t[u].x - s) * i + (o = t[u].y - a) * o : Math.abs(t[u] - s)) < c && (c = i, l = u);
        return l = !n || c <= n ? t[l] : e, r || l === e || X(e) ? l : l + ae(e)
      } : pe(t))
    }, ve = function (t, e, n, r) {
      return oe($(t) ? !e : !0 === n ? !!(n = 0) : !r, (function () {
        return $(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (r = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + .99 * n)) / n) * n * r) / r
      }))
    }, ge = function (t, e, n) {
      return oe(n, (function (n) {
        return t[~~e(n)]
      }))
    }, ye = function (t) {
      for (var e, n, r, i, o = 0, s = ""; ~(e = t.indexOf("random(", o));) r = t.indexOf(")", e), i = "[" === t.charAt(e + 7), n = t.substr(e + 7, r - e - 7).match(i ? ot : tt), s += t.substr(o, e - o) + ve(i ? n : +n[0], i ? 0 : +n[1], +n[2] || 1e-5), o = r + 1;
      return s + t.substr(o, t.length - o)
    }, _e = function (t, e, n, r, i) {
      var o = e - t, s = r - n;
      return oe(i, (function (e) {
        return n + ((e - t) / o * s || 0)
      }))
    }, be = function (t, e, n) {
      var r, i, o, s = t.labels, a = N;
      for (r in s) (i = s[r] - e) < 0 == !!n && i && a > (i = Math.abs(i)) && (o = r, a = i);
      return o
    }, xe = function (t, e, n) {
      var r, i, o = t.vars, s = o[e];
      if (s) return r = o[e + "Params"], i = o.callbackScope || t, n && mt.length && Ht(), r ? s.apply(i, r) : s.call(i)
    }, we = function (t) {
      return It(t), t.scrollTrigger && t.scrollTrigger.kill(!1), t.progress() < 1 && xe(t, "onInterrupt"), t
    }, Se = function (t) {
      var e = (t = !t.name && t.default || t).name, n = W(t), r = e && !n && t.init ? function () {
          this._props = []
        } : t, i = {init: dt, render: dn, add: Ke, kill: mn, modifier: pn, rawVars: 0},
        o = {targetTest: 0, get: 0, getSetter: ln, aliases: {}, register: 0};
      if (ke(), t !== r) {
        if (gt[e]) return;
        Lt(r, Lt(Nt(t, i), o)), kt(r.prototype, kt(i, Nt(t, o))), gt[r.prop = e] = r, t.targetTest && (bt.push(r), pt[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
      }
      ft(e, r), t.register && t.register(wn, r, yn)
    }, Me = 255, Ee = {
      aqua: [0, Me, Me],
      lime: [0, Me, 0],
      silver: [192, 192, 192],
      black: [0, 0, 0],
      maroon: [128, 0, 0],
      teal: [0, 128, 128],
      blue: [0, 0, Me],
      navy: [0, 0, 128],
      white: [Me, Me, Me],
      olive: [128, 128, 0],
      yellow: [Me, Me, 0],
      orange: [Me, 165, 0],
      gray: [128, 128, 128],
      purple: [128, 0, 128],
      green: [0, 128, 0],
      red: [Me, 0, 0],
      pink: [Me, 192, 203],
      cyan: [0, Me, Me],
      transparent: [Me, Me, Me, 0]
    }, Te = function (t, e, n) {
      return (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * Me + .5 | 0
    }, Oe = function (t, e, n) {
      var r, i, o, s, a, c, l, u, h, f, d = t ? X(t) ? [t >> 16, t >> 8 & Me, t & Me] : 0 : Ee.black;
      if (!d) {
        if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), Ee[t]) d = Ee[t]; else if ("#" === t.charAt(0)) {
          if (t.length < 6 && (r = t.charAt(1), i = t.charAt(2), o = t.charAt(3), t = "#" + r + r + i + i + o + o + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")), 9 === t.length) return [(d = parseInt(t.substr(1, 6), 16)) >> 16, d >> 8 & Me, d & Me, parseInt(t.substr(7), 16) / 255];
          d = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & Me, t & Me]
        } else if ("hsl" === t.substr(0, 3)) if (d = f = t.match(tt), e) {
          if (~t.indexOf("=")) return d = t.match(et), n && d.length < 4 && (d[3] = 1), d
        } else s = +d[0] % 360 / 360, a = +d[1] / 100, r = 2 * (c = +d[2] / 100) - (i = c <= .5 ? c * (a + 1) : c + a - c * a), d.length > 3 && (d[3] *= 1), d[0] = Te(s + 1 / 3, r, i), d[1] = Te(s, r, i), d[2] = Te(s - 1 / 3, r, i); else d = t.match(tt) || Ee.transparent;
        d = d.map(Number)
      }
      return e && !f && (r = d[0] / Me, i = d[1] / Me, o = d[2] / Me, c = ((l = Math.max(r, i, o)) + (u = Math.min(r, i, o))) / 2, l === u ? s = a = 0 : (h = l - u, a = c > .5 ? h / (2 - l - u) : h / (l + u), s = l === r ? (i - o) / h + (i < o ? 6 : 0) : l === i ? (o - r) / h + 2 : (r - i) / h + 4, s *= 60), d[0] = ~~(s + .5), d[1] = ~~(100 * a + .5), d[2] = ~~(100 * c + .5)), n && d.length < 4 && (d[3] = 1), d
    }, He = function (t) {
      var e = [], n = [], r = -1;
      return t.split(Pe).forEach((function (t) {
        var i = t.match(nt) || [];
        e.push.apply(e, i), n.push(r += i.length + 1)
      })), e.c = n, e
    }, Ae = function (t, e, n) {
      var r, i, o, s, a = "", c = (t + a).match(Pe), l = e ? "hsla(" : "rgba(", u = 0;
      if (!c) return t;
      if (c = c.map((function (t) {
        return (t = Oe(t, e, 1)) && l + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
      })), n && (o = He(t), (r = n.c).join(a) !== o.c.join(a))) for (s = (i = t.replace(Pe, "1").split(nt)).length - 1; u < s; u++) a += i[u] + (~r.indexOf(u) ? c.shift() || l + "0,0,0,0)" : (o.length ? o : c.length ? c : n).shift());
      if (!i) for (s = (i = t.split(Pe)).length - 1; u < s; u++) a += i[u] + c[u];
      return a + i[s]
    }, Pe = function () {
      var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
      for (t in Ee) e += "|" + t + "\\b";
      return new RegExp(e + ")", "gi")
    }(), Re = /hsl[a]?\(/, Le = function (t) {
      var e, n = t.join(" ");
      if (Pe.lastIndex = 0, Pe.test(n)) return e = Re.test(n), t[1] = Ae(t[1], e), t[0] = Ae(t[0], e, He(t[1])), !0
    }, Ce = (x = Date.now, w = 500, S = 33, M = x(), E = M, O = T = 1e3 / 240, A = function t(e) {
      var n, r, i, o, s = x() - E, a = !0 === e;
      if (s > w && (M += s - S), ((n = (i = (E += s) - M) - O) > 0 || a) && (o = ++y.frame, _ = i - 1e3 * y.time, y.time = i /= 1e3, O += n + (n >= T ? 4 : T - n), r = 1), a || (m = v(t)), r) for (b = 0; b < H.length; b++) H[b](i, _, o, e)
    }, y = {
      time: 0, frame: 0, tick: function () {
        A(!0)
      }, deltaRatio: function (t) {
        return _ / (1e3 / (t || 60))
      }, wake: function () {
        h && (!l && J() && (c = l = window, u = c.document || {}, at.gsap = wn, (c.gsapVersions || (c.gsapVersions = [])).push(wn.version), lt(ct || c.GreenSockGlobals || !c.gsap && c || {}), g = c.requestAnimationFrame), m && y.sleep(), v = g || function (t) {
          return setTimeout(t, O - 1e3 * y.time + 1 | 0)
        }, p = 1, A(2))
      }, sleep: function () {
        (g ? c.cancelAnimationFrame : clearTimeout)(m), p = 0, v = dt
      }, lagSmoothing: function (t, e) {
        w = t || 1e8, S = Math.min(e, w, 0)
      }, fps: function (t) {
        T = 1e3 / (t || 240), O = 1e3 * y.time + T
      }, add: function (t) {
        H.indexOf(t) < 0 && H.push(t), ke()
      }, remove: function (t) {
        var e;
        ~(e = H.indexOf(t)) && H.splice(e, 1) && b >= e && b--
      }, _listeners: H = []
    }), ke = function () {
      return !p && Ce.wake()
    }, De = {}, Ne = /^[\d.\-M][\d.\-,\s]/, ze = /["']/g, je = function (t) {
      for (var e, n, r, i = {}, o = t.substr(1, t.length - 3).split(":"), s = o[0], a = 1, c = o.length; a < c; a++) n = o[a], e = a !== c - 1 ? n.lastIndexOf(",") : n.length, r = n.substr(0, e), i[s] = isNaN(r) ? r.replace(ze, "").trim() : +r, s = n.substr(e + 1).trim();
      return i
    }, Ie = function (t) {
      return function (e) {
        return 1 - t(1 - e)
      }
    }, Be = function t(e, n) {
      for (var r, i = e._first; i;) i instanceof Ye ? t(i, n) : !i.vars.yoyoEase || i._yoyo && i._repeat || i._yoyo === n || (i.timeline ? t(i.timeline, n) : (r = i._ease, i._ease = i._yEase, i._yEase = r, i._yoyo = n)), i = i._next
    }, Fe = function (t, e) {
      return t && (W(t) ? t : De[t] || function (t) {
        var e, n, r, i, o = (t + "").split("("), s = De[o[0]];
        return s && o.length > 1 && s.config ? s.config.apply(null, ~t.indexOf("{") ? [je(o[1])] : (e = t, n = e.indexOf("(") + 1, r = e.indexOf(")"), i = e.indexOf("(", n), e.substring(n, ~i && i < r ? e.indexOf(")", r + 1) : r)).split(",").map(Pt)) : De._CE && Ne.test(t) ? De._CE("", t) : s
      }(t)) || e
    }, Ue = function (t, e, n, r) {
      void 0 === n && (n = function (t) {
        return 1 - e(1 - t)
      }), void 0 === r && (r = function (t) {
        return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
      });
      var i, o = {easeIn: e, easeOut: n, easeInOut: r};
      return Et(t, (function (t) {
        for (var e in De[t] = at[t] = o, De[i = t.toLowerCase()] = n, o) De[i + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = De[t + "." + e] = o[e]
      })), o
    }, Ge = function (t) {
      return function (e) {
        return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
      }
    }, Ve = function t(e, n, r) {
      var i = n >= 1 ? n : 1, o = (r || (e ? .3 : .45)) / (n < 1 ? n : 1), s = o / j * (Math.asin(1 / i) || 0),
        a = function (t) {
          return 1 === t ? 1 : i * Math.pow(2, -10 * t) * G((t - s) * o) + 1
        }, c = "out" === e ? a : "in" === e ? function (t) {
          return 1 - a(1 - t)
        } : Ge(a);
      return o = j / o, c.config = function (n, r) {
        return t(e, n, r)
      }, c
    }, We = function t(e, n) {
      void 0 === n && (n = 1.70158);
      var r = function (t) {
        return t ? --t * t * ((n + 1) * t + n) + 1 : 0
      }, i = "out" === e ? r : "in" === e ? function (t) {
        return 1 - r(1 - t)
      } : Ge(r);
      return i.config = function (n) {
        return t(e, n)
      }, i
    };
  Et("Linear,Quad,Cubic,Quart,Quint,Strong", (function (t, e) {
    var n = e < 5 ? e + 1 : e;
    Ue(t + ",Power" + (n - 1), e ? function (t) {
      return Math.pow(t, n)
    } : function (t) {
      return t
    }, (function (t) {
      return 1 - Math.pow(1 - t, n)
    }), (function (t) {
      return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2
    }))
  })), De.Linear.easeNone = De.none = De.Linear.easeIn, Ue("Elastic", Ve("in"), Ve("out"), Ve()), P = 7.5625, L = 1 / (R = 2.75), Ue("Bounce", (function (t) {
    return 1 - C(1 - t)
  }), C = function (t) {
    return t < L ? P * t * t : t < .7272727272727273 ? P * Math.pow(t - 1.5 / R, 2) + .75 : t < .9090909090909092 ? P * (t -= 2.25 / R) * t + .9375 : P * Math.pow(t - 2.625 / R, 2) + .984375
  }), Ue("Expo", (function (t) {
    return t ? Math.pow(2, 10 * (t - 1)) : 0
  })), Ue("Circ", (function (t) {
    return -(F(1 - t * t) - 1)
  })), Ue("Sine", (function (t) {
    return 1 === t ? 1 : 1 - U(t * I)
  })), Ue("Back", We("in"), We("out"), We()), De.SteppedEase = De.steps = at.SteppedEase = {
    config: function (t, e) {
      void 0 === t && (t = 1);
      var n = 1 / t, r = t + (e ? 0 : 1), i = e ? 1 : 0;
      return function (t) {
        return ((r * se(0, .99999999, t) | 0) + i) * n
      }
    }
  }, D.ease = De["quad.out"], Et("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (t) {
    return xt += t + "," + t + "Params,"
  }));
  var Xe = function (t, e) {
    this.id = B++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : Mt, this.set = e ? e.getSetter : ln
  }, qe = function () {
    function t(t) {
      this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, te(this, +t.duration, 1, 1), this.data = t.data, p || Ce.wake()
    }

    var e = t.prototype;
    return e.delay = function (t) {
      return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
    }, e.duration = function (t) {
      return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
    }, e.totalDuration = function (t) {
      return arguments.length ? (this._dirty = 0, te(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
    }, e.totalTime = function (t, e) {
      if (ke(), !arguments.length) return this._tTime;
      var n = this._dp;
      if (n && n.smoothChildTiming && this._ts) {
        for (qt(this, t), !n._dp || n.parent || Yt(n, this); n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
        !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && Zt(this._dp, this, this._start - this._delay)
      }
      return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === z || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), At(this, t, e)), this
    }, e.time = function (t, e) {
      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Gt(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time
    }, e.totalProgress = function (t, e) {
      return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
    }, e.progress = function (t, e) {
      return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Gt(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
    }, e.iteration = function (t, e) {
      var n = this.duration() + this._rDelay;
      return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? Vt(this._tTime, n) + 1 : 1
    }, e.timeScale = function (t) {
      if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
      if (this._rts === t) return this;
      var e = this.parent && this._ts ? Wt(this.parent._time, this) : this._tTime;
      return this._rts = +t || 0, this._ts = this._ps || -1e-8 === t ? 0 : this._rts, Ft(this.totalTime(se(-this._delay, this._tDur, e), !0))
    }, e.paused = function (t) {
      return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (ke(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== z && (this._tTime -= z)))), this) : this._ps
    }, e.startTime = function (t) {
      if (arguments.length) {
        this._start = t;
        var e = this.parent || this._dp;
        return e && (e._sort || !this.parent) && Zt(e, this, t - this._delay), this
      }
      return this._start
    }, e.endTime = function (t) {
      return this._start + (Z(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts)
    }, e.rawTime = function (t) {
      var e = this.parent || this._dp;
      return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Wt(e.rawTime(t), this) : this._tTime : this._tTime
    }, e.globalTime = function (t) {
      for (var e = this, n = arguments.length ? t : e.rawTime(); e;) n = e._start + n / (e._ts || 1), e = e._dp;
      return n
    }, e.repeat = function (t) {
      return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, ee(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
    }, e.repeatDelay = function (t) {
      if (arguments.length) {
        var e = this._time;
        return this._rDelay = t, ee(this), e ? this.time(e) : this
      }
      return this._rDelay
    }, e.yoyo = function (t) {
      return arguments.length ? (this._yoyo = t, this) : this._yoyo
    }, e.seek = function (t, e) {
      return this.totalTime(re(this, t), Z(e))
    }, e.restart = function (t, e) {
      return this.play().totalTime(t ? -this._delay : 0, Z(e))
    }, e.play = function (t, e) {
      return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
    }, e.reverse = function (t, e) {
      return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
    }, e.pause = function (t, e) {
      return null != t && this.seek(t, e), this.paused(!0)
    }, e.resume = function () {
      return this.paused(!1)
    }, e.reversed = function (t) {
      return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0
    }, e.invalidate = function () {
      return this._initted = this._act = 0, this._zTime = -1e-8, this
    }, e.isActive = function () {
      var t, e = this.parent || this._dp, n = this._start;
      return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - z))
    }, e.eventCallback = function (t, e, n) {
      var r = this.vars;
      return arguments.length > 1 ? (e ? (r[t] = e, n && (r[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete r[t], this) : r[t]
    }, e.then = function (t) {
      var e = this;
      return new Promise((function (n) {
        var r = W(t) ? t : Rt, i = function () {
          var t = e.then;
          e.then = null, W(r) && (r = r(e)) && (r.then || r === e) && (e.then = t), n(r), e.then = t
        };
        e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? i() : e._prom = i
      }))
    }, e.kill = function () {
      we(this)
    }, t
  }();
  Lt(qe.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -1e-8,
    _prom: 0,
    _ps: !1,
    _rts: 1
  });
  var Ye = function (t) {
    function e(e, n) {
      var r;
      return void 0 === e && (e = {}), (r = t.call(this, e) || this).labels = {}, r.smoothChildTiming = !!e.smoothChildTiming, r.autoRemoveChildren = !!e.autoRemoveChildren, r._sort = Z(e.sortChildren), a && Zt(e.parent || a, i(r), n), e.reversed && r.reverse(), e.paused && r.paused(!0), e.scrollTrigger && Jt(i(r), e.scrollTrigger), r
    }

    o(e, t);
    var n = e.prototype;
    return n.to = function (t, e, n) {
      return ie(0, arguments, this), this
    }, n.from = function (t, e, n) {
      return ie(1, arguments, this), this
    }, n.fromTo = function (t, e, n, r) {
      return ie(2, arguments, this), this
    }, n.set = function (t, e, n) {
      return e.duration = 0, e.parent = this, zt(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new rn(t, e, re(this, n), 1), this
    }, n.call = function (t, e, n) {
      return Zt(this, rn.delayedCall(0, t, e), n)
    }, n.staggerTo = function (t, e, n, r, i, o, s) {
      return n.duration = e, n.stagger = n.stagger || r, n.onComplete = o, n.onCompleteParams = s, n.parent = this, new rn(t, n, re(this, i)), this
    }, n.staggerFrom = function (t, e, n, r, i, o, s) {
      return n.runBackwards = 1, zt(n).immediateRender = Z(n.immediateRender), this.staggerTo(t, e, n, r, i, o, s)
    }, n.staggerFromTo = function (t, e, n, r, i, o, s, a) {
      return r.startAt = n, zt(r).immediateRender = Z(r.immediateRender), this.staggerTo(t, e, r, i, o, s, a)
    }, n.render = function (t, e, n) {
      var r, i, o, s, c, l, u, h, f, d, p, m, v = this._time, g = this._dirty ? this.totalDuration() : this._tDur,
        y = this._dur, _ = this !== a && t > g - z && t >= 0 ? g : t < z ? 0 : t,
        b = this._zTime < 0 != t < 0 && (this._initted || !y);
      if (_ !== this._tTime || n || b) {
        if (v !== this._time && y && (_ += this._time - v, t += this._time - v), r = _, f = this._start, l = !(h = this._ts), b && (y || (v = this._zTime), (t || !e) && (this._zTime = t)), this._repeat) {
          if (p = this._yoyo, c = y + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * c + t, e, n);
          if (r = Tt(_ % c), _ === g ? (s = this._repeat, r = y) : ((s = ~~(_ / c)) && s === _ / c && (r = y, s--), r > y && (r = y)), d = Vt(this._tTime, c), !v && this._tTime && d !== s && (d = s), p && 1 & s && (r = y - r, m = 1), s !== d && !this._lock) {
            var x = p && 1 & d, w = x === (p && 1 & s);
            if (s < d && (x = !x), v = x ? 0 : y, this._lock = 1, this.render(v || (m ? 0 : Tt(s * c)), e, !y)._lock = 0, this._tTime = _, !e && this.parent && xe(this, "onRepeat"), this.vars.repeatRefresh && !m && (this.invalidate()._lock = 1), v && v !== this._time || l !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
            if (y = this._dur, g = this._tDur, w && (this._lock = 2, v = x ? y : -1e-4, this.render(v, !0), this.vars.repeatRefresh && !m && this.invalidate()), this._lock = 0, !this._ts && !l) return this;
            Be(this, m)
          }
        }
        if (this._hasPause && !this._forcing && this._lock < 2 && (u = function (t, e, n) {
          var r;
          if (n > e) for (r = t._first; r && r._start <= n;) {
            if (!r._dur && "isPause" === r.data && r._start > e) return r;
            r = r._next
          } else for (r = t._last; r && r._start >= n;) {
            if (!r._dur && "isPause" === r.data && r._start < e) return r;
            r = r._prev
          }
        }(this, Tt(v), Tt(r)), u && (_ -= r - (r = u._start))), this._tTime = _, this._time = r, this._act = !h, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t, v = 0), !v && r && !e && (xe(this, "onStart"), this._tTime !== _)) return this;
        if (r >= v && t >= 0) for (i = this._first; i;) {
          if (o = i._next, (i._act || r >= i._start) && i._ts && u !== i) {
            if (i.parent !== this) return this.render(t, e, n);
            if (i.render(i._ts > 0 ? (r - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (r - i._start) * i._ts, e, n), r !== this._time || !this._ts && !l) {
              u = 0, o && (_ += this._zTime = -1e-8);
              break
            }
          }
          i = o
        } else {
          i = this._last;
          for (var S = t < 0 ? t : r; i;) {
            if (o = i._prev, (i._act || S <= i._end) && i._ts && u !== i) {
              if (i.parent !== this) return this.render(t, e, n);
              if (i.render(i._ts > 0 ? (S - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (S - i._start) * i._ts, e, n), r !== this._time || !this._ts && !l) {
                u = 0, o && (_ += this._zTime = S ? -1e-8 : z);
                break
              }
            }
            i = o
          }
        }
        if (u && !e && (this.pause(), u.render(r >= v ? 0 : -1e-8)._zTime = r >= v ? 1 : -1, this._ts)) return this._start = f, Xt(this), this.render(t, e, n);
        this._onUpdate && !e && xe(this, "onUpdate", !0), (_ === g && g >= this.totalDuration() || !_ && v) && (f !== this._start && Math.abs(h) === Math.abs(this._ts) || this._lock || ((t || !y) && (_ === g && this._ts > 0 || !_ && this._ts < 0) && It(this, 1), e || t < 0 && !v || !_ && !v && g || (xe(this, _ === g && t >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(_ < g && this.timeScale() > 0) && this._prom())))
      }
      return this
    }, n.add = function (t, e) {
      var n = this;
      if (X(e) || (e = re(this, e, t)), !(t instanceof qe)) {
        if ($(t)) return t.forEach((function (t) {
          return n.add(t, e)
        })), this;
        if (V(t)) return this.addLabel(t, e);
        if (!W(t)) return this;
        t = rn.delayedCall(0, t)
      }
      return this !== t ? Zt(this, t, e) : this
    }, n.getChildren = function (t, e, n, r) {
      void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === r && (r = -N);
      for (var i = [], o = this._first; o;) o._start >= r && (o instanceof rn ? e && i.push(o) : (n && i.push(o), t && i.push.apply(i, o.getChildren(!0, e, n)))), o = o._next;
      return i
    }, n.getById = function (t) {
      for (var e = this.getChildren(1, 1, 1), n = e.length; n--;) if (e[n].vars.id === t) return e[n]
    }, n.remove = function (t) {
      return V(t) ? this.removeLabel(t) : W(t) ? this.killTweensOf(t) : (jt(this, t), t === this._recent && (this._recent = this._last), Bt(this))
    }, n.totalTime = function (e, n) {
      return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Tt(Ce.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, n), this._forcing = 0, this) : this._tTime
    }, n.addLabel = function (t, e) {
      return this.labels[t] = re(this, e), this
    }, n.removeLabel = function (t) {
      return delete this.labels[t], this
    }, n.addPause = function (t, e, n) {
      var r = rn.delayedCall(0, e || dt, n);
      return r.data = "isPause", this._hasPause = 1, Zt(this, r, re(this, t))
    }, n.removePause = function (t) {
      var e = this._first;
      for (t = re(this, t); e;) e._start === t && "isPause" === e.data && It(e), e = e._next
    }, n.killTweensOf = function (t, e, n) {
      for (var r = this.getTweensOf(t, n), i = r.length; i--;) Ze !== r[i] && r[i].kill(t, e);
      return this
    }, n.getTweensOf = function (t, e) {
      for (var n, r = [], i = he(t), o = this._first, s = X(e); o;) o instanceof rn ? Ot(o._targets, i) && (s ? (!Ze || o._initted && o._ts) && o.globalTime(0) <= e && o.globalTime(o.totalDuration()) > e : !e || o.isActive()) && r.push(o) : (n = o.getTweensOf(i, e)).length && r.push.apply(r, n), o = o._next;
      return r
    }, n.tweenTo = function (t, e) {
      e = e || {};
      var n, r = this, i = re(r, t), o = e, s = o.startAt, a = o.onStart, c = o.onStartParams, l = o.immediateRender,
        u = rn.to(r, Lt({
          ease: e.ease || "none",
          lazy: !1,
          immediateRender: !1,
          time: i,
          overwrite: "auto",
          duration: e.duration || Math.abs((i - (s && "time" in s ? s.time : r._time)) / r.timeScale()) || z,
          onStart: function () {
            if (r.pause(), !n) {
              var t = e.duration || Math.abs((i - (s && "time" in s ? s.time : r._time)) / r.timeScale());
              u._dur !== t && te(u, t, 0, 1).render(u._time, !0, !0), n = 1
            }
            a && a.apply(u, c || [])
          }
        }, e));
      return l ? u.render(0) : u
    }, n.tweenFromTo = function (t, e, n) {
      return this.tweenTo(e, Lt({startAt: {time: re(this, t)}}, n))
    }, n.recent = function () {
      return this._recent
    }, n.nextLabel = function (t) {
      return void 0 === t && (t = this._time), be(this, re(this, t))
    }, n.previousLabel = function (t) {
      return void 0 === t && (t = this._time), be(this, re(this, t), 1)
    }, n.currentLabel = function (t) {
      return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + z)
    }, n.shiftChildren = function (t, e, n) {
      void 0 === n && (n = 0);
      for (var r, i = this._first, o = this.labels; i;) i._start >= n && (i._start += t, i._end += t), i = i._next;
      if (e) for (r in o) o[r] >= n && (o[r] += t);
      return Bt(this)
    }, n.invalidate = function () {
      var e = this._first;
      for (this._lock = 0; e;) e.invalidate(), e = e._next;
      return t.prototype.invalidate.call(this)
    }, n.clear = function (t) {
      void 0 === t && (t = !0);
      for (var e, n = this._first; n;) e = n._next, this.remove(n), n = e;
      return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), Bt(this)
    }, n.totalDuration = function (t) {
      var e, n, r, i = 0, o = this, s = o._last, c = N;
      if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -t : t));
      if (o._dirty) {
        for (r = o.parent; s;) e = s._prev, s._dirty && s.totalDuration(), (n = s._start) > c && o._sort && s._ts && !o._lock ? (o._lock = 1, Zt(o, s, n - s._delay, 1)._lock = 0) : c = n, n < 0 && s._ts && (i -= n, (!r && !o._dp || r && r.smoothChildTiming) && (o._start += n / o._ts, o._time -= n, o._tTime -= n), o.shiftChildren(-n, !1, -Infinity), c = 0), s._end > i && s._ts && (i = s._end), s = e;
        te(o, o === a && o._time > i ? o._time : i, 1, 1), o._dirty = 0
      }
      return o._tDur
    }, e.updateRoot = function (t) {
      if (a._ts && (At(a, Wt(t, a)), f = Ce.frame), Ce.frame >= _t) {
        _t += k.autoSleep || 120;
        var e = a._first;
        if ((!e || !e._ts) && k.autoSleep && Ce._listeners.length < 2) {
          for (; e && !e._ts;) e = e._next;
          e || Ce.sleep()
        }
      }
    }, e
  }(qe);
  Lt(Ye.prototype, {_lock: 0, _hasPause: 0, _forcing: 0});
  var Ze, Je = function (t, e, n, r, i, o, s) {
      var a, c, l, u, h, f, d, p, m = new yn(this._pt, t, e, 0, 1, fn, null, i), v = 0, g = 0;
      for (m.b = n, m.e = r, n += "", (d = ~(r += "").indexOf("random(")) && (r = ye(r)), o && (o(p = [n, r], t, e), n = p[0], r = p[1]), c = n.match(rt) || []; a = rt.exec(r);) u = a[0], h = r.substring(v, a.index), l ? l = (l + 1) % 5 : "rgba(" === h.substr(-5) && (l = 1), u !== c[g++] && (f = parseFloat(c[g - 1]) || 0, m._pt = {
        _next: m._pt,
        p: h || 1 === g ? h : ",",
        s: f,
        c: "=" === u.charAt(1) ? parseFloat(u.substr(2)) * ("-" === u.charAt(0) ? -1 : 1) : parseFloat(u) - f,
        m: l && l < 4 ? Math.round : 0
      }, v = rt.lastIndex);
      return m.c = v < r.length ? r.substring(v, r.length) : "", m.fp = s, (it.test(r) || d) && (m.e = 0), this._pt = m, m
    }, Ke = function (t, e, n, r, i, o, s, a, c) {
      W(r) && (r = r(i || 0, t, o));
      var l, u = t[e],
        h = "get" !== n ? n : W(u) ? c ? t[e.indexOf("set") || !W(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](c) : t[e]() : u,
        f = W(u) ? c ? an : sn : on;
      if (V(r) && (~r.indexOf("random(") && (r = ye(r)), "=" === r.charAt(1) && ((l = parseFloat(h) + parseFloat(r.substr(2)) * ("-" === r.charAt(0) ? -1 : 1) + (ae(h) || 0)) || 0 === l) && (r = l)), h !== r) return isNaN(h * r) || "" === r ? (!u && !(e in t) && ut(e, r), Je.call(this, t, e, h, r, f, a || k.stringFilter, c)) : (l = new yn(this._pt, t, e, +h || 0, r - (h || 0), "boolean" == typeof u ? hn : un, 0, f), c && (l.fp = c), s && l.modifier(s, this, t), this._pt = l)
    }, Qe = function (t, e, n, r, i, o) {
      var s, a, c, l;
      if (gt[t] && !1 !== (s = new gt[t]).init(i, s.rawVars ? e[t] : function (t, e, n, r, i) {
        if (W(t) && (t = tn(t, i, e, n, r)), !Y(t) || t.style && t.nodeType || $(t) || Q(t)) return V(t) ? tn(t, i, e, n, r) : t;
        var o, s = {};
        for (o in t) s[o] = tn(t[o], i, e, n, r);
        return s
      }(e[t], r, i, o, n), n, r, o) && (n._pt = a = new yn(n._pt, i, t, 0, 1, s.render, s, 0, s.priority), n !== d)) for (c = n._ptLookup[n._targets.indexOf(i)], l = s._props.length; l--;) c[s._props[l]] = a;
      return s
    }, $e = function t(e, n) {
      var r, i, o, c, l, u, h, f, d, p, m, v, g, y = e.vars, _ = y.ease, b = y.startAt, x = y.immediateRender, w = y.lazy,
        S = y.onUpdate, M = y.onUpdateParams, E = y.callbackScope, T = y.runBackwards, O = y.yoyoEase, H = y.keyframes,
        A = y.autoRevert, P = e._dur, R = e._startAt, L = e._targets, C = e.parent,
        k = C && "nested" === C.data ? C.parent._targets : L, N = "auto" === e._overwrite && !s, j = e.timeline;
      if (j && (!H || !_) && (_ = "none"), e._ease = Fe(_, D.ease), e._yEase = O ? Ie(Fe(!0 === O ? _ : O, D.ease)) : 0, O && e._yoyo && !e._repeat && (O = e._yEase, e._yEase = e._ease, e._ease = O), e._from = !j && !!y.runBackwards, !j) {
        if (v = (f = L[0] ? St(L[0]).harness : 0) && y[f.prop], r = Nt(y, pt), R && R.render(-1, !0).kill(), b) if (It(e._startAt = rn.set(L, Lt({
          data: "isStart",
          overwrite: !1,
          parent: C,
          immediateRender: !0,
          lazy: Z(w),
          startAt: null,
          delay: 0,
          onUpdate: S,
          onUpdateParams: M,
          callbackScope: E,
          stagger: 0
        }, b))), n < 0 && !x && !A && e._startAt.render(-1, !0), x) {
          if (n > 0 && !A && (e._startAt = 0), P && n <= 0) return void(n && (e._zTime = n))
        } else !1 === A && (e._startAt = 0); else if (T && P) if (R) !A && (e._startAt = 0); else if (n && (x = !1), o = Lt({
          overwrite: !1,
          data: "isFromStart",
          lazy: x && Z(w),
          immediateRender: x,
          stagger: 0,
          parent: C
        }, r), v && (o[f.prop] = v), It(e._startAt = rn.set(L, o)), n < 0 && e._startAt.render(-1, !0), x) {
          if (!n) return
        } else t(e._startAt, z);
        for (e._pt = 0, w = P && Z(w) || w && !P, i = 0; i < L.length; i++) {
          if (h = (l = L[i])._gsap || wt(L)[i]._gsap, e._ptLookup[i] = p = {}, vt[h.id] && mt.length && Ht(), m = k === L ? i : k.indexOf(l), f && !1 !== (d = new f).init(l, v || r, e, m, k) && (e._pt = c = new yn(e._pt, l, d.name, 0, 1, d.render, d, 0, d.priority), d._props.forEach((function (t) {
            p[t] = c
          })), d.priority && (u = 1)), !f || v) for (o in r) gt[o] && (d = Qe(o, r, e, m, l, k)) ? d.priority && (u = 1) : p[o] = c = Ke.call(e, l, o, "get", r[o], m, k, 0, y.stringFilter);
          e._op && e._op[i] && e.kill(l, e._op[i]), N && e._pt && (Ze = e, a.killTweensOf(l, p, e.globalTime(0)), g = !e.parent, Ze = 0), e._pt && w && (vt[h.id] = 1)
        }
        u && gn(e), e._onInit && e._onInit(e)
      }
      e._onUpdate = S, e._initted = (!e._op || e._pt) && !g
    }, tn = function (t, e, n, r, i) {
      return W(t) ? t.call(e, n, r, i) : V(t) && ~t.indexOf("random(") ? ye(t) : t
    }, en = xt + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
    nn = (en + ",id,stagger,delay,duration,paused,scrollTrigger").split(","), rn = function (t) {
      function e(e, n, r, o) {
        var c;
        "number" == typeof n && (r.duration = n, n = r, r = null);
        var l, u, h, f, d, p, m, v, g = (c = t.call(this, o ? n : zt(n)) || this).vars, y = g.duration, _ = g.delay,
          b = g.immediateRender, x = g.stagger, w = g.overwrite, S = g.keyframes, M = g.defaults, E = g.scrollTrigger,
          T = g.yoyoEase, O = n.parent || a, H = ($(e) || Q(e) ? X(e[0]) : "length" in n) ? [e] : he(e);
        if (c._targets = H.length ? wt(H) : ht("GSAP target " + e + " not found. https://greensock.com", !k.nullTargetWarn) || [], c._ptLookup = [], c._overwrite = w, S || x || K(y) || K(_)) {
          if (n = c.vars, (l = c.timeline = new Ye({
            data: "nested",
            defaults: M || {}
          })).kill(), l.parent = l._dp = i(c), l._start = 0, S) Lt(l.vars.defaults, {ease: "none"}), x ? H.forEach((function (t, e) {
            return S.forEach((function (n, r) {
              return l.to(t, n, r ? ">" : e * x)
            }))
          })) : S.forEach((function (t) {
            return l.to(H, t, ">")
          })); else {
            if (f = H.length, m = x ? de(x) : dt, Y(x)) for (d in x) ~en.indexOf(d) && (v || (v = {}), v[d] = x[d]);
            for (u = 0; u < f; u++) {
              for (d in h = {}, n) nn.indexOf(d) < 0 && (h[d] = n[d]);
              h.stagger = 0, T && (h.yoyoEase = T), v && kt(h, v), p = H[u], h.duration = +tn(y, i(c), u, p, H), h.delay = (+tn(_, i(c), u, p, H) || 0) - c._delay, !x && 1 === f && h.delay && (c._delay = _ = h.delay, c._start += _, h.delay = 0), l.to(p, h, m(u, p, H))
            }
            l.duration() ? y = _ = 0 : c.timeline = 0
          }
          y || c.duration(y = l.duration())
        } else c.timeline = 0;
        return !0 !== w || s || (Ze = i(c), a.killTweensOf(H), Ze = 0), Zt(O, i(c), r), n.reversed && c.reverse(), n.paused && c.paused(!0), (b || !y && !S && c._start === Tt(O._time) && Z(b) && Ut(i(c)) && "nested" !== O.data) && (c._tTime = -1e-8, c.render(Math.max(0, -_))), E && Jt(i(c), E), c
      }

      o(e, t);
      var n = e.prototype;
      return n.render = function (t, e, n) {
        var r, i, o, s, a, c, l, u, h, f = this._time, d = this._tDur, p = this._dur,
          m = t > d - z && t >= 0 ? d : t < z ? 0 : t;
        if (p) {
          if (m !== this._tTime || !t || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 != t < 0) {
            if (r = m, u = this.timeline, this._repeat) {
              if (s = p + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * s + t, e, n);
              if (r = Tt(m % s), m === d ? (o = this._repeat, r = p) : ((o = ~~(m / s)) && o === m / s && (r = p, o--), r > p && (r = p)), (c = this._yoyo && 1 & o) && (h = this._yEase, r = p - r), a = Vt(this._tTime, s), r === f && !n && this._initted) return this;
              o !== a && (u && this._yEase && Be(u, c), !this.vars.repeatRefresh || c || this._lock || (this._lock = n = 1, this.render(Tt(s * o), !0).invalidate()._lock = 0))
            }
            if (!this._initted) {
              if (Kt(this, t < 0 ? t : r, n, e)) return this._tTime = 0, this;
              if (p !== this._dur) return this.render(t, e, n)
            }
            if (this._tTime = m, this._time = r, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = l = (h || this._ease)(r / p), this._from && (this.ratio = l = 1 - l), r && !f && !e && (xe(this, "onStart"), this._tTime !== m)) return this;
            for (i = this._pt; i;) i.r(l, i.d), i = i._next;
            u && u.render(t < 0 ? t : !r && c ? -1e-8 : u._dur * l, e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, n), xe(this, "onUpdate")), this._repeat && o !== a && this.vars.onRepeat && !e && this.parent && xe(this, "onRepeat"), m !== this._tDur && m || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0), (t || !p) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && It(this, 1), e || t < 0 && !f || !m && !f || (xe(this, m === d ? "onComplete" : "onReverseComplete", !0), this._prom && !(m < d && this.timeScale() > 0) && this._prom()))
          }
        } else !function (t, e, n, r) {
          var i, o, s, a = t.ratio,
            c = e < 0 || !e && (!t._start && Qt(t) && (t._initted || !$t(t)) || (t._ts < 0 || t._dp._ts < 0) && !$t(t)) ? 0 : 1,
            l = t._rDelay, u = 0;
          if (l && t._repeat && (u = se(0, t._tDur, e), o = Vt(u, l), s = Vt(t._tTime, l), t._yoyo && 1 & o && (c = 1 - c), o !== s && (a = 1 - c, t.vars.repeatRefresh && t._initted && t.invalidate())), c !== a || r || t._zTime === z || !e && t._zTime) {
            if (!t._initted && Kt(t, e, r, n)) return;
            for (s = t._zTime, t._zTime = e || (n ? z : 0), n || (n = e && !s), t.ratio = c, t._from && (c = 1 - c), t._time = 0, t._tTime = u, i = t._pt; i;) i.r(c, i.d), i = i._next;
            t._startAt && e < 0 && t._startAt.render(e, !0, !0), t._onUpdate && !n && xe(t, "onUpdate"), u && t._repeat && !n && t.parent && xe(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === c && (c && It(t, 1), n || (xe(t, c ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
          } else t._zTime || (t._zTime = e)
        }(this, t, e, n);
        return this
      }, n.targets = function () {
        return this._targets
      }, n.invalidate = function () {
        return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), t.prototype.invalidate.call(this)
      }, n.kill = function (t, e) {
        if (void 0 === e && (e = "all"), !(t || e && "all" !== e)) return this._lazy = this._pt = 0, this.parent ? we(this) : this;
        if (this.timeline) {
          var n = this.timeline.totalDuration();
          return this.timeline.killTweensOf(t, e, Ze && !0 !== Ze.vars.overwrite)._first || we(this), this.parent && n !== this.timeline.totalDuration() && te(this, this._dur * this.timeline._tDur / n, 0, 1), this
        }
        var r, i, o, s, a, c, l, u = this._targets, h = t ? he(t) : u, f = this._ptLookup, d = this._pt;
        if ((!e || "all" === e) && function (t, e) {
          for (var n = t.length, r = n === e.length; r && n-- && t[n] === e[n];) ;
          return n < 0
        }(u, h)) return "all" === e && (this._pt = 0), we(this);
        for (r = this._op = this._op || [], "all" !== e && (V(e) && (a = {}, Et(e, (function (t) {
          return a[t] = 1
        })), e = a), e = function (t, e) {
          var n, r, i, o, s = t[0] ? St(t[0]).harness : 0, a = s && s.aliases;
          if (!a) return e;
          for (r in n = kt({}, e), a) if (r in n) for (i = (o = a[r].split(",")).length; i--;) n[o[i]] = n[r];
          return n
        }(u, e)), l = u.length; l--;) if (~h.indexOf(u[l])) for (a in i = f[l], "all" === e ? (r[l] = e, s = i, o = {}) : (o = r[l] = r[l] || {}, s = e), s) (c = i && i[a]) && ("kill" in c.d && !0 !== c.d.kill(a) || jt(this, c, "_pt"), delete i[a]), "all" !== o && (o[a] = 1);
        return this._initted && !this._pt && d && we(this), this
      }, e.to = function (t, n) {
        return new e(t, n, arguments[2])
      }, e.from = function (t, e) {
        return ie(1, arguments)
      }, e.delayedCall = function (t, n, r, i) {
        return new e(n, 0, {
          immediateRender: !1,
          lazy: !1,
          overwrite: !1,
          delay: t,
          onComplete: n,
          onReverseComplete: n,
          onCompleteParams: r,
          onReverseCompleteParams: r,
          callbackScope: i
        })
      }, e.fromTo = function (t, e, n) {
        return ie(2, arguments)
      }, e.set = function (t, n) {
        return n.duration = 0, n.repeatDelay || (n.repeat = 0), new e(t, n)
      }, e.killTweensOf = function (t, e, n) {
        return a.killTweensOf(t, e, n)
      }, e
    }(qe);
  Lt(rn.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
  }), Et("staggerTo,staggerFrom,staggerFromTo", (function (t) {
    rn[t] = function () {
      var e = new Ye, n = ce.call(arguments, 0);
      return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
    }
  }));
  var on = function (t, e, n) {
    return t[e] = n
  }, sn = function (t, e, n) {
    return t[e](n)
  }, an = function (t, e, n, r) {
    return t[e](r.fp, n)
  }, cn = function (t, e, n) {
    return t.setAttribute(e, n)
  }, ln = function (t, e) {
    return W(t[e]) ? sn : q(t[e]) && t.setAttribute ? cn : on
  }, un = function (t, e) {
    return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e)
  }, hn = function (t, e) {
    return e.set(e.t, e.p, !!(e.s + e.c * t), e)
  }, fn = function (t, e) {
    var n = e._pt, r = "";
    if (!t && e.b) r = e.b; else if (1 === t && e.e) r = e.e; else {
      for (; n;) r = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + r, n = n._next;
      r += e.c
    }
    e.set(e.t, e.p, r, e)
  }, dn = function (t, e) {
    for (var n = e._pt; n;) n.r(t, n.d), n = n._next
  }, pn = function (t, e, n, r) {
    for (var i, o = this._pt; o;) i = o._next, o.p === r && o.modifier(t, e, n), o = i
  }, mn = function (t) {
    for (var e, n, r = this._pt; r;) n = r._next, r.p === t && !r.op || r.op === t ? jt(this, r, "_pt") : r.dep || (e = 1), r = n;
    return !e
  }, vn = function (t, e, n, r) {
    r.mSet(t, e, r.m.call(r.tween, n, r.mt), r)
  }, gn = function (t) {
    for (var e, n, r, i, o = t._pt; o;) {
      for (e = o._next, n = r; n && n.pr > o.pr;) n = n._next;
      (o._prev = n ? n._prev : i) ? o._prev._next = o : r = o, (o._next = n) ? n._prev = o : i = o, o = e
    }
    t._pt = r
  }, yn = function () {
    function t(t, e, n, r, i, o, s, a, c) {
      this.t = e, this.s = r, this.c = i, this.p = n, this.r = o || un, this.d = s || this, this.set = a || on, this.pr = c || 0, this._next = t, t && (t._prev = this)
    }

    return t.prototype.modifier = function (t, e, n) {
      this.mSet = this.mSet || this.set, this.set = vn, this.m = t, this.mt = n, this.tween = e
    }, t
  }();
  Et(xt + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function (t) {
    return pt[t] = 1
  })), at.TweenMax = at.TweenLite = rn, at.TimelineLite = at.TimelineMax = Ye, a = new Ye({
    sortChildren: !1,
    defaults: D,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
  }), k.stringFilter = Le;
  var _n = {
    registerPlugin: function () {
      for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
      e.forEach((function (t) {
        return Se(t)
      }))
    },
    timeline: function (t) {
      return new Ye(t)
    },
    getTweensOf: function (t, e) {
      return a.getTweensOf(t, e)
    },
    getProperty: function (t, e, n, r) {
      V(t) && (t = he(t)[0]);
      var i = St(t || {}).get, o = n ? Rt : Pt;
      return "native" === n && (n = ""), t ? e ? o((gt[e] && gt[e].get || i)(t, e, n, r)) : function (e, n, r) {
        return o((gt[e] && gt[e].get || i)(t, e, n, r))
      } : t
    },
    quickSetter: function (t, e, n) {
      if ((t = he(t)).length > 1) {
        var r = t.map((function (t) {
          return wn.quickSetter(t, e, n)
        })), i = r.length;
        return function (t) {
          for (var e = i; e--;) r[e](t)
        }
      }
      t = t[0] || {};
      var o = gt[e], s = St(t), a = s.harness && (s.harness.aliases || {})[e] || e, c = o ? function (e) {
        var r = new o;
        d._pt = 0, r.init(t, n ? e + n : e, d, 0, [t]), r.render(1, r), d._pt && dn(1, d)
      } : s.set(t, a);
      return o ? c : function (e) {
        return c(t, a, n ? e + n : e, s, 1)
      }
    },
    isTweening: function (t) {
      return a.getTweensOf(t, !0).length > 0
    },
    defaults: function (t) {
      return t && t.ease && (t.ease = Fe(t.ease, D.ease)), Dt(D, t || {})
    },
    config: function (t) {
      return Dt(k, t || {})
    },
    registerEffect: function (t) {
      var e = t.name, n = t.effect, r = t.plugins, i = t.defaults, o = t.extendTimeline;
      (r || "").split(",").forEach((function (t) {
        return t && !gt[t] && !at[t] && ht(e + " effect requires " + t + " plugin.")
      })), yt[e] = function (t, e, r) {
        return n(he(t), Lt(e || {}, i), r)
      }, o && (Ye.prototype[e] = function (t, n, r) {
        return this.add(yt[e](t, Y(n) ? n : (r = n) && {}, this), r)
      })
    },
    registerEase: function (t, e) {
      De[t] = Fe(e)
    },
    parseEase: function (t, e) {
      return arguments.length ? Fe(t, e) : De
    },
    getById: function (t) {
      return a.getById(t)
    },
    exportRoot: function (t, e) {
      void 0 === t && (t = {});
      var n, r, i = new Ye(t);
      for (i.smoothChildTiming = Z(t.smoothChildTiming), a.remove(i), i._dp = 0, i._time = i._tTime = a._time, n = a._first; n;) r = n._next, !e && !n._dur && n instanceof rn && n.vars.onComplete === n._targets[0] || Zt(i, n, n._start - n._delay), n = r;
      return Zt(a, i, 0), i
    },
    utils: {
      wrap: function t(e, n, r) {
        var i = n - e;
        return $(e) ? ge(e, t(0, e.length), n) : oe(r, (function (t) {
          return (i + (t - e) % i) % i + e
        }))
      }, wrapYoyo: function t(e, n, r) {
        var i = n - e, o = 2 * i;
        return $(e) ? ge(e, t(0, e.length - 1), n) : oe(r, (function (t) {
          return e + ((t = (o + (t - e) % o) % o || 0) > i ? o - t : t)
        }))
      }, distribute: de, random: ve, snap: me, normalize: function (t, e, n) {
        return _e(t, e, 0, 1, n)
      }, getUnit: ae, clamp: function (t, e, n) {
        return oe(n, (function (n) {
          return se(t, e, n)
        }))
      }, splitColor: Oe, toArray: he, selector: function (t) {
        return t = he(t)[0] || ht("Invalid scope") || {}, function (e) {
          var n = t.current || t.nativeElement || t;
          return he(e, n.querySelectorAll ? n : n === t ? ht("Invalid scope") || u.createElement("div") : t)
        }
      }, mapRange: _e, pipe: function () {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
        return function (t) {
          return e.reduce((function (t, e) {
            return e(t)
          }), t)
        }
      }, unitize: function (t, e) {
        return function (n) {
          return t(parseFloat(n)) + (e || ae(n))
        }
      }, interpolate: function t(e, n, r, i) {
        var o = isNaN(e + n) ? 0 : function (t) {
          return (1 - t) * e + t * n
        };
        if (!o) {
          var s, a, c, l, u, h = V(e), f = {};
          if (!0 === r && (i = 1) && (r = null), h) e = {p: e}, n = {p: n}; else if ($(e) && !$(n)) {
            for (c = [], l = e.length, u = l - 2, a = 1; a < l; a++) c.push(t(e[a - 1], e[a]));
            l--, o = function (t) {
              t *= l;
              var e = Math.min(u, ~~t);
              return c[e](t - e)
            }, r = n
          } else i || (e = kt($(e) ? [] : {}, e));
          if (!c) {
            for (s in n) Ke.call(f, e, s, "get", n[s]);
            o = function (t) {
              return dn(t, f) || (h ? e.p : e)
            }
          }
        }
        return oe(r, o)
      }, shuffle: fe
    },
    install: lt,
    effects: yt,
    ticker: Ce,
    updateRoot: Ye.updateRoot,
    plugins: gt,
    globalTimeline: a,
    core: {
      PropTween: yn,
      globals: ft,
      Tween: rn,
      Timeline: Ye,
      Animation: qe,
      getCache: St,
      _removeLinkedListItem: jt,
      suppressOverwrites: function (t) {
        return s = t
      }
    }
  };
  Et("to,from,fromTo,delayedCall,set,killTweensOf", (function (t) {
    return _n[t] = rn[t]
  })), Ce.add(Ye.updateRoot), d = _n.to({}, {duration: 0});
  var bn = function (t, e) {
    for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;) n = n._next;
    return n
  }, xn = function (t, e) {
    return {
      name: t, rawVars: 1, init: function (t, n, r) {
        r._onInit = function (t) {
          var r, i;
          if (V(n) && (r = {}, Et(n, (function (t) {
            return r[t] = 1
          })), n = r), e) {
            for (i in r = {}, n) r[i] = e(n[i]);
            n = r
          }
          !function (t, e) {
            var n, r, i, o = t._targets;
            for (n in e) for (r = o.length; r--;) (i = t._ptLookup[r][n]) && (i = i.d) && (i._pt && (i = bn(i, n)), i && i.modifier && i.modifier(e[n], t, o[r], n))
          }(t, n)
        }
      }
    }
  }, wn = _n.registerPlugin({
    name: "attr", init: function (t, e, n, r, i) {
      var o, s;
      for (o in e) (s = this.add(t, "setAttribute", (t.getAttribute(o) || 0) + "", e[o], r, i, 0, 0, o)) && (s.op = o), this._props.push(o)
    }
  }, {
    name: "endArray", init: function (t, e) {
      for (var n = e.length; n--;) this.add(t, n, t[n] || 0, e[n])
    }
  }, xn("roundProps", pe), xn("modifiers"), xn("snap", me)) || _n;
  rn.version = Ye.version = wn.version = "3.7.1", h = 1, J() && ke();
  De.Power0, De.Power1, De.Power2, De.Power3, De.Power4, De.Linear, De.Quad, De.Cubic, De.Quart, De.Quint, De.Strong, De.Elastic, De.Back, De.SteppedEase, De.Bounce, De.Sine, De.Expo, De.Circ;
  var Sn, Mn, En, Tn, On, Hn, An, Pn = {}, Rn = 180 / Math.PI, Ln = Math.PI / 180, Cn = Math.atan2, kn = /([A-Z])/g,
    Dn = /(?:left|right|width|margin|padding|x)/i, Nn = /[\s,\(]\S/,
    zn = {autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity"}, jn = function (t, e) {
      return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
    }, In = function (t, e) {
      return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
    }, Bn = function (t, e) {
      return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
    }, Fn = function (t, e) {
      var n = e.s + e.c * t;
      e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
    }, Un = function (t, e) {
      return e.set(e.t, e.p, t ? e.e : e.b, e)
    }, Gn = function (t, e) {
      return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
    }, Vn = function (t, e, n) {
      return t.style[e] = n
    }, Wn = function (t, e, n) {
      return t.style.setProperty(e, n)
    }, Xn = function (t, e, n) {
      return t._gsap[e] = n
    }, qn = function (t, e, n) {
      return t._gsap.scaleX = t._gsap.scaleY = n
    }, Yn = function (t, e, n, r, i) {
      var o = t._gsap;
      o.scaleX = o.scaleY = n, o.renderTransform(i, o)
    }, Zn = function (t, e, n, r, i) {
      var o = t._gsap;
      o[e] = n, o.renderTransform(i, o)
    }, Jn = "transform", Kn = Jn + "Origin", Qn = function (t, e) {
      var n = Mn.createElementNS ? Mn.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : Mn.createElement(t);
      return n.style ? n : Mn.createElement(t)
    }, $n = function t(e, n, r) {
      var i = getComputedStyle(e);
      return i[n] || i.getPropertyValue(n.replace(kn, "-$1").toLowerCase()) || i.getPropertyValue(n) || !r && t(e, er(n) || n, 1) || ""
    }, tr = "O,Moz,ms,Ms,Webkit".split(","), er = function (t, e, n) {
      var r = (e || On).style, i = 5;
      if (t in r && !n) return t;
      for (t = t.charAt(0).toUpperCase() + t.substr(1); i-- && !(tr[i] + t in r);) ;
      return i < 0 ? null : (3 === i ? "ms" : i >= 0 ? tr[i] : "") + t
    }, nr = function () {
      "undefined" != typeof window && window.document && (Sn = window, Mn = Sn.document, En = Mn.documentElement, On = Qn("div") || {style: {}}, Qn("div"), Jn = er(Jn), Kn = Jn + "Origin", On.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", An = !!er("perspective"), Tn = 1)
    }, rr = function t(e) {
      var n,
        r = Qn("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
        i = this.parentNode, o = this.nextSibling, s = this.style.cssText;
      if (En.appendChild(r), r.appendChild(this), this.style.display = "block", e) try {
        n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
      } catch (a) {
      } else this._gsapBBox && (n = this._gsapBBox());
      return i && (o ? i.insertBefore(this, o) : i.appendChild(this)), En.removeChild(r), this.style.cssText = s, n
    }, ir = function (t, e) {
      for (var n = e.length; n--;) if (t.hasAttribute(e[n])) return t.getAttribute(e[n])
    }, or = function (t) {
      var e;
      try {
        e = t.getBBox()
      } catch (n) {
        e = rr.call(t, !0)
      }
      return e && (e.width || e.height) || t.getBBox === rr || (e = rr.call(t, !0)), !e || e.width || e.x || e.y ? e : {
        x: +ir(t, ["x", "cx", "x1"]) || 0,
        y: +ir(t, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
      }
    }, sr = function (t) {
      return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !or(t))
    }, ar = function (t, e) {
      if (e) {
        var n = t.style;
        e in Pn && e !== Kn && (e = Jn), n.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), n.removeProperty(e.replace(kn, "-$1").toLowerCase())) : n.removeAttribute(e)
      }
    }, cr = function (t, e, n, r, i, o) {
      var s = new yn(t._pt, e, n, 0, 1, o ? Gn : Un);
      return t._pt = s, s.b = r, s.e = i, t._props.push(n), s
    }, lr = {deg: 1, rad: 1, turn: 1}, ur = function t(e, n, r, i) {
      var o, s, a, c, l = parseFloat(r) || 0, u = (r + "").trim().substr((l + "").length) || "px", h = On.style,
        f = Dn.test(n), d = "svg" === e.tagName.toLowerCase(), p = (d ? "client" : "offset") + (f ? "Width" : "Height"),
        m = 100, v = "px" === i, g = "%" === i;
      return i === u || !l || lr[i] || lr[u] ? l : ("px" !== u && !v && (l = t(e, n, r, "px")), c = e.getCTM && sr(e), !g && "%" !== u || !Pn[n] && !~n.indexOf("adius") ? (h[f ? "width" : "height"] = m + (v ? u : i), s = ~n.indexOf("adius") || "em" === i && e.appendChild && !d ? e : e.parentNode, c && (s = (e.ownerSVGElement || {}).parentNode), s && s !== Mn && s.appendChild || (s = Mn.body), (a = s._gsap) && g && a.width && f && a.time === Ce.time ? Tt(l / a.width * m) : ((g || "%" === u) && (h.position = $n(e, "position")), s === e && (h.position = "static"), s.appendChild(On), o = On[p], s.removeChild(On), h.position = "absolute", f && g && ((a = St(s)).time = Ce.time, a.width = s[p]), Tt(v ? o * l / m : o && l ? m / o * l : 0))) : (o = c ? e.getBBox()[f ? "width" : "height"] : e[p], Tt(g ? l / o * m : l / 100 * o)))
    }, hr = function (t, e, n, r) {
      var i;
      return Tn || nr(), e in zn && "transform" !== e && ~(e = zn[e]).indexOf(",") && (e = e.split(",")[0]), Pn[e] && "transform" !== e ? (i = wr(t, r), i = "transformOrigin" !== e ? i[e] : i.svg ? i.origin : Sr($n(t, Kn)) + " " + i.zOrigin + "px") : (!(i = t.style[e]) || "auto" === i || r || ~(i + "").indexOf("calc(")) && (i = mr[e] && mr[e](t, e, n) || $n(t, e) || Mt(t, e) || ("opacity" === e ? 1 : 0)), n && !~(i + "").trim().indexOf(" ") ? ur(t, e, i, n) + n : i
    }, fr = function (t, e, n, r) {
      if (!n || "none" === n) {
        var i = er(e, t, 1), o = i && $n(t, i, 1);
        o && o !== n ? (e = i, n = o) : "borderColor" === e && (n = $n(t, "borderTopColor"))
      }
      var s, a, c, l, u, h, f, d, p, m, v, g, y = new yn(this._pt, t.style, e, 0, 1, fn), _ = 0, b = 0;
      if (y.b = n, y.e = r, n += "", "auto" === (r += "") && (t.style[e] = r, r = $n(t, e) || r, t.style[e] = n), Le(s = [n, r]), r = s[1], c = (n = s[0]).match(nt) || [], (r.match(nt) || []).length) {
        for (; a = nt.exec(r);) f = a[0], p = r.substring(_, a.index), u ? u = (u + 1) % 5 : "rgba(" !== p.substr(-5) && "hsla(" !== p.substr(-5) || (u = 1), f !== (h = c[b++] || "") && (l = parseFloat(h) || 0, v = h.substr((l + "").length), (g = "=" === f.charAt(1) ? +(f.charAt(0) + "1") : 0) && (f = f.substr(2)), d = parseFloat(f), m = f.substr((d + "").length), _ = nt.lastIndex - m.length, m || (m = m || k.units[e] || v, _ === r.length && (r += m, y.e += m)), v !== m && (l = ur(t, e, h, m) || 0), y._pt = {
          _next: y._pt,
          p: p || 1 === b ? p : ",",
          s: l,
          c: g ? g * d : d - l,
          m: u && u < 4 || "zIndex" === e ? Math.round : 0
        });
        y.c = _ < r.length ? r.substring(_, r.length) : ""
      } else y.r = "display" === e && "none" === r ? Gn : Un;
      return it.test(r) && (y.e = 0), this._pt = y, y
    }, dr = {top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%"}, pr = function (t, e) {
      if (e.tween && e.tween._time === e.tween._dur) {
        var n, r, i, o = e.t, s = o.style, a = e.u, c = o._gsap;
        if ("all" === a || !0 === a) s.cssText = "", r = 1; else for (i = (a = a.split(",")).length; --i > -1;) n = a[i], Pn[n] && (r = 1, n = "transformOrigin" === n ? Kn : Jn), ar(o, n);
        r && (ar(o, Jn), c && (c.svg && o.removeAttribute("transform"), wr(o, 1), c.uncache = 1))
      }
    }, mr = {
      clearProps: function (t, e, n, r, i) {
        if ("isFromStart" !== i.data) {
          var o = t._pt = new yn(t._pt, e, n, 0, 0, pr);
          return o.u = r, o.pr = -10, o.tween = i, t._props.push(n), 1
        }
      }
    }, vr = [1, 0, 0, 1, 0, 0], gr = {}, yr = function (t) {
      return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
    }, _r = function (t) {
      var e = $n(t, Jn);
      return yr(e) ? vr : e.substr(7).match(et).map(Tt)
    }, br = function (t, e) {
      var n, r, i, o, s = t._gsap || St(t), a = t.style, c = _r(t);
      return s.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (c = [(i = t.transform.baseVal.consolidate().matrix).a, i.b, i.c, i.d, i.e, i.f]).join(",") ? vr : c : (c !== vr || t.offsetParent || t === En || s.svg || (i = a.display, a.display = "block", (n = t.parentNode) && t.offsetParent || (o = 1, r = t.nextSibling, En.appendChild(t)), c = _r(t), i ? a.display = i : ar(t, "display"), o && (r ? n.insertBefore(t, r) : n ? n.appendChild(t) : En.removeChild(t))), e && c.length > 6 ? [c[0], c[1], c[4], c[5], c[12], c[13]] : c)
    }, xr = function (t, e, n, r, i, o) {
      var s, a, c, l = t._gsap, u = i || br(t, !0), h = l.xOrigin || 0, f = l.yOrigin || 0, d = l.xOffset || 0,
        p = l.yOffset || 0, m = u[0], v = u[1], g = u[2], y = u[3], _ = u[4], b = u[5], x = e.split(" "),
        w = parseFloat(x[0]) || 0, S = parseFloat(x[1]) || 0;
      n ? u !== vr && (a = m * y - v * g) && (c = w * (-v / a) + S * (m / a) - (m * b - v * _) / a, w = w * (y / a) + S * (-g / a) + (g * b - y * _) / a, S = c) : (w = (s = or(t)).x + (~x[0].indexOf("%") ? w / 100 * s.width : w), S = s.y + (~(x[1] || x[0]).indexOf("%") ? S / 100 * s.height : S)), r || !1 !== r && l.smooth ? (_ = w - h, b = S - f, l.xOffset = d + (_ * m + b * g) - _, l.yOffset = p + (_ * v + b * y) - b) : l.xOffset = l.yOffset = 0, l.xOrigin = w, l.yOrigin = S, l.smooth = !!r, l.origin = e, l.originIsAbsolute = !!n, t.style[Kn] = "0px 0px", o && (cr(o, l, "xOrigin", h, w), cr(o, l, "yOrigin", f, S), cr(o, l, "xOffset", d, l.xOffset), cr(o, l, "yOffset", p, l.yOffset)), t.setAttribute("data-svg-origin", w + " " + S)
    }, wr = function (t, e) {
      var n = t._gsap || new Xe(t);
      if ("x" in n && !e && !n.uncache) return n;
      var r, i, o, s, a, c, l, u, h, f, d, p, m, v, g, y, _, b, x, w, S, M, E, T, O, H, A, P, R, L, C, D, N = t.style,
        z = n.scaleX < 0, j = "px", I = "deg", B = $n(t, Kn) || "0";
      return r = i = o = c = l = u = h = f = d = 0, s = a = 1, n.svg = !(!t.getCTM || !sr(t)), v = br(t, n.svg), n.svg && (T = (!n.uncache || "0px 0px" === B) && !e && t.getAttribute("data-svg-origin"), xr(t, T || B, !!T || n.originIsAbsolute, !1 !== n.smooth, v)), p = n.xOrigin || 0, m = n.yOrigin || 0, v !== vr && (b = v[0], x = v[1], w = v[2], S = v[3], r = M = v[4], i = E = v[5], 6 === v.length ? (s = Math.sqrt(b * b + x * x), a = Math.sqrt(S * S + w * w), c = b || x ? Cn(x, b) * Rn : 0, (h = w || S ? Cn(w, S) * Rn + c : 0) && (a *= Math.abs(Math.cos(h * Ln))), n.svg && (r -= p - (p * b + m * w), i -= m - (p * x + m * S))) : (D = v[6], L = v[7], A = v[8], P = v[9], R = v[10], C = v[11], r = v[12], i = v[13], o = v[14], l = (g = Cn(D, R)) * Rn, g && (T = M * (y = Math.cos(-g)) + A * (_ = Math.sin(-g)), O = E * y + P * _, H = D * y + R * _, A = M * -_ + A * y, P = E * -_ + P * y, R = D * -_ + R * y, C = L * -_ + C * y, M = T, E = O, D = H), u = (g = Cn(-w, R)) * Rn, g && (y = Math.cos(-g), C = S * (_ = Math.sin(-g)) + C * y, b = T = b * y - A * _, x = O = x * y - P * _, w = H = w * y - R * _), c = (g = Cn(x, b)) * Rn, g && (T = b * (y = Math.cos(g)) + x * (_ = Math.sin(g)), O = M * y + E * _, x = x * y - b * _, E = E * y - M * _, b = T, M = O), l && Math.abs(l) + Math.abs(c) > 359.9 && (l = c = 0, u = 180 - u), s = Tt(Math.sqrt(b * b + x * x + w * w)), a = Tt(Math.sqrt(E * E + D * D)), g = Cn(M, E), h = Math.abs(g) > 2e-4 ? g * Rn : 0, d = C ? 1 / (C < 0 ? -C : C) : 0), n.svg && (T = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !yr($n(t, Jn)), T && t.setAttribute("transform", T))), Math.abs(h) > 90 && Math.abs(h) < 270 && (z ? (s *= -1, h += c <= 0 ? 180 : -180, c += c <= 0 ? 180 : -180) : (a *= -1, h += h <= 0 ? 180 : -180)), n.x = r - ((n.xPercent = r && (n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetWidth * n.xPercent / 100 : 0) + j, n.y = i - ((n.yPercent = i && (n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-i) ? -50 : 0))) ? t.offsetHeight * n.yPercent / 100 : 0) + j, n.z = o + j, n.scaleX = Tt(s), n.scaleY = Tt(a), n.rotation = Tt(c) + I, n.rotationX = Tt(l) + I, n.rotationY = Tt(u) + I, n.skewX = h + I, n.skewY = f + I, n.transformPerspective = d + j, (n.zOrigin = parseFloat(B.split(" ")[2]) || 0) && (N[Kn] = Sr(B)), n.xOffset = n.yOffset = 0, n.force3D = k.force3D, n.renderTransform = n.svg ? Pr : An ? Ar : Er, n.uncache = 0, n
    }, Sr = function (t) {
      return (t = t.split(" "))[0] + " " + t[1]
    }, Mr = function (t, e, n) {
      var r = ae(e);
      return Tt(parseFloat(e) + parseFloat(ur(t, "x", n + "px", r))) + r
    }, Er = function (t, e) {
      e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, Ar(t, e)
    }, Tr = "0deg", Or = "0px", Hr = ") ", Ar = function (t, e) {
      var n = e || this, r = n.xPercent, i = n.yPercent, o = n.x, s = n.y, a = n.z, c = n.rotation, l = n.rotationY,
        u = n.rotationX, h = n.skewX, f = n.skewY, d = n.scaleX, p = n.scaleY, m = n.transformPerspective, v = n.force3D,
        g = n.target, y = n.zOrigin, _ = "", b = "auto" === v && t && 1 !== t || !0 === v;
      if (y && (u !== Tr || l !== Tr)) {
        var x, w = parseFloat(l) * Ln, S = Math.sin(w), M = Math.cos(w);
        w = parseFloat(u) * Ln, x = Math.cos(w), o = Mr(g, o, S * x * -y), s = Mr(g, s, -Math.sin(w) * -y), a = Mr(g, a, M * x * -y + y)
      }
      m !== Or && (_ += "perspective(" + m + Hr), (r || i) && (_ += "translate(" + r + "%, " + i + "%) "), (b || o !== Or || s !== Or || a !== Or) && (_ += a !== Or || b ? "translate3d(" + o + ", " + s + ", " + a + ") " : "translate(" + o + ", " + s + Hr), c !== Tr && (_ += "rotate(" + c + Hr), l !== Tr && (_ += "rotateY(" + l + Hr), u !== Tr && (_ += "rotateX(" + u + Hr), h === Tr && f === Tr || (_ += "skew(" + h + ", " + f + Hr), 1 === d && 1 === p || (_ += "scale(" + d + ", " + p + Hr), g.style[Jn] = _ || "translate(0, 0)"
    }, Pr = function (t, e) {
      var n, r, i, o, s, a = e || this, c = a.xPercent, l = a.yPercent, u = a.x, h = a.y, f = a.rotation, d = a.skewX,
        p = a.skewY, m = a.scaleX, v = a.scaleY, g = a.target, y = a.xOrigin, _ = a.yOrigin, b = a.xOffset, x = a.yOffset,
        w = a.forceCSS, S = parseFloat(u), M = parseFloat(h);
      f = parseFloat(f), d = parseFloat(d), (p = parseFloat(p)) && (d += p = parseFloat(p), f += p), f || d ? (f *= Ln, d *= Ln, n = Math.cos(f) * m, r = Math.sin(f) * m, i = Math.sin(f - d) * -v, o = Math.cos(f - d) * v, d && (p *= Ln, s = Math.tan(d - p), i *= s = Math.sqrt(1 + s * s), o *= s, p && (s = Math.tan(p), n *= s = Math.sqrt(1 + s * s), r *= s)), n = Tt(n), r = Tt(r), i = Tt(i), o = Tt(o)) : (n = m, o = v, r = i = 0), (S && !~(u + "").indexOf("px") || M && !~(h + "").indexOf("px")) && (S = ur(g, "x", u, "px"), M = ur(g, "y", h, "px")), (y || _ || b || x) && (S = Tt(S + y - (y * n + _ * i) + b), M = Tt(M + _ - (y * r + _ * o) + x)), (c || l) && (s = g.getBBox(), S = Tt(S + c / 100 * s.width), M = Tt(M + l / 100 * s.height)), s = "matrix(" + n + "," + r + "," + i + "," + o + "," + S + "," + M + ")", g.setAttribute("transform", s), w && (g.style[Jn] = s)
    }, Rr = function (t, e, n, r, i, o) {
      var s, a, c = 360, l = V(i), u = parseFloat(i) * (l && ~i.indexOf("rad") ? Rn : 1), h = o ? u * o : u - r,
        f = r + h + "deg";
      return l && ("short" === (s = i.split("_")[1]) && (h %= c) !== h % 180 && (h += h < 0 ? c : -360), "cw" === s && h < 0 ? h = (h + 36e9) % c - ~~(h / c) * c : "ccw" === s && h > 0 && (h = (h - 36e9) % c - ~~(h / c) * c)), t._pt = a = new yn(t._pt, e, n, r, h, In), a.e = f, a.u = "deg", t._props.push(n), a
    }, Lr = function (t, e) {
      for (var n in e) t[n] = e[n];
      return t
    }, Cr = function (t, e, n) {
      var r, i, o, s, a, c, l, u = Lr({}, n._gsap), h = n.style;
      for (i in u.svg ? (o = n.getAttribute("transform"), n.setAttribute("transform", ""), h[Jn] = e, r = wr(n, 1), ar(n, Jn), n.setAttribute("transform", o)) : (o = getComputedStyle(n)[Jn], h[Jn] = e, r = wr(n, 1), h[Jn] = o), Pn) (o = u[i]) !== (s = r[i]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(i) < 0 && (a = ae(o) !== (l = ae(s)) ? ur(n, i, o, l) : parseFloat(o), c = parseFloat(s), t._pt = new yn(t._pt, r, i, a, c - a, jn), t._pt.u = l || 0, t._props.push(i));
      Lr(r, u)
    };
  Et("padding,margin,Width,Radius", (function (t, e) {
    var n = "Top", r = "Right", i = "Bottom", o = "Left",
      s = (e < 3 ? [n, r, i, o] : [n + o, n + r, i + r, i + o]).map((function (n) {
        return e < 2 ? t + n : "border" + n + t
      }));
    mr[e > 1 ? "border" + t : t] = function (t, e, n, r, i) {
      var o, a;
      if (arguments.length < 4) return o = s.map((function (e) {
        return hr(t, e, n)
      })), 5 === (a = o.join(" ")).split(o[0]).length ? o[0] : a;
      o = (r + "").split(" "), a = {}, s.forEach((function (t, e) {
        return a[t] = o[e] = o[e] || o[(e - 1) / 2 | 0]
      })), t.init(e, a, i)
    }
  }));
  var kr, Dr, Nr, zr = {
    name: "css", register: nr, targetTest: function (t) {
      return t.style && t.nodeType
    }, init: function (t, e, n, r, i) {
      var o, s, a, c, l, u, h, f, d, p, m, v, g, y, _, b, x, w, S, M = this._props, E = t.style, T = n.vars.startAt;
      for (h in Tn || nr(), e) if ("autoRound" !== h && (s = e[h], !gt[h] || !Qe(h, e, n, r, t, i))) if (l = typeof s, u = mr[h], "function" === l && (l = typeof(s = s.call(n, r, t, i))), "string" === l && ~s.indexOf("random(") && (s = ye(s)), u) u(this, t, h, s, n) && (_ = 1); else if ("--" === h.substr(0, 2)) o = (getComputedStyle(t).getPropertyValue(h) + "").trim(), s += "", Pe.lastIndex = 0, Pe.test(o) || (f = ae(o), d = ae(s)), d ? f !== d && (o = ur(t, h, o, d) + d) : f && (s += f), this.add(E, "setProperty", o, s, r, i, 0, 0, h), M.push(h); else if ("undefined" !== l) {
        if (T && h in T ? (o = "function" == typeof T[h] ? T[h].call(n, r, t, i) : T[h], h in k.units && !ae(o) && (o += k.units[h]), "=" === (o + "").charAt(1) && (o = hr(t, h))) : o = hr(t, h), c = parseFloat(o), (p = "string" === l && "=" === s.charAt(1) ? +(s.charAt(0) + "1") : 0) && (s = s.substr(2)), a = parseFloat(s), h in zn && ("autoAlpha" === h && (1 === c && "hidden" === hr(t, "visibility") && a && (c = 0), cr(this, E, "visibility", c ? "inherit" : "hidden", a ? "inherit" : "hidden", !a)), "scale" !== h && "transform" !== h && ~(h = zn[h]).indexOf(",") && (h = h.split(",")[0])), m = h in Pn) if (v || ((g = t._gsap).renderTransform && !e.parseTransform || wr(t, e.parseTransform), y = !1 !== e.smoothOrigin && g.smooth, (v = this._pt = new yn(this._pt, E, Jn, 0, 1, g.renderTransform, g, 0, -1)).dep = 1), "scale" === h) this._pt = new yn(this._pt, g, "scaleY", g.scaleY, (p ? p * a : a - g.scaleY) || 0), M.push("scaleY", h), h += "X"; else {
          if ("transformOrigin" === h) {
            x = void 0, w = void 0, S = void 0, x = (b = s).split(" "), w = x[0], S = x[1] || "50%", "top" !== w && "bottom" !== w && "left" !== S && "right" !== S || (b = w, w = S, S = b), x[0] = dr[w] || w, x[1] = dr[S] || S, s = x.join(" "), g.svg ? xr(t, s, 0, y, 0, this) : ((d = parseFloat(s.split(" ")[2]) || 0) !== g.zOrigin && cr(this, g, "zOrigin", g.zOrigin, d), cr(this, E, h, Sr(o), Sr(s)));
            continue
          }
          if ("svgOrigin" === h) {
            xr(t, s, 1, y, 0, this);
            continue
          }
          if (h in gr) {
            Rr(this, g, h, c, s, p);
            continue
          }
          if ("smoothOrigin" === h) {
            cr(this, g, "smooth", g.smooth, s);
            continue
          }
          if ("force3D" === h) {
            g[h] = s;
            continue
          }
          if ("transform" === h) {
            Cr(this, s, t);
            continue
          }
        } else h in E || (h = er(h) || h);
        if (m || (a || 0 === a) && (c || 0 === c) && !Nn.test(s) && h in E) a || (a = 0), (f = (o + "").substr((c + "").length)) !== (d = ae(s) || (h in k.units ? k.units[h] : f)) && (c = ur(t, h, o, d)), this._pt = new yn(this._pt, m ? g : E, h, c, p ? p * a : a - c, m || "px" !== d && "zIndex" !== h || !1 === e.autoRound ? jn : Fn), this._pt.u = d || 0, f !== d && (this._pt.b = o, this._pt.r = Bn); else if (h in E) fr.call(this, t, h, o, s); else {
          if (!(h in t)) {
            ut(h, s);
            continue
          }
          this.add(t, h, o || t[h], s, r, i)
        }
        M.push(h)
      }
      _ && gn(this)
    }, get: hr, aliases: zn, getSetter: function (t, e, n) {
      var r = zn[e];
      return r && r.indexOf(",") < 0 && (e = r), e in Pn && e !== Kn && (t._gsap.x || hr(t, "x")) ? n && Hn === n ? "scale" === e ? qn : Xn : (Hn = n || {}) && ("scale" === e ? Yn : Zn) : t.style && !q(t.style[e]) ? Vn : ~e.indexOf("-") ? Wn : ln(t, e)
    }, core: {_removeProperty: ar, _getMatrix: br}
  };
  wn.utils.checkPrefix = er, Nr = Et((kr = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (Dr = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (t) {
    Pn[t] = 1
  })), Et(Dr, (function (t) {
    k.units[t] = "deg", gr[t] = 1
  })), zn[Nr[13]] = kr + "," + Dr, Et("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (t) {
    var e = t.split(":");
    zn[e[1]] = Nr[e[0]]
  })), Et("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (t) {
    k.units[t] = "px"
  })), wn.registerPlugin(zr);
  var jr = wn.registerPlugin(zr) || wn, Ir = (jr.core.Tween, n(2)), Br = n(8), Fr = n.n(Br), Ur = n(1), Gr = n(0),
    Vr = n(19);

  function Wr(t) {
    return Wr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Wr(t)
  }

  function Xr(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function qr(t, e, n) {
    return qr = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Kr(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, qr(t, e, n || t)
  }

  function Yr(t, e) {
    return Yr = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, Yr(t, e)
  }

  function Zr(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = Kr(t);
      if (e) {
        var i = Kr(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return Jr(this, n)
    }
  }

  function Jr(t, e) {
    if (e && ("object" === Wr(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function Kr(t) {
    return Kr = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, Kr(t)
  }

  var Qr = function (t) {
      !function (t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
        t.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: t,
            writable: !0,
            configurable: !0
          }
        }), e && Yr(t, e)
      }(s, t);
      var e, n, i, o = Zr(s);

      function s(t, e) {
        var n;
        return function (t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }(this, s), (n = o.call(this, e)).source = t, n.updateSize(), n
      }

      return e = s, (n = [{
        key: "updateSize", value: function (t, e) {
          qr(Kr(s.prototype), "updateSize", this).call(this, t, e);
          var n = Object(r.a)({source: this.source, rule: "cover", scale: 1, width: this.width, height: this.height});
          this._ctx.clearRect(0, 0, this.width, this.height), this._ctx.drawImage(this.source, 0, 0, n.sourceWidth, n.sourceHeight, n.x, n.y, n.width, n.height)
        }
      }]) && Xr(e.prototype, n), i && Xr(e, i), s
    }(Vr.a), $r = n(31), ti = n(5), ei = n(49), ni = n(26), ri = n(29), ii = Gr.a.viewport, oi = ri.b.tagName,
    si = ri.b.quantityMultiplier;

  function ai(t) {
    var e = t.parent, n = t.intersectionEl, i = t.data, o = t.settings, s = void 0 === o ? ri.a : o,
      a = t.renderPosition, c = void 0 === a || a, l = t.scene, u = void 0 === l ? ti.a.scene3d : l, h = t.heightRatio,
      f = void 0 === h ? .5625 : h, d = t.handleLoaded, p = void 0 === d ? function () {
      } : d, m = !1, v = 0, g = !1, y = 0, _ = i.length * si, b = new Array(_), x = [], w = !1, S = [], M = [], E = !1;

    function T() {
      b.forEach((function (t) {
        var n = Object(Ur.b)("div", {parent: e}), r = new Vr.a(!1), i = new Qr(t, !1), o = new Ir.hb(r.canvas);
        o.magFilter = Ir.z, o.minFilter = Ir.z;
        var s = {
          image: t,
          refEl: n,
          plane: new $r.a({el: n, texture: o, renderPosition: !1, materialProp: {transparent: !0}, scene: w}),
          texturePrerender: r,
          imagePrerender: i,
          texture: o,
          width: 0,
          height: 0,
          x: 0,
          y: 0
        };
        x.push(s)
      }))
    }

    function O() {
      x.forEach((function (t, n) {
        !function (t) {
          var n = x[t];
          if (void 0 === n) return;
          var i = n.refEl, o = n.imagePrerender, a = n.texturePrerender, c = n.texture, l = n.plane, u = 2,
            h = e.clientHeight, d = function (t) {
              var e = s.paddingXRatio;
              return t * e
            }(h), p = h / f + d;
          i.style.width = "".concat(p, "px"), i.style.height = "".concat(h, "px"), n.width = p, n.height = h;
          var m = p * u, v = m + d * u, g = h * u;
          a.updateSize(v, g);
          var y = 2;
          o.updateSize(m * y, g * y);
          var _ = a.ctx, b = a.width, w = a.height;
          _.save(), _.clearRect(0, 0, b, w);
          var S = Object(r.a)({source: o.canvas, rule: "contain", scale: 1, width: b, height: w});
          _.drawImage(o.canvas, 0, 0, S.sourceWidth, S.sourceHeight, S.x, S.y, S.width, S.height), _.restore(), c.needsUpdate = !0, l.resize()
        }(n)
      })), H()
    }

    function H() {
      var t = s.speed;
      y += t, c && function () {
        if (!w) return;
        var t = s.rotationY, e = s.parallaxFriction, r = ti.a.width, i = ti.a.height, o = n.getBoundingClientRect(),
          a = o.top + o.height / 2, c = Fr()(a, [ti.a.height, 0]), l = 0;
        l = c <= .5 ? 1 - Fr()(c, [0, .5]) : -Fr()(c, [.5, 1]);
        var u = a - l * (r > i ? e : e / 2) * i;
        w.position.y = i / 2 - u, w.rotation.y = t
      }(), function () {
        for (var t = s.alpha, e = function () {
          for (var t = 0, e = 0; e < _; e++) {
            t += x[e].width
          }
          return t
        }(), n = function () {
          if (x.length > 0) return x[0].width;
          return 0
        }(), r = 0; r < _; r++) {
          var i = x[r], o = i.plane, a = o.mesh, c = o.material;
          i.x = jr.utils.wrap(2 * -n, e - 2 * n, y + n * r), a.position.x = -ti.a.width / 2 + i.x + n / 2, c.opacity = t
        }
      }()
    }

    return i.forEach((function (t, e) {
      Object(ni.a)(t, (function (t) {
        m || (v++, b[e] = t, v === i.length && (g = !0, function () {
          if (g && !m) {
            var t = ri.b.alwaysRender;
            w = new Ir.s, u.add(w);
            for (var e = 0; e < si; e++) T();
            O();
            var r = Gr.a.vevetPage;
            r && r.onPageShown((function () {
              m || O()
            })), S.push(ii.on("", (function () {
              O()
            }), {name: oi, timeout: 50})), t ? M.push(ti.a.on("prerender", (function () {
              H()
            }))) : E = Object(ei.a)(n, (function () {
              m || M.push(ti.a.on("prerender", (function () {
                H()
              })))
            }), (function () {
              m || (M.forEach((function (t) {
                ti.a.remove(t)
              })), M = [])
            })), p()
          }
        }()))
      }))
    })), {
      destroy: function () {
        m = !0, S.forEach((function (t) {
          ii.remove(t)
        })), M.forEach((function (t) {
          ti.a.remove(t)
        })), x.forEach((function (t) {
          t.plane.destroy(), t.refEl.remove()
        })), w && u.remove(w), E && E.destroy()
      }.bind(this), getGroup: function () {
        return w
      }, getElements: function () {
        return x
      }
    }
  }
}, function (t, e, n) {
  "use strict";
  n.d(e, "a", (function () {
    return l
  }));
  var r = n(2), i = n(60), o = n(43), s = n(21);

  class a extends s.b {
    constructor(t, e) {
      super(), this.scene = t, this.camera = e, this.clear = !0, this.needsSwap = !1, this.inverse = !1
    }

    render(t, e, n) {
      const r = t.getContext(), i = t.state;
      let o, s;
      i.buffers.color.setMask(!1), i.buffers.depth.setMask(!1), i.buffers.color.setLocked(!0), i.buffers.depth.setLocked(!0), this.inverse ? (o = 0, s = 1) : (o = 1, s = 0), i.buffers.stencil.setTest(!0), i.buffers.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE), i.buffers.stencil.setFunc(r.ALWAYS, o, 4294967295), i.buffers.stencil.setClear(s), i.buffers.stencil.setLocked(!0), t.setRenderTarget(n), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), i.buffers.color.setLocked(!1), i.buffers.depth.setLocked(!1), i.buffers.stencil.setLocked(!1), i.buffers.stencil.setFunc(r.EQUAL, 1, 4294967295), i.buffers.stencil.setOp(r.KEEP, r.KEEP, r.KEEP), i.buffers.stencil.setLocked(!0)
    }
  }

  class c extends s.b {
    constructor() {
      super(), this.needsSwap = !1
    }

    render(t) {
      t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1)
    }
  }

  class l {
    constructor(t, e) {
      if (this.renderer = t, void 0 === e) {
        const n = {minFilter: r.z, magFilter: r.z, format: r.U}, i = t.getSize(new r.mb);
        this._pixelRatio = t.getPixelRatio(), this._width = i.width, this._height = i.height, (e = new r.qb(this._width * this._pixelRatio, this._height * this._pixelRatio, n)).texture.name = "EffectComposer.rt1"
      } else this._pixelRatio = 1, this._width = e.width, this._height = e.height;
      this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], void 0 === i.a && console.error("THREE.EffectComposer relies on CopyShader"), void 0 === o.a && console.error("THREE.EffectComposer relies on ShaderPass"), this.copyPass = new o.a(i.a), this.clock = new r.h
    }

    swapBuffers() {
      const t = this.readBuffer;
      this.readBuffer = this.writeBuffer, this.writeBuffer = t
    }

    addPass(t) {
      this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
    }

    insertPass(t, e) {
      this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
    }

    removePass(t) {
      const e = this.passes.indexOf(t);
      -1 !== e && this.passes.splice(e, 1)
    }

    isLastEnabledPass(t) {
      for (let e = t + 1; e < this.passes.length; e++) if (this.passes[e].enabled) return !1;
      return !0
    }

    render(t) {
      void 0 === t && (t = this.clock.getDelta());
      const e = this.renderer.getRenderTarget();
      let n = !1;
      for (let r = 0, i = this.passes.length; r < i; r++) {
        const e = this.passes[r];
        if (!1 !== e.enabled) {
          if (e.renderToScreen = this.renderToScreen && this.isLastEnabledPass(r), e.render(this.renderer, this.writeBuffer, this.readBuffer, t, n), e.needsSwap) {
            if (n) {
              const e = this.renderer.getContext(), n = this.renderer.state.buffers.stencil;
              n.setFunc(e.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), n.setFunc(e.EQUAL, 1, 4294967295)
            }
            this.swapBuffers()
          }
          void 0 !== a && (e instanceof a ? n = !0 : e instanceof c && (n = !1))
        }
      }
      this.renderer.setRenderTarget(e)
    }

    reset(t) {
      if (void 0 === t) {
        const e = this.renderer.getSize(new r.mb);
        this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, (t = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
      }
      this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
    }

    setSize(t, e) {
      this._width = t, this._height = e;
      const n = this._width * this._pixelRatio, r = this._height * this._pixelRatio;
      this.renderTarget1.setSize(n, r), this.renderTarget2.setSize(n, r);
      for (let i = 0; i < this.passes.length; i++) this.passes[i].setSize(n, r)
    }

    setPixelRatio(t) {
      this._pixelRatio = t, this.setSize(this._width, this._height)
    }
  }

  new r.M(-1, 1, 1, -1, 0, 1);
  const u = new r.e;
  u.setAttribute("position", new r.q([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), u.setAttribute("uv", new r.q([0, 2, 0, 0, 2, 0], 2))
}, function (t, e, n) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var r = l(n(104)), i = l(n(106)), o = l(n(107)), s = l(n(108)), a = l(n(109)), c = l(n(110));

  function l(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function u(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function h(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  var f = function () {
    function t() {
      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      u(this, t), this.prop = Object.assign(this.defaultProp, e), this._prefix = this.prop.prefix, this._init()
    }

    var e, n, l;
    return e = t, n = [{
      key: "defaultProp", get: function () {
        return {
          page: ["home"],
          tablet: 1199,
          mobile: 899,
          prefix: "vevet-",
          prefixData: "data-vevet-",
          prefixProp: "vevet-",
          ajaxTimeMax: 5e3,
          easing: [.25, .1, .25, 1]
        }
      }
    }, {
      key: "doc", get: function () {
        return this._doc
      }
    }, {
      key: "html", get: function () {
        return this._html
      }
    }, {
      key: "body", get: function () {
        return this._body
      }
    }, {
      key: "prefix", get: function () {
        return this._prefix
      }
    }, {
      key: "easing", get: function () {
        return this.prop.easing
      }
    }, {
      key: "_init", value: function () {
        this._hi(), this._doc = document, this._html = document.documentElement, this._body = document.body, this._page = [], this.page = this.prop.page, this._browser = (0, a.default)(), this._os = (0, c.default)(), this.load = new r.default({v: this}), this.viewport = new i.default({v: this}), this.url = new o.default({v: this}), this.ajax = new s.default({v: this}), this.vevetPages = [], this.vevetPage = !1, window.vevetApplication = this
      }
    }, {
      key: "_hi", value: function () {
        var t = ["padding: 1rem 1.5rem;", "background: #5F2580;", "font: 1rem/1 Arial;", "color: #ffffff;"].join("");
        console.log("%c%s", t, "Vevet")
      }
    }, {
      key: "page", get: function () {
        return this._page
      }, set: function (t) {
        void 0 === t && (t = ["home"]);
        for (var e = 0; e < this._page.length; e++) this._html.classList.remove("".concat(this._prefix, "page_").concat(this._page[e]));
        for (var n = 0; n < t.length; n++) this._html.classList.add("".concat(this._prefix, "page_").concat(t[n]));
        this._page = t
      }
    }, {
      key: "pageCheck", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
        return this._page.includes(t)
      }
    }, {
      key: "browser", get: function () {
        return this._html.classList.remove("".concat(this._prefix, "browser_").concat(this._browser)), this._browser = (0, a.default)(), this._html.classList.add("".concat(this._prefix, "browser_").concat(this._browser)), this._browser
      }
    }, {
      key: "os", get: function () {
        return this._html.classList.remove("".concat(this._prefix, "os_").concat(this._os)), this._os = (0, c.default)(), this._html.classList.add("".concat(this._prefix, "os_").concat(this._os)), this._os
      }
    }], n && h(e.prototype, n), l && h(e, l), t
  }();
  e.default = f
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = a(n(15)), o = a(n(6)), s = a(n(17));

  function a(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function c(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function l(t, e, n) {
    return l = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = d(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, l(t, e, n || t)
  }

  function u(t, e) {
    return u = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, u(t, e)
  }

  function h(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = d(t);
      if (e) {
        var i = d(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return f(this, n)
    }
  }

  function f(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function d(t) {
    return d = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, d(t)
  }

  var p = n(25), m = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && u(t, e)
    }(a, t);
    var e, n, r, i = h(a);

    function a(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, a), i.call(this, t)
    }

    return e = a, n = [{
      key: "prefix", get: function () {
        return "".concat(this._v.prefix, "pageAjax")
      }
    }, {
      key: "defaultProp", get: function () {
        return (0, o.default)(l(d(a.prototype), "defaultProp", this), {
          selectors: {
            outer: ".".concat(this._prefix),
            links: ".".concat(this._prefix, "__link")
          },
          popstate: {event: !0, reload: !0, timeout: 300},
          on: !0,
          disabled: !1,
          update: {url: !0, title: !0, content: !0},
          menuLinks: {update: !0, class: "active", compare: "href", selectorNew: ".menu a", selectorOld: ".menu a"},
          timeouts: {load: 100, update: 100, done: 100},
          pageChange: {on: !0, default: "default", hide: "prepare", destroy: "loaded", create: "updated", show: "done"},
          changeSame: !0,
          cache: !1,
          ajax: {method: "post", successCodes: [404]}
        })
      }
    }, {
      key: "links", get: function () {
        return this._links
      }
    }, {
      key: "outer", get: function () {
        return this._outer
      }
    }, {
      key: "loading", get: function () {
        return this._loading
      }
    }, {
      key: "lastData", get: function () {
        return this._lastData
      }
    }, {
      key: "_extra", value: function () {
        l(d(a.prototype), "_extra", this).call(this), this._data = {
          proceeded: "data-".concat(this._prefix, "-proceeded"),
          name: "data-".concat(this._prefix, "-name")
        }, this._loading = !1, this._links = [], this._popstateTimeout = !1, this._linksListeners = [], this._lastData = {}, this._visitedLinks = [window.location.href], this._outer = p.one(this._prop.selectors.outer), this.setLinks()
      }
    }, {
      key: "_setEvents", value: function () {
        this.listener(window, "popstate", this._popstate.bind(this))
      }
    }, {
      key: "setLinks", value: function () {
        this._removeLinksListeners(), this._links = p.all(this._prop.selectors.links), this._addLinksListeners()
      }
    }, {
      key: "_addLinksListeners", value: function () {
        var t = this, e = this._data.proceeded;
        this._links.forEach((function (n) {
          if (void 0 === n[e]) {
            var r = t.listener(n, "click", t.load.bind(t, {link: n, push: !0, popstate: !1}));
            t._linksListeners.push(r), n[e] = !0
          }
        }))
      }
    }, {
      key: "_removeLinksListeners", value: function () {
        var t = this;
        this._linksListeners.forEach((function (e) {
          t.removeEventListener({el: e.el, id: e.id}), delete e.el[t._data.proceeded]
        })), this._linksListeners = []
      }
    }, {
      key: "_popstate", value: function () {
        var t = this._prop.popstate;
        t.event ? this._popstateLoad() : t.reload && window.location.reload()
      }
    }, {
      key: "_popstateLoad", value: function () {
        var t = this._prop;
        this._popstateTimeout && (clearTimeout(this._popstateTimeout), this._popstateTimeout = !1), !this._loading & !t.disabled ? this._popstateTimeout = setTimeout(this._popstateForceLoad.bind(this), t.popstate.timeout) : this._loading && (this._popstateTimeout = setTimeout(this._popstateBusyLoad.bind(this), t.popstate.timeout))
      }
    }, {
      key: "_popstateForceLoad", value: function () {
        this._pageChange("popstate"), this.lbt("popstate", {href: window.location.href}), this.load({
          link: window.location.href,
          push: !1,
          popstate: !0
        })
      }
    }, {
      key: "_popstateBusyLoad", value: function () {
        var t = this;
        this.on("done", (function () {
          t._popstateLoad()
        }), {once: !0})
      }
    }, {
      key: "load", value: function (t) {
        var e = this, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r = this._prop;
        if (!r.on) return !1;
        var i = !1;
        if (t.link instanceof HTMLAnchorElement && t.link.getAttribute("target") && (i = !0), null != n & !i && n.preventDefault(), this._loading) return !1;
        if (r.disabled) return !1;
        var a = {push: !0, popstate: !1};
        t = (0, o.default)(a, t);
        var c = this._getHref(t.link);
        if (!c) return !1;
        if (!c.includes(window.location.host)) return window.location.href = c, !1;
        var l = {href: c, link: t.link, visited: this._visitedLinks.includes(c)};
        return !r.changeSame & !t.popstate && c == location.href ? (this._pageChange("clickSame"), this.lbt("clickSame", l), !1) : (this._loading = !0, this._pageChange("click"), this.lbt("click", l), this._pageChange("prepare"), this.lbt("prepare", l), (0, s.default)((function () {
          e._loadAjax(t, c)
        }), r.timeouts.load), !0)
      }
    }, {
      key: "_getHref", value: function (t) {
        return "string" == typeof t ? (t.includes("http") || (t = location.origin + t), t) : t instanceof HTMLAnchorElement && !!t.getAttribute("href") && t.href
      }
    }, {
      key: "_loadAjax", value: function (t, e) {
        var n = this._prop;
        this._v.ajax.load({
          url: e,
          method: n.ajax.method,
          data: {pageAjax: 1},
          cache: n.cache,
          success: this._loadSuccess.bind(this, t, e),
          abort: this._loadAjax.bind(this, t, e),
          error: this._loadError.bind(this, t, e)
        })
      }
    }, {
      key: "_loadSuccess", value: function (t, e, n) {
        this._visitedLinks.push(e), this._update(t, e, n)
      }
    }, {
      key: "_loadError", value: function (t, e, n) {
        this._prop.ajax.successCodes.includes(n.xhr.status) ? this._loadSuccess(t, e, n) : window.location.href = e
      }
    }, {
      key: "_update", value: function (t, e, n) {
        var r = this, i = this._prop, o = i.selectors.outer, a = document.createElement("html");
        a.innerHTML = n.xhr.responseText;
        var c = a.querySelector(o);
        if (null == c) throw new Error("There's no HTMLElement under the selector \"".concat(o, '"'));
        var l = c.getAttribute(this._data.name);
        if (null == l) throw new Error('The outer "'.concat(o, '" must contain the attribute "').concat(this._data.name, '"'));
        var u = c.innerHTML, h = {
          ajax: n,
          response: n.xhr.responseText,
          html: u,
          outer: c,
          name: l,
          e: a,
          push: t.push,
          href: e,
          popstate: t.popstate
        };
        this._pageChange("loaded", l), this.lbt("loaded", h), (0, s.default)((function () {
          r._updateContents(h), (0, s.default)((function () {
            r._done(h)
          }), i.timeouts.done), a = null
        }), i.timeouts.update)
      }
    }, {
      key: "_updateContents", value: function (t) {
        this._lastData = t, this._updateUrl(t), this._updateTitle(t), this._updateHTML(t), this._prop.menuLinks.update && this._updateMenuLinks(t, this.prop.menuLinks), this._updatePageData(t), this._pageChange("updated", t.name), this.lbt("updated", t)
      }
    }, {
      key: "_updateUrl", value: function (t) {
        this._prop.update.url & t.push && window.history.pushState(null, "", t.href)
      }
    }, {
      key: "_updateTitle", value: function (t) {
        if (this._prop.update.title) {
          var e = {old: document.querySelector("title"), new: t.e.querySelector("title")};
          null !== e.old & null !== e.new && (e.old.innerHTML = e.new.innerHTML)
        }
      }
    }, {
      key: "_updateHTML", value: function (t) {
        this._prop.update.content && (this._outer.innerHTML = t.html, this.setLinks())
      }
    }, {
      key: "updateMenuLinks", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.prop.menuLinks;
        t = (0, o.default)({
          update: !0,
          class: "active",
          compare: "href",
          selectorNew: ".menu a",
          selectorOld: ".menu a"
        }, t), Object.keys(this._lastData).length > 0 && this._updateMenuLinks(this._lastData, t)
      }
    }, {
      key: "_updateMenuLinks", value: function (t, e) {
        for (var n = {
          old: document.querySelectorAll(e.selectorNew),
          new: t.e.querySelectorAll(e.selectorOld)
        }, r = 0; r < n.new.length; r++) for (var i = n.new[r], o = i.getAttribute(e.compare), s = i.classList.contains(e.class), a = 0; a < n.old.length; a++) {
          var c = n.old[a];
          o === c.getAttribute(e.compare) && (s ? c.classList.add(e.class) : c.classList.remove(e.class))
        }
      }
    }, {
      key: "_updatePageData", value: function (t) {
        this._outer.setAttribute(this._data.name, t.name), this._v.page = [t.name]
      }
    }, {
      key: "_done", value: function (t) {
        this._loading = !1, this._pageChange("done", t.name), this.lbt("done", t)
      }
    }, {
      key: "_pageChange", value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", n = this._prop.pageChange;
        if (n.on) {
          if (t === n.hide && this._v.vevetPage.hide(), t === n.destroy && this._v.vevetPage.destroy(), t === n.create) {
            for (var r = !1, i = !1, o = 0; o < this._v.vevetPages.length; o++) {
              var s = this._v.vevetPages[o];
              s.name == e && (r = s), s.name == this._prop.pageChange.default && (i = s)
            }
            if (r) r.create(!0); else {
              if (!i) throw new Error("Default page doesn't exist!");
              i.create(!0)
            }
          }
          t === n.show && this._v.vevetPage.show()
        }
      }
    }], n && c(e.prototype, n), r && c(e, r), a
  }(i.default);
  e.default = m
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = s(n(15)), o = s(n(6));

  function s(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function a(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function c(t, e, n) {
    return c = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = f(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, c(t, e, n || t)
  }

  function l(t, e) {
    return l = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, l(t, e)
  }

  function u(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = f(t);
      if (e) {
        var i = f(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return h(this, n)
    }
  }

  function h(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function f(t) {
    return f = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, f(t)
  }

  var d = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && l(t, e)
    }(s, t);
    var e, n, r, i = u(s);

    function s(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, s), i.call(this, t)
    }

    return e = s, n = [{
      key: "defaultProp", get: function () {
        return (0, o.default)(c(f(s.prototype), "defaultProp", this), {interval: 250})
      }
    }, {
      key: "add", value: function (t) {
        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        if (void 0 !== t.input) {
          t.input = t.input.toUpperCase(), t.keys = [];
          for (var n = 0; n < t.input.length; n++) t.keys.push(t.input[n].charCodeAt(0))
        }
        return c(f(s.prototype), "add", this).call(this, t, e)
      }
    }, {
      key: "_setEvents", value: function () {
        var t = this;
        this.listener(window, "keydown", (function (e) {
          t._implement(e)
        }))
      }
    }, {
      key: "_implement", value: function (t) {
        var e = this;
        this._events.forEach((function (n) {
          if (n.on) {
            var r = n.data;
            if ("once" === r.target) t.keyCode === r.keys[0] && e._launch(n, t); else if ("queue" === r.target) {
              if (void 0 === n.string && (n.string = ""), n.string += "-" + t.keyCode, void 0 === n.compareString) {
                n.compareString = "";
                for (var i = 0; i < r.keys.length; i++) n.compareString += "-" + r.keys[i]
              }
              n.string.includes(n.compareString) && (e._launch(n, t), n.string = "")
            } else if ("multi" === r.target) {
              void 0 === n.array && (n.array = []), n.array.push(t.keyCode), setTimeout((function () {
                n.array = []
              }), e._prop.interval);
              for (var o = 0, s = 0; s < r.keys.length; s++) for (var a = 0; a < n.array.length; a++) r.keys[s] === n.array[a] && o++;
              r.keys.length === o && (e._launch(n, t), n.array = [])
            }
          }
        }))
      }
    }], n && a(e.prototype, n), r && a(e, r), s
  }(i.default);
  e.default = d
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = s(n(15)), o = s(n(6));

  function s(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function a(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function c(t, e, n) {
    return c = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = f(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, c(t, e, n || t)
  }

  function l(t, e) {
    return l = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, l(t, e)
  }

  function u(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = f(t);
      if (e) {
        var i = f(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return h(this, n)
    }
  }

  function h(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function f(t) {
    return f = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, f(t)
  }

  var d = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && l(t, e)
    }(s, t);
    var e, n, r, i = u(s);

    function s(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, s), i.call(this, t)
    }

    return e = s, n = [{
      key: "defaultProp", get: function () {
        return (0, o.default)(c(f(s.prototype), "defaultProp", this), {name: "home"})
      }
    }, {
      key: "created", get: function () {
        return this._created
      }
    }, {
      key: "shown", get: function () {
        return this._shown
      }
    }, {
      key: "hidden", get: function () {
        return this._hidden
      }
    }, {
      key: "destroyed", get: function () {
        return this._destroyed
      }
    }, {
      key: "name", get: function () {
        return this._prop.name
      }
    }, {
      key: "_extra", value: function () {
        c(f(s.prototype), "_extra", this).call(this), this._initVars(), this._v.vevetPages.push(this)
      }
    }, {
      key: "_initVars", value: function () {
        this._created = !1, this._shown = !1, this._hidden = !1, this._destroyed = !1, this._throughAjax = !1
      }
    }, {
      key: "create", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return !!this.createCheck() && (this._created = !0, this._shown = !1, this._hidden = !1, this._destroyed = !1, this._throughAjax = t, this._v.vevetPage = this, this.lbt("create"), this)
      }
    }, {
      key: "createCheck", value: function () {
        return !this._created
      }
    }, {
      key: "show", value: function () {
        return !!this.showCheck() && (this._created = !0, this._shown = !0, this._hidden = !1, this._destroyed = !1, this.lbt("show"), !0)
      }
    }, {
      key: "showCheck", value: function () {
        return !!this._created && !this._shown
      }
    }, {
      key: "hide", value: function () {
        return !!this.hideCheck() && (this._created = !0, this._shown = !1, this._hidden = !0, this._destroyed = !1, this.lbt("hide"), !0)
      }
    }, {
      key: "hideCheck", value: function () {
        return !!this._created && !(!this._shown || this._hidden)
      }
    }, {
      key: "destroy", value: function () {
        return !!this.destroyCheck() && (c(f(s.prototype), "destroy", this).call(this), this._initVars(), this._v.vevetPage = !1, !0)
      }
    }, {
      key: "destroyCheck", value: function () {
        return !!this._created && !!this._hidden
      }
    }, {
      key: "onPageShown", value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        this._shown ? t() : this.on("show", (function () {
          t()
        }), e)
      }
    }, {
      key: "onPageHidden", value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        this._hidden ? t() : this.on("hide", (function () {
          t()
        }), e)
      }
    }], n && a(e.prototype, n), r && a(e, r), s
  }(i.default);
  e.default = d
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = s(n(15)), o = s(n(6));

  function s(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function a(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function c(t, e, n) {
    return c = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = f(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, c(t, e, n || t)
  }

  function l(t, e) {
    return l = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, l(t, e)
  }

  function u(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = f(t);
      if (e) {
        var i = f(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return h(this, n)
    }
  }

  function h(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function f(t) {
    return f = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, f(t)
  }

  var d = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && l(t, e)
    }(s, t);
    var e, n, r, i = u(s);

    function s(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, s), i.call(this, t)
    }

    return e = s, n = [{
      key: "defaultProp", get: function () {
        return (0, o.default)(c(f(s.prototype), "defaultProp", this), {fps: 60})
      }
    }, {
      key: "_extra", value: function () {
        c(f(s.prototype), "_extra", this).call(this), this._time = null, this._frameSeg = -1, this._frame = null, this._playing = !1
      }
    }, {
      key: "playing", get: function () {
        return this._playing
      }
    }, {
      key: "play", value: function () {
        return !this._playing && (this._playing = !0, this._start(), !0)
      }
    }, {
      key: "_start", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        this._frame = window.requestAnimationFrame(this._start.bind(this)), null == this._time && (this._time = t);
        var e = Math.floor((t - this._time) / (1e3 / this._prop.fps));
        e > this._frameSeg && (this._frameSeg = e, this.launchAll())
      }
    }, {
      key: "pause", value: function () {
        return !!this._playing && (window.cancelAnimationFrame(this._frame), this._playing = !1, !0)
      }
    }, {
      key: "destroy", value: function () {
        c(f(s.prototype), "destroy", this).call(this), this.pause()
      }
    }], n && a(e.prototype, n), r && a(e, r), s
  }(i.default);
  e.default = d
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = a(n(117)), o = a(n(6)), s = a(n(17));

  function a(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function c(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function l(t, e, n) {
    return l = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = d(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, l(t, e, n || t)
  }

  function u(t, e) {
    return u = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, u(t, e)
  }

  function h(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = d(t);
      if (e) {
        var i = d(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return f(this, n)
    }
  }

  function f(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function d(t) {
    return d = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, d(t)
  }

  var p = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && u(t, e)
    }(a, t);
    var e, n, r, i = h(a);

    function a(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, a), i.call(this, t)
    }

    return e = a, n = [{
      key: "prefix", get: function () {
        return "".concat(this._v.prefix, "view")
      }
    }, {
      key: "defaultProp", get: function () {
        return (0, o.default)(l(d(a.prototype), "defaultProp", this), {
          edge: .9,
          seekLoad: !0,
          classToAdd: "".concat(this._prefix, "__el_viewed"),
          stackDelay: 100,
          autostack: {on: !1, delay: 750}
        })
      }
    }, {
      key: "_extra", value: function () {
        var t = this._prefix;
        this._edge = 0, this._firstLoad = !0, this._data = {
          proceeded: "data-".concat(t, "-proceeded"),
          in: "data-".concat(t, "-in"),
          stack: "data-".concat(t, "-stack")
        }, l(d(a.prototype), "_extra", this).call(this), this._properties = {callback: "".concat(t, "-callback")}
      }
    }, {
      key: "_elGet", value: function () {
        l(d(a.prototype), "_elGet", this).call(this);
        for (var t = this._data, e = 0; e < this._el.length; e++) {
          var n = this._el[e];
          void 0 === n[t.proceeded] && (n[t.in] = !1, n[t.proceeded] = !0)
        }
      }
    }, {
      key: "updateEl", value: function () {
        this._removeScrollListeners(), this._elGet()
      }
    }, {
      key: "_setEvents", value: function () {
        var t = this;
        l(d(a.prototype), "_setEvents", this).call(this);
        var e = this._prop;
        e.seekLoad && this.addEvent("load", {
          name: this.name, do: function () {
            e.seekLoad && t.seek()
          }
        }), this.on("in", (function (t) {
          t.el.classList.add(e.classToAdd)
        }))
      }
    }, {
      key: "setSize", value: function () {
        l(d(a.prototype), "setSize", this).call(this), this._edge = this._prop.edge * this._size
      }
    }, {
      key: "seek", value: function () {
        var t = this, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
        if (!l(d(a.prototype), "seek", this).call(this, e)) return !1;
        var n = this._bounding, r = this._prop, i = r.horizontal, o = this._data, c = this._edge;
        this._firstLoad && (c = this._size);
        for (var u = function (e) {
          var r = t._el[e];
          if (r[o.in]) return "continue";
          var a = r.getBoundingClientRect(),
            l = {top: a.top - n.top, bottom: a.bottom - n.bottom, left: a.left - n.left, right: a.right - n.right},
            u = i ? [l.left, l.right] : [l.top, l.bottom], h = i ? r.clientWidth : r.clientHeight;
          if (u[0] < c && u[0] > -1 * h) {
            var f = 0;
            t._firstLoad && (f = t._getDelay(r, u));
            var d = {el: r};
            (0, s.default)((function () {
              t.lbt("in", d), t._seekCallback(r)
            }), f), r[o.in] = !0
          }
        }, h = 0; h < this._el.length; h++) u(h);
        return this._firstLoad && (this._firstLoad = !1), !0
      }
    }, {
      key: "_getDelay", value: function (t, e) {
        var n = this._prop, r = n.autostack, i = 0, o = t.getAttribute(this._data.stack);
        return o ? i = parseInt(o) * n.stackDelay : r.on && (i = e[0] / this._size * r.delay), i
      }
    }, {
      key: "_seekCallback", value: function (t) {
        var e = this._properties.callback;
        void 0 !== t[e] && t[e]()
      }
    }], n && c(e.prototype, n), r && c(e, r), a
  }(i.default);
  e.default = p
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = c(n(118)), o = c(n(6)), s = c(n(36)), a = c(n(10));

  function c(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function l(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function u(t, e, n) {
    return u = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = p(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, u(t, e, n || t)
  }

  function h(t, e) {
    return h = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, h(t, e)
  }

  function f(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = p(t);
      if (e) {
        var i = p(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return d(this, n)
    }
  }

  function d(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function p(t) {
    return p = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, p(t)
  }

  var m = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && h(t, e)
    }(c, t);
    var e, n, r, i = f(c);

    function c(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, c), i.call(this, t)
    }

    return e = c, (n = [{
      key: "defaultProp", get: function () {
        return (0, o.default)(u(p(c.prototype), "defaultProp", this), {
          timeline: {
            duration: 1500,
            outerScope: [0, .25],
            innerScope: [0, 1],
            easing: this._vp.easing
          }
        })
      }
    }, {
      key: "_extra", value: function () {
        u(p(c.prototype), "_extra", this).call(this);
        var t = this._prop.timeline, e = t.easing;
        this._timeline = new a.default;
        var n = this._timeline;
        n.on("progress", this._timelineAnimation.bind(this)), n.on("end", this._timelineAnimationEnd.bind(this)), this._timelineOuter = new s.default({
          line: t.outerScope,
          easing: e
        }), this._timelineOuter.on("progress", this._timelineOuterAnimation.bind(this)), n.addTimeline(this._timelineOuter), this._timelineInner = new s.default({
          line: t.innerScope,
          easing: e
        }), this._timelineInner.on("progress", this._timelineInnerAnimation.bind(this)), n.addTimeline(this._timelineInner)
      }
    }, {
      key: "_timelineAnimation", value: function (t) {
        this.lbt("progress", t)
      }
    }, {
      key: "_timelineAnimationEnd", value: function () {
        this._timeline.reversed ? this.lbt("hidden") : this.lbt("shown");
        var t = this._outer, e = this._prefix;
        this._timeline.reversed && (t.classList.remove("".concat(e, "_show")), t.classList.remove("".concat(e, "_hide")))
      }
    }, {
      key: "_timelineOuterAnimation", value: function (t) {
        this.lbt("progressOuter", t);
        var e = this._outer, n = this._button, r = this._prefix;
        this._timeline.reversed ? t.p < 1 && (e.classList.add("".concat(r, "_hide")), n && n.classList.remove("".concat(r, "-button_close"))) : t.p > 0 && (e.classList.add("".concat(r, "_show")), e.classList.remove("".concat(r, "_hide")), n && n.classList.add("".concat(r, "-button_close")))
      }
    }, {
      key: "_timelineInnerAnimation", value: function (t) {
        this.lbt("progressInner", t)
      }
    }, {
      key: "_show", value: function () {
        u(p(c.prototype), "_show", this).call(this);
        var t = this._timeline;
        t.playing ? t.reverse() : (t.reversed && t.reverse(), t.play({
          duration: this._prop.timeline.duration,
          easing: this._prop.timeline.easing
        }))
      }
    }, {
      key: "_hide", value: function () {
        u(p(c.prototype), "_hide", this).call(this);
        var t = this._timeline;
        t.playing ? t.reverse() : (t.reverse(), t.play({
          duration: this._prop.timeline.duration,
          easing: this._prop.timeline.easing
        }))
      }
    }]) && l(e.prototype, n), r && l(e, r), c
  }(i.default);
  e.default = m
}, function (t, e) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var n = function (t, e) {
    for (var n = [], r = 1 / (t - e * (t - 1)), i = 0; i < t; i++) {
      var o = r * (1 - e) * i, s = o + r;
      n.push([o, s])
    }
    return n
  };
  e.default = n
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = s(n(15)), o = s(n(6));

  function s(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function a(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function c(t, e, n) {
    return c = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = f(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, c(t, e, n || t)
  }

  function l(t, e) {
    return l = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, l(t, e)
  }

  function u(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = f(t);
      if (e) {
        var i = f(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return h(this, n)
    }
  }

  function h(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function f(t) {
    return f = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, f(t)
  }

  var d = n(54), p = n(25), m = n(46), v = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && l(t, e)
    }(s, t);
    var e, n, r, i = u(s);

    function s(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, s), i.call(this, t)
    }

    return e = s, (n = [{
      key: "prefix", get: function () {
        return "".concat(this._v.prefix, "cursor")
      }
    }, {
      key: "defaultProp", get: function () {
        return (0, o.default)(c(f(s.prototype), "defaultProp", this), {selector: "body", ease: .2, run: !0})
      }
    }, {
      key: "outer", get: function () {
        return this._outer
      }
    }, {
      key: "cursor", get: function () {
        return this._cursor
      }
    }, {
      key: "_extra", value: function () {
        c(f(s.prototype), "_extra", this).call(this), this._mouse = {x: 0, y: 0}, this._pos = {x: 0, y: 0};
        var t = this._prefix;
        this._classes = {
          show: "".concat(t, "_show"),
          click: "".concat(t, "_click")
        }, this._outer = p.one(this._prop.selector), this._create(), this._runPrevBool = this._prop.run, this._play()
      }
    }, {
      key: "_changeProp", value: function () {
        c(f(s.prototype), "_changeProp", this).call(this), this.prop.run !== this._runPrevBool && this._play(), this._runPrevBool = this._prop.run
      }
    }, {
      key: "_create", value: function () {
        this._cursor = d({
          selector: "div",
          styles: this._prefix
        }), this._outer.appendChild(this._cursor), this.lbt("create")
      }
    }, {
      key: "_setEvents", value: function () {
        c(f(s.prototype), "_setEvents", this).call(this), this.listener(this._outer, "mousemove", this._mousemove.bind(this)), this.listener(this._outer, "mouseenter", this._mouseenter.bind(this)), this.listener(this._outer, "mouseleave", this._mouseleave.bind(this)), this.listener(this._outer, "mousedown", this._mousedown.bind(this)), this.listener(this._outer, "mouseup", this._mouseup.bind(this)), this.listener(window, "blur", this._blur.bind(this))
      }
    }, {
      key: "_mousemove", value: function (t) {
        this._mouse.x = t.x, this._mouse.y = t.y, this._outer.classList.add(this._classes.show)
      }
    }, {
      key: "_mouseenter", value: function (t) {
        this._outer.classList.add(this._classes.show), this._mouse.x = t.clientX, this._mouse.y = t.clientY;
        var e = this.prop.ease;
        this.prop.ease = 1, this._animatePos(), this._render(), this.prop.ease = e
      }
    }, {
      key: "_mouseleave", value: function () {
        this._outer.classList.remove(this._classes.show)
      }
    }, {
      key: "_mousedown", value: function (t) {
        1 === t.which && this._cursor.classList.add(this._classes.click)
      }
    }, {
      key: "_mouseup", value: function () {
        this._cursor.classList.remove(this._classes.click)
      }
    }, {
      key: "_blur", value: function () {
        this._cursor.classList.remove(this._classes.click)
      }
    }, {
      key: "_play", value: function () {
        this._prop.run && (window.requestAnimationFrame(this._play.bind(this)), this._animate())
      }
    }, {
      key: "_animate", value: function () {
        this._animatePos(), this._render(), this.lbt("render")
      }
    }, {
      key: "_animatePos", value: function () {
        var t = this._cursor.clientWidth, e = this._cursor.clientHeight, n = this._mouse.x - t / 2,
          r = this._mouse.y - e / 2;
        this._pos.x = m(this._pos.x, n, this._prop.ease), this._pos.y = m(this._pos.y, r, this._prop.ease)
      }
    }, {
      key: "_render", value: function () {
        this._cursor.style.transform = "translate3d(".concat(this._pos.x, "px, ").concat(this._pos.y, "px, 0)")
      }
    }]) && a(e.prototype, n), r && a(e, r), s
  }(i.default);
  e.default = v
}, function (t) {
  var e;
  e = function () {
    return this
  }();
  try {
    e = e || new Function("return this")()
  } catch (n) {
    "object" == typeof window && (e = window)
  }
  t.exports = e
}, function (t, e, n) {
  "use strict";
  var r, i = function () {
    return void 0 === r && (r = Boolean(window && document && document.all && !window.atob)), r
  }, o = function () {
    var t = {};
    return function (e) {
      if (void 0 === t[e]) {
        var n = document.querySelector(e);
        if (window.HTMLIFrameElement && n instanceof window.HTMLIFrameElement) try {
          n = n.contentDocument.head
        } catch (r) {
          n = null
        }
        t[e] = n
      }
      return t[e]
    }
  }(), s = [];

  function a(t) {
    for (var e = -1, n = 0; n < s.length; n++) if (s[n].identifier === t) {
      e = n;
      break
    }
    return e
  }

  function c(t, e) {
    for (var n = {}, r = [], i = 0; i < t.length; i++) {
      var o = t[i], c = e.base ? o[0] + e.base : o[0], l = n[c] || 0, u = "".concat(c, " ").concat(l);
      n[c] = l + 1;
      var h = a(u), f = {css: o[1], media: o[2], sourceMap: o[3]};
      -1 !== h ? (s[h].references++, s[h].updater(f)) : s.push({
        identifier: u,
        updater: v(f, e),
        references: 1
      }), r.push(u)
    }
    return r
  }

  function l(t) {
    var e = document.createElement("style"), r = t.attributes || {};
    if (void 0 === r.nonce) {
      var i = n.nc;
      i && (r.nonce = i)
    }
    if (Object.keys(r).forEach((function (t) {
      e.setAttribute(t, r[t])
    })), "function" == typeof t.insert) t.insert(e); else {
      var s = o(t.insert || "head");
      if (!s) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
      s.appendChild(e)
    }
    return e
  }

  var u, h = (u = [], function (t, e) {
    return u[t] = e, u.filter(Boolean).join("\n")
  });

  function f(t, e, n, r) {
    var i = n ? "" : r.media ? "@media ".concat(r.media, " {").concat(r.css, "}") : r.css;
    if (t.styleSheet) t.styleSheet.cssText = h(e, i); else {
      var o = document.createTextNode(i), s = t.childNodes;
      s[e] && t.removeChild(s[e]), s.length ? t.insertBefore(o, s[e]) : t.appendChild(o)
    }
  }

  function d(t, e, n) {
    var r = n.css, i = n.media, o = n.sourceMap;
    if (i ? t.setAttribute("media", i) : t.removeAttribute("media"), o && "undefined" != typeof btoa && (r += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(o)))), " */")), t.styleSheet) t.styleSheet.cssText = r; else {
      for (; t.firstChild;) t.removeChild(t.firstChild);
      t.appendChild(document.createTextNode(r))
    }
  }

  var p = null, m = 0;

  function v(t, e) {
    var n, r, i;
    if (e.singleton) {
      var o = m++;
      n = p || (p = l(e)), r = f.bind(null, n, o, !1), i = f.bind(null, n, o, !0)
    } else n = l(e), r = d.bind(null, n, e), i = function () {
      !function (t) {
        if (null === t.parentNode) return !1;
        t.parentNode.removeChild(t)
      }(n)
    };
    return r(t), function (e) {
      if (e) {
        if (e.css === t.css && e.media === t.media && e.sourceMap === t.sourceMap) return;
        r(t = e)
      } else i()
    }
  }

  t.exports = function (t, e) {
    (e = e || {}).singleton || "boolean" == typeof e.singleton || (e.singleton = i());
    var n = c(t = t || [], e);
    return function (t) {
      if (t = t || [], "[object Array]" === Object.prototype.toString.call(t)) {
        for (var r = 0; r < n.length; r++) {
          var i = a(n[r]);
          s[i].references--
        }
        for (var o = c(t, e), l = 0; l < n.length; l++) {
          var u = a(n[l]);
          0 === s[u].references && (s[u].updater(), s.splice(u, 1))
        }
        n = o
      }
    }
  }
}, function (t) {
  t.exports = function (t) {
    return t.webpackPolyfill || (t.deprecate = function () {
    }, t.paths = [], t.children || (t.children = []), Object.defineProperty(t, "loaded", {
      enumerable: !0,
      get: function () {
        return t.l
      }
    }), Object.defineProperty(t, "id", {
      enumerable: !0, get: function () {
        return t.i
      }
    }), t.webpackPolyfill = 1), t
  }
}, function (t, e, n) {
  "use strict";
  n.r(e), e.default = "#define GLSLIFY 1\n// https://www.shadertoy.com/view/Xltfzj\n\nvec4 blurShift(vec4 coord, float shiftX, float shiftY) {\n    coord.x = coord.x + shiftX;\n    coord.y = coord.y + shiftY;\n    return coord;\n}\n\nvec4 blur_texture2DProj(sampler2D tDiffuse, vec4 uv) {\n\n    const float Pi = 6.28318530718;\n    const float Directions = 16.0;\n    const float DirStep = Pi / Directions;\n    const float Quality = 7.0;\n    const float QualityStep = 1. / Quality;\n    const float Size = 20.0;\n    \n    // Pixel colour\n    vec4 Color = texture2DProj(tDiffuse, uv);\n    \n    // Blur calculations\n    for (float d = 0.0; d < Pi; d += DirStep) {\n\t\tfor (float i = QualityStep; i <= 1.0; i += QualityStep) {\n            Color += texture2DProj( tDiffuse, blurShift(uv, cos(d)*Size*i, sin(d)*Size*i) );\n        }\n    }\n    \n    // Output to screen\n    Color /= Quality * Directions - 15.0;\n\n    return Color;\n\n}\n\n"
}, function (t, e, n) {
  var r = n(99), i = n(103);
  "string" == typeof(i = i.__esModule ? i.default : i) && (i = [[t.i, i, ""]]);
  var o = {insert: "head", singleton: !1};
  r(i, o);
  t.exports = i.locals || {}
}, function () {
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  var i;

  function o(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function s(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function a(t, e, n) {
    return a = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = h(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, a(t, e, n || t)
  }

  function c(t, e) {
    return c = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, c(t, e)
  }

  function l(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = h(t);
      if (e) {
        var i = h(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return u(this, n)
    }
  }

  function u(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function h(t) {
    return h = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, h(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var f = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && c(t, e)
    }(u, t);
    var e, n, r, i = l(u);

    function u() {
      return o(this, u), i.apply(this, arguments)
    }

    return e = u, (n = [{
      key: "_extra", value: function () {
        a(h(u.prototype), "_extra", this).call(this), this._loaded = !1
      }
    }, {
      key: "loaded", get: function () {
        return this._loaded
      }
    }, {
      key: "_setEvents", value: function () {
        var t = this;
        this.add({
          do: function () {
            var e = t._vp.prefix;
            t._loaded = !0, t._v.html.classList.remove("".concat(e, "loading")), t._v.body.classList.remove("".concat(e, "loading"))
          }, protected: !0
        }), window.addEventListener("load", this.launchAll.bind(this))
      }
    }]) && s(e.prototype, n), r && s(e, r), u
  }(((i = n(23)) && i.__esModule ? i : {default: i}).default);
  e.default = f
}, function (t, e, n) {
  (function (t, n) {
    var r = "__lodash_hash_undefined__", i = 9007199254740991, o = "[object Arguments]", s = "[object Function]",
      a = "[object Object]", c = /^\[object .+?Constructor\]$/, l = /^(?:0|[1-9]\d*)$/, u = {};
    u["[object Float32Array]"] = u["[object Float64Array]"] = u["[object Int8Array]"] = u["[object Int16Array]"] = u["[object Int32Array]"] = u["[object Uint8Array]"] = u["[object Uint8ClampedArray]"] = u["[object Uint16Array]"] = u["[object Uint32Array]"] = !0, u[o] = u["[object Array]"] = u["[object ArrayBuffer]"] = u["[object Boolean]"] = u["[object DataView]"] = u["[object Date]"] = u["[object Error]"] = u[s] = u["[object Map]"] = u["[object Number]"] = u[a] = u["[object RegExp]"] = u["[object Set]"] = u["[object String]"] = u["[object WeakMap]"] = !1;
    var h = "object" == typeof t && t && t.Object === Object && t,
      f = "object" == typeof self && self && self.Object === Object && self, d = h || f || Function("return this")(),
      p = e && !e.nodeType && e, m = p && "object" == typeof n && n && !n.nodeType && n, v = m && m.exports === p,
      g = v && h.process, y = function () {
        try {
          var t = m && m.require && m.require("util").types;
          return t || g && g.binding && g.binding("util")
        } catch (e) {
        }
      }(), _ = y && y.isTypedArray;

    function b(t, e, n) {
      switch (n.length) {
        case 0:
          return t.call(e);
        case 1:
          return t.call(e, n[0]);
        case 2:
          return t.call(e, n[0], n[1]);
        case 3:
          return t.call(e, n[0], n[1], n[2])
      }
      return t.apply(e, n)
    }

    var x, w, S, M = Array.prototype, E = Function.prototype, T = Object.prototype, O = d["__core-js_shared__"],
      H = E.toString, A = T.hasOwnProperty,
      P = (x = /[^.]+$/.exec(O && O.keys && O.keys.IE_PROTO || "")) ? "Symbol(src)_1." + x : "", R = T.toString,
      L = H.call(Object),
      C = RegExp("^" + H.call(A).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
      k = v ? d.Buffer : void 0, D = d.Symbol, N = d.Uint8Array, z = k ? k.allocUnsafe : void 0,
      j = (w = Object.getPrototypeOf, S = Object, function (t) {
        return w(S(t))
      }), I = Object.create, B = T.propertyIsEnumerable, F = M.splice, U = D ? D.toStringTag : void 0, G = function () {
        try {
          var t = mt(Object, "defineProperty");
          return t({}, "", {}), t
        } catch (e) {
        }
      }(), V = k ? k.isBuffer : void 0, W = Math.max, X = Date.now, q = mt(d, "Map"), Y = mt(Object, "create"),
      Z = function () {
        function t() {
        }

        return function (e) {
          if (!Ot(e)) return {};
          if (I) return I(e);
          t.prototype = e;
          var n = new t;
          return t.prototype = void 0, n
        }
      }();

    function J(t) {
      var e = -1, n = null == t ? 0 : t.length;
      for (this.clear(); ++e < n;) {
        var r = t[e];
        this.set(r[0], r[1])
      }
    }

    function K(t) {
      var e = -1, n = null == t ? 0 : t.length;
      for (this.clear(); ++e < n;) {
        var r = t[e];
        this.set(r[0], r[1])
      }
    }

    function Q(t) {
      var e = -1, n = null == t ? 0 : t.length;
      for (this.clear(); ++e < n;) {
        var r = t[e];
        this.set(r[0], r[1])
      }
    }

    function $(t) {
      var e = this.__data__ = new K(t);
      this.size = e.size
    }

    function tt(t, e) {
      var n = wt(t), r = !n && xt(t), i = !n && !r && Mt(t), o = !n && !r && !i && At(t), s = n || r || i || o,
        a = s ? function (t, e) {
          for (var n = -1, r = Array(t); ++n < t;) r[n] = e(n);
          return r
        }(t.length, String) : [], c = a.length;
      for (var l in t) !e && !A.call(t, l) || s && ("length" == l || i && ("offset" == l || "parent" == l) || o && ("buffer" == l || "byteLength" == l || "byteOffset" == l) || vt(l, c)) || a.push(l);
      return a
    }

    function et(t, e, n) {
      (void 0 !== n && !bt(t[e], n) || void 0 === n && !(e in t)) && it(t, e, n)
    }

    function nt(t, e, n) {
      var r = t[e];
      A.call(t, e) && bt(r, n) && (void 0 !== n || e in t) || it(t, e, n)
    }

    function rt(t, e) {
      for (var n = t.length; n--;) if (bt(t[n][0], e)) return n;
      return -1
    }

    function it(t, e, n) {
      "__proto__" == e && G ? G(t, e, {configurable: !0, enumerable: !0, value: n, writable: !0}) : t[e] = n
    }

    J.prototype.clear = function () {
      this.__data__ = Y ? Y(null) : {}, this.size = 0
    }, J.prototype.delete = function (t) {
      var e = this.has(t) && delete this.__data__[t];
      return this.size -= e ? 1 : 0, e
    }, J.prototype.get = function (t) {
      var e = this.__data__;
      if (Y) {
        var n = e[t];
        return n === r ? void 0 : n
      }
      return A.call(e, t) ? e[t] : void 0
    }, J.prototype.has = function (t) {
      var e = this.__data__;
      return Y ? void 0 !== e[t] : A.call(e, t)
    }, J.prototype.set = function (t, e) {
      var n = this.__data__;
      return this.size += this.has(t) ? 0 : 1, n[t] = Y && void 0 === e ? r : e, this
    }, K.prototype.clear = function () {
      this.__data__ = [], this.size = 0
    }, K.prototype.delete = function (t) {
      var e = this.__data__, n = rt(e, t);
      return !(n < 0) && (n == e.length - 1 ? e.pop() : F.call(e, n, 1), --this.size, !0)
    }, K.prototype.get = function (t) {
      var e = this.__data__, n = rt(e, t);
      return n < 0 ? void 0 : e[n][1]
    }, K.prototype.has = function (t) {
      return rt(this.__data__, t) > -1
    }, K.prototype.set = function (t, e) {
      var n = this.__data__, r = rt(n, t);
      return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this
    }, Q.prototype.clear = function () {
      this.size = 0, this.__data__ = {hash: new J, map: new (q || K), string: new J}
    }, Q.prototype.delete = function (t) {
      var e = pt(this, t).delete(t);
      return this.size -= e ? 1 : 0, e
    }, Q.prototype.get = function (t) {
      return pt(this, t).get(t)
    }, Q.prototype.has = function (t) {
      return pt(this, t).has(t)
    }, Q.prototype.set = function (t, e) {
      var n = pt(this, t), r = n.size;
      return n.set(t, e), this.size += n.size == r ? 0 : 1, this
    }, $.prototype.clear = function () {
      this.__data__ = new K, this.size = 0
    }, $.prototype.delete = function (t) {
      var e = this.__data__, n = e.delete(t);
      return this.size = e.size, n
    }, $.prototype.get = function (t) {
      return this.__data__.get(t)
    }, $.prototype.has = function (t) {
      return this.__data__.has(t)
    }, $.prototype.set = function (t, e) {
      var n = this.__data__;
      if (n instanceof K) {
        var r = n.__data__;
        if (!q || r.length < 199) return r.push([t, e]), this.size = ++n.size, this;
        n = this.__data__ = new Q(r)
      }
      return n.set(t, e), this.size = n.size, this
    };
    var ot, st = function (t, e, n) {
      for (var r = -1, i = Object(t), o = n(t), s = o.length; s--;) {
        var a = o[ot ? s : ++r];
        if (!1 === e(i[a], a, i)) break
      }
      return t
    };

    function at(t) {
      return null == t ? void 0 === t ? "[object Undefined]" : "[object Null]" : U && U in Object(t) ? function (t) {
        var e = A.call(t, U), n = t[U];
        try {
          t[U] = void 0;
          var r = !0
        } catch (o) {
        }
        var i = R.call(t);
        r && (e ? t[U] = n : delete t[U]);
        return i
      }(t) : function (t) {
        return R.call(t)
      }(t)
    }

    function ct(t) {
      return Ht(t) && at(t) == o
    }

    function lt(t) {
      return !(!Ot(t) || function (t) {
        return !!P && P in t
      }(t)) && (Et(t) ? C : c).test(function (t) {
        if (null != t) {
          try {
            return H.call(t)
          } catch (e) {
          }
          try {
            return t + ""
          } catch (e) {
          }
        }
        return ""
      }(t))
    }

    function ut(t) {
      if (!Ot(t)) return function (t) {
        var e = [];
        if (null != t) for (var n in Object(t)) e.push(n);
        return e
      }(t);
      var e = gt(t), n = [];
      for (var r in t) ("constructor" != r || !e && A.call(t, r)) && n.push(r);
      return n
    }

    function ht(t, e, n, r, i) {
      t !== e && st(e, (function (o, s) {
        if (i || (i = new $), Ot(o)) !function (t, e, n, r, i, o, s) {
          var c = yt(t, n), l = yt(e, n), u = s.get(l);
          if (u) return void et(t, n, u);
          var h = o ? o(c, l, n + "", t, e, s) : void 0, f = void 0 === h;
          if (f) {
            var d = wt(l), p = !d && Mt(l), m = !d && !p && At(l);
            h = l, d || p || m ? wt(c) ? h = c : Ht(b = c) && St(b) ? h = function (t, e) {
              var n = -1, r = t.length;
              e || (e = Array(r));
              for (; ++n < r;) e[n] = t[n];
              return e
            }(c) : p ? (f = !1, h = function (t, e) {
              if (e) return t.slice();
              var n = t.length, r = z ? z(n) : new t.constructor(n);
              return t.copy(r), r
            }(l, !0)) : m ? (f = !1, v = l, g = !0 ? (y = v.buffer, _ = new y.constructor(y.byteLength), new N(_).set(new N(y)), _) : v.buffer, h = new v.constructor(g, v.byteOffset, v.length)) : h = [] : function (t) {
              if (!Ht(t) || at(t) != a) return !1;
              var e = j(t);
              if (null === e) return !0;
              var n = A.call(e, "constructor") && e.constructor;
              return "function" == typeof n && n instanceof n && H.call(n) == L
            }(l) || xt(l) ? (h = c, xt(c) ? h = function (t) {
              return function (t, e, n, r) {
                var i = !n;
                n || (n = {});
                var o = -1, s = e.length;
                for (; ++o < s;) {
                  var a = e[o], c = r ? r(n[a], t[a], a, n, t) : void 0;
                  void 0 === c && (c = t[a]), i ? it(n, a, c) : nt(n, a, c)
                }
                return n
              }(t, Pt(t))
            }(c) : Ot(c) && !Et(c) || (h = function (t) {
              return "function" != typeof t.constructor || gt(t) ? {} : Z(j(t))
            }(l))) : f = !1
          }
          var v, g, y, _;
          var b;
          f && (s.set(l, h), i(h, l, r, o, s), s.delete(l));
          et(t, n, h)
        }(t, e, s, n, ht, r, i); else {
          var c = r ? r(yt(t, s), o, s + "", t, e, i) : void 0;
          void 0 === c && (c = o), et(t, s, c)
        }
      }), Pt)
    }

    function ft(t, e) {
      return _t(function (t, e, n) {
        return e = W(void 0 === e ? t.length - 1 : e, 0), function () {
          for (var r = arguments, i = -1, o = W(r.length - e, 0), s = Array(o); ++i < o;) s[i] = r[e + i];
          i = -1;
          for (var a = Array(e + 1); ++i < e;) a[i] = r[i];
          return a[e] = n(s), b(t, this, a)
        }
      }(t, e, Ct), t + "")
    }

    var dt = G ? function (t, e) {
      return G(t, "toString", {
        configurable: !0, enumerable: !1, value: (n = e, function () {
          return n
        }), writable: !0
      });
      var n
    } : Ct;

    function pt(t, e) {
      var n, r, i = t.__data__;
      return ("string" == (r = typeof(n = e)) || "number" == r || "symbol" == r || "boolean" == r ? "__proto__" !== n : null === n) ? i["string" == typeof e ? "string" : "hash"] : i.map
    }

    function mt(t, e) {
      var n = function (t, e) {
        return null == t ? void 0 : t[e]
      }(t, e);
      return lt(n) ? n : void 0
    }

    function vt(t, e) {
      var n = typeof t;
      return !!(e = null == e ? i : e) && ("number" == n || "symbol" != n && l.test(t)) && t > -1 && t % 1 == 0 && t < e
    }

    function gt(t) {
      var e = t && t.constructor;
      return t === ("function" == typeof e && e.prototype || T)
    }

    function yt(t, e) {
      if (("constructor" !== e || "function" != typeof t[e]) && "__proto__" != e) return t[e]
    }

    var _t = function (t) {
      var e = 0, n = 0;
      return function () {
        var r = X(), i = 16 - (r - n);
        if (n = r, i > 0) {
          if (++e >= 800) return arguments[0]
        } else e = 0;
        return t.apply(void 0, arguments)
      }
    }(dt);

    function bt(t, e) {
      return t === e || t != t && e != e
    }

    var xt = ct(function () {
      return arguments
    }()) ? ct : function (t) {
      return Ht(t) && A.call(t, "callee") && !B.call(t, "callee")
    }, wt = Array.isArray;

    function St(t) {
      return null != t && Tt(t.length) && !Et(t)
    }

    var Mt = V || function () {
      return !1
    };

    function Et(t) {
      if (!Ot(t)) return !1;
      var e = at(t);
      return e == s || "[object GeneratorFunction]" == e || "[object AsyncFunction]" == e || "[object Proxy]" == e
    }

    function Tt(t) {
      return "number" == typeof t && t > -1 && t % 1 == 0 && t <= i
    }

    function Ot(t) {
      var e = typeof t;
      return null != t && ("object" == e || "function" == e)
    }

    function Ht(t) {
      return null != t && "object" == typeof t
    }

    var At = _ ? function (t) {
      return function (e) {
        return t(e)
      }
    }(_) : function (t) {
      return Ht(t) && Tt(t.length) && !!u[at(t)]
    };

    function Pt(t) {
      return St(t) ? tt(t, !0) : ut(t)
    }

    var Rt, Lt = (Rt = function (t, e, n, r) {
      ht(t, e, n, r)
    }, ft((function (t, e) {
      var n = -1, r = e.length, i = r > 1 ? e[r - 1] : void 0, o = r > 2 ? e[2] : void 0;
      for (i = Rt.length > 3 && "function" == typeof i ? (r--, i) : void 0, o && function (t, e, n) {
        if (!Ot(n)) return !1;
        var r = typeof e;
        return !!("number" == r ? St(n) && vt(e, n.length) : "string" == r && e in n) && bt(n[e], t)
      }(e[0], e[1], o) && (i = r < 3 ? void 0 : i, r = 1), t = Object(t); ++n < r;) {
        var s = e[n];
        s && Rt(t, s, n, i)
      }
      return t
    })));

    function Ct(t) {
      return t
    }

    n.exports = Lt
  }).call(this, n(98), n(100)(t))
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = s(n(23)), o = s(n(125));

  function s(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function a(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function c(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function l(t, e, n) {
    return l = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = d(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, l(t, e, n || t)
  }

  function u(t, e) {
    return u = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, u(t, e)
  }

  function h(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = d(t);
      if (e) {
        var i = d(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return f(this, n)
    }
  }

  function f(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function d(t) {
    return d = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, d(t)
  }

  var p = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && u(t, e)
    }(s, t);
    var e, n, r, i = h(s);

    function s() {
      return a(this, s), i.apply(this, arguments)
    }

    return e = s, (n = [{
      key: "_extra", value: function () {
        l(d(s.prototype), "_extra", this).call(this), this._size = [0, 0], this._sizePrev = [0, 0], this._desktop = !1, this._tablet = !1, this._mobile = !1, this._mobiledevice = !1, this._types = ["desktop", "tablet", "mobile"]
      }
    }, {
      key: "size", get: function () {
        return this._size
      }
    }, {
      key: "desktop", get: function () {
        return this._desktop
      }
    }, {
      key: "tablet", get: function () {
        return this._tablet
      }
    }, {
      key: "mobile", get: function () {
        return this._mobile
      }
    }, {
      key: "dpr", get: function () {
        return void 0 !== window.devicePixelRatio ? window.devicePixelRatio : 1
      }
    }, {
      key: "dprMobile", get: function () {
        return this.mobiledevice ? this.dpr : 1
      }
    }, {
      key: "mobiledevice", get: function () {
        return this._mobiledevice
      }
    }, {
      key: "landscape", get: function () {
        return this.size[0] > this.size[1]
      }
    }, {
      key: "portrait", get: function () {
        return this.size[0] < this.size[1]
      }
    }, {
      key: "_setEvents", value: function () {
        window.addEventListener("resize", this._implement.bind(this)), this._set()
      }
    }, {
      key: "_implement", value: function () {
        var t = this._sizePrev.slice();
        this._set();
        var e = {
          size: this.size,
          dpr: this.dpr,
          desktop: this.desktop,
          tablet: this.tablet,
          mobile: this.mobile,
          mobiledevice: this.mobiledevice,
          landscape: this.landscape
        }, n = this._size, r = n[0], i = n[1];
        r !== t[0] & i === t[1] && this.lbt("w", e), i !== t[1] & r === t[0] && this.lbt("h", e), r !== t[0] & i !== t[1] && (this.lbt("wh", e), this.lbt("hw", e)), r !== t[0] && this.lbt("w_", e), i !== t[1] && this.lbt("h_", e), this.lbt("", e)
      }
    }, {
      key: "_set", value: function () {
        var t = this._v.html;
        this._size = [t.clientWidth, t.clientHeight], this._sizePrev = this._size.slice();
        var e = (0, o.default)();
        this._mobiledevice = e.tablet || e.phone, this._classes(), this._breakpoints()
      }
    }, {
      key: "_classes", value: function () {
        var t = this._size[0], e = this._v.prop, n = this._v.html, r = this._v.prefix, i = "desktop", o = this._types;
        switch (t <= e.tablet && (i = t > e.mobile ? "tablet" : "mobile"), i) {
          case"desktop":
            this._classesBreakpoint("desktop", o);
            break;
          case"tablet":
            this._classesBreakpoint("tablet", o);
            break;
          case"mobile":
            this._classesBreakpoint("mobile", o)
        }
        var s = ["landscape", "portrait"];
        this.landscape ? this._classesBreakpoint("landscape", s) : this.portrait ? this._classesBreakpoint("portrait", s) : this._classesBreakpoint("", s);
        var a = r + "mobile-device";
        this.mobiledevice ? n.classList.add(a) : n.classList.remove(a)
      }
    }, {
      key: "_classesBreakpoint", value: function (t, e) {
        var n = this._v.html, r = this._v.prefix;
        e.forEach((function (e) {
          e === t ? n.classList.add(r + e) : n.classList.remove(r + e)
        }))
      }
    }, {
      key: "_breakpoints", value: function () {
        var t = this._size[0], e = this._v.prop, n = this._types;
        t > e.tablet ? this._breakpointsSet("desktop", n) : t > e.mobile ? this._breakpointsSet("tablet", n) : this._breakpointsSet("mobile", n)
      }
    }, {
      key: "_breakpointsSet", value: function (t, e) {
        var n = this;
        e.forEach((function (e) {
          e === t ? n["_" + t] = !0 : n["_" + e] = !1
        }))
      }
    }]) && c(e.prototype, n), r && c(e, r), s
  }(i.default);
  e.default = p
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  var i;

  function o(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function s(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function a(t, e) {
    return a = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, a(t, e)
  }

  function c(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = u(t);
      if (e) {
        var i = u(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return l(this, n)
    }
  }

  function l(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function u(t) {
    return u = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, u(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var h = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && a(t, e)
    }(l, t);
    var e, n, r, i = c(l);

    function l() {
      return o(this, l), i.apply(this, arguments)
    }

    return e = l, (n = [{
      key: "_getAbsoluteURL", value: function (t) {
        return /^https?:\/\//i.test(t) || (t = 0 === t.indexOf("/") ? window.location.origin + t : window.location.origin + "/" + t), t
      }
    }, {
      key: "getParam", value: function (t) {
        var e = {url: window.location.href}, n = t = Object.assign(e, t), r = n.key, i = n.url;
        i = this._getAbsoluteURL(i), r = r.replace(/[[\]]/g, "\\$&");
        var o = new RegExp("[?&]" + r + "(=([^&#]*)|&|#|$)").exec(i);
        if (!o) return null;
        if (!o[2]) return "";
        var s = decodeURIComponent(o[2].replace(/\+/g, " "));
        return this.lbt("getParam", {key: r, url: i, value: s}), s
      }
    }, {
      key: "setParam", value: function (t) {
        var e = {push: !0, url: window.location.href}, n = t = Object.assign(e, t), r = n.key, i = n.value, o = n.push,
          s = n.url;
        s = this._getAbsoluteURL(s), r = encodeURI(r), i = encodeURI(i);
        for (var a, c = null, l = "" === (c = s.length > 0 ? new URL(s) : window.location).search.substr(1) ? [] : c.search.substr(1).split("&"), u = l.length; u--;) if ((a = l[u].split("="))[0] == r) {
          a[1] = i, l[u] = a.join("=");
          break
        }
        u < 0 && (l[l.length] = [r, i].join("="));
        var h = c.pathname + "?" + l.join("&");
        0 === i.length && (h = (h = (h = (h = h.replace("?" + r + "=&", "?")).replace("?" + r + "=", "")).replace("&" + r + "=", "")).replace(r + "=", "")), o && window.history.pushState(null, "", h);
        var f = c.origin + h;
        return this.lbt("setParam", {key: r, value: i, push: o, url: s, newUrl: f}), f
      }
    }]) && s(e.prototype, n), r && s(e, r), l
  }(((i = n(23)) && i.__esModule ? i : {default: i}).default);
  e.default = h
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = s(n(23)), o = s(n(17));

  function s(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function a(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function c(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function l(t, e) {
    return l = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, l(t, e)
  }

  function u(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = f(t);
      if (e) {
        var i = f(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return h(this, n)
    }
  }

  function h(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function f(t) {
    return f = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, f(t)
  }

  var d = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && l(t, e)
    }(s, t);
    var e, n, r, i = u(s);

    function s() {
      return a(this, s), i.apply(this, arguments)
    }

    return e = s, (n = [{
      key: "_extra", value: function () {
        this._cache = []
      }
    }, {
      key: "cache", get: function () {
        return this._cache
      }
    }, {
      key: "load", value: function (t) {
        var e = {
          method: "post",
          url: window.location.href,
          responseType: "",
          data: {},
          cache: !1,
          async: !0,
          before: function () {
          },
          success: function () {
          },
          abort: function () {
          },
          error: function () {
          }
        };
        if ((e = Object.assign(e, t)).method = e.method.toUpperCase(), e.cache) {
          var n = this._cacheCheck({url: e.url, method: e.method, data: e.data});
          if (n) return void e.success(n)
        }
        this.lbt("load", e), this._xhr(e)
      }
    }, {
      key: "_xhr", value: function (t) {
        var e = this, n = !1, r = t.url, i = t.data, s = !0;
        if ("POST" == t.method) {
          n = !0;
          var a = [];
          for (var c in i) a.push(c + "=" + encodeURIComponent(i[c]));
          i = a.join("&")
        } else if ("GET" == t.method) for (var l in i) r = this._v.url.setParam({
          key: l,
          value: i[l],
          push: !1,
          url: r
        });
        var u = new XMLHttpRequest;
        u.open(t.method, r, t.async), "POST" == t.method && u.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), t.before(u), "" !== t.responseType && (u.responseType = t.responseType), u.onreadystatechange = function () {
          if (4 === u.readyState) {
            var n = {url: t.url, method: t.method, data: t.data, xhr: u};
            200 === u.status ? (t.cache && e._cacheSet(n), t.success(n)) : t.error(n), s = !1, e.lbt("loaded", n)
          }
        }, u.send(n ? i : null), (0, o.default)((function () {
          s && (u.onreadystatechange = null, u.abort(), t.abort())
        }), this._vp.ajaxTimeMax)
      }
    }, {
      key: "_cacheCheck", value: function (t) {
        for (var e = !1, n = 0; n < this._cache.length; n++) {
          var r = this._cache[n];
          if (t.url == r.url && t.method == r.method) {
            var i = Object.keys(t.data).length, o = 0;
            for (var s in r.data) for (var a in t.data) s == a & r.data[s] == t.data[a] && o++;
            o == i && (e = r)
          }
        }
        return e
      }
    }, {
      key: "_cacheSet", value: function (t) {
        this._cache.push(t)
      }
    }, {
      key: "cacheClear", value: function () {
        this._cache = []
      }
    }]) && c(e.prototype, n), r && c(e, r), s
  }(i.default);
  e.default = d
}, function (t, e) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var n = function () {
    var t = !!window.opr && !!window.opr.addons || !!window.opera || navigator.userAgent.indexOf(" OPR/") >= 0,
      e = "undefined" != typeof InstallTrigger,
      n = /constructor/i.test(window.HTMLElement) || "[object SafariRemoteNotification]" === (!window.safari || window.safari.pushNotification).toString(),
      r = !!document.documentMode, i = !r && !!window.StyleMedia,
      o = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
    return t ? "opera" : e ? "firefox" : n ? "safari" : r ? "ie" : i ? "edge" : o ? "chrome" : "unknown"
  };
  e.default = n
}, function (t, e) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var n = function () {
    return -1 !== navigator.userAgent.indexOf("Windows") ? "windows" : -1 !== navigator.userAgent.indexOf("Linux") ? "linux" : -1 !== navigator.userAgent.indexOf("Mac") ? "macos" : -1 !== navigator.userAgent.indexOf("FreeBSD") ? "freebsd" : "unknown"
  };
  e.default = n
}, function (t, e, n) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var r = o(n(72)), i = o(n(6));

  function o(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function s(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function a(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  var c = function () {
    function t() {
      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function () {
        }, o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function () {
        };
      s(this, t), e = (0, r.default)(e), this._v = e.v, this._onchange = n, this._onresponsive = o, this._propInit = e, this._propRef = (0, i.default)({}, e), this._prop = (0, i.default)({}, e), this._viewportID = !1, this._initResponsive()
    }

    var e, n, o;
    return e = t, n = [{
      key: "prop", get: function () {
        return this._prop
      }
    }, {
      key: "changeProp", value: function (t) {
        this._prop = (0, i.default)(this._prop, t), this._propRef = (0, i.default)(this._propRef, t), this._onchange()
      }
    }, {
      key: "_initResponsive", value: function () {
        void 0 !== this._propInit.responsive && (this._propertiesResponse(), this._viewportID = this._v.viewport.add({
          target: "w_",
          name: "Responsive properties",
          do: this._propertiesResponse.bind(this, !0)
        }))
      }
    }, {
      key: "_propertiesResponse", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], e = this._propInit.responsive;
        if (e) {
          var n = this._v.viewport, r = n.size[0], o = {}, s = !1;
          e.forEach((function (t) {
            var e = t.settings, a = t.breakpoint;
            "number" == typeof a ? r <= t.breakpoint && (o = (0, i.default)(o, e), s = !0) : "string" == typeof a && ("d" === (a = a.toLowerCase()) & n.desktop && (o = (0, i.default)(o, e), s = !0), "t" === a & n.tablet && (o = (0, i.default)(o, e), s = !0), "m" === a & n.mobile && (o = (0, i.default)(o, e), s = !0), "md" === a & n.mobiledevice && (o = (0, i.default)(o, e), s = !0))
          })), this._prop = s ? (0, i.default)(this._prop, o) : (0, i.default)(this._prop, this._propRef), t && this._onresponsive()
        }
      }
    }, {
      key: "destroy", value: function () {
        this._viewportID && this._v.viewport.remove(this._viewportID)
      }
    }], n && a(e.prototype, n), o && a(e, o), t
  }();
  e.default = c
}, function (t, e, n) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var r, i = (r = n(63)) && r.__esModule ? r : {default: r};
  var o = function (t) {
    var e = "vevet-event", n = t.el, r = t.target, o = t.do;
    void 0 === n[e] && (n[e] = {});
    var s = (0, i.default)("".concat(e, "__").concat(r, "__"));
    return void 0 !== t.passive ? t.passive ? n.addEventListener(r, o, {passive: !0}) : n.addEventListener(r, o, {passive: !1}) : n.addEventListener(r, o, !1), n[e][s] = {
      target: r,
      do: o
    }, {id: s, el: n, target: r, do: o}
  };
  e.default = o
}, function (t, e, n) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var r, i = (r = n(114)) && r.__esModule ? r : {default: r};
  var o = function (t) {
    var e = (0, i.default)(t);
    e.el.removeEventListener(e.target, e.do, !1), delete e.el["vevet-event"][t.id]
  };
  e.default = o
}, function (t, e) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var n = function (t) {
    var e = "vevet-event", n = t.el, r = t.id;
    return void 0 !== n[e] && (void 0 !== n[e][r] && {id: r, el: n, target: n[e][r].target, do: n[e][r].do})
  };
  e.default = n
}, function (t, e, n) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var r = c(n(75)), i = c(n(47)), o = c(n(39)), s = c(n(56)), a = c(n(40));

  function c(t) {
    return t && t.__esModule ? t : {default: t}
  }

  var l = function (t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return t instanceof NodeList ? t : (0, o.default)(t) ? (0, r.default)(t) : (0, i.default)(t) ? [t] : "string" == typeof t ? e ? (e = (0, s.default)(e), (0, a.default)(e) ? e.querySelectorAll(t) : []) : document.querySelectorAll(t) : []
  };
  e.default = l
}, function (t, e, n) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var r = o(n(56)), i = o(n(40));

  function o(t) {
    return t && t.__esModule ? t : {default: t}
  }

  var s = function (t) {
    return t = (0, r.default)(t), !!(0, i.default)(t)
  };
  e.default = s
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = s(n(15)), o = s(n(6));

  function s(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function a(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function c(t, e, n) {
    return c = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = f(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, c(t, e, n || t)
  }

  function l(t, e) {
    return l = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, l(t, e)
  }

  function u(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = f(t);
      if (e) {
        var i = f(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return h(this, n)
    }
  }

  function h(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function f(t) {
    return f = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, f(t)
  }

  var d = n(25), p = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && l(t, e)
    }(h, t);
    var e, n, r, s = u(h);

    function h(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, h), s.call(this, t)
    }

    return e = h, n = [{
      key: "prefix", get: function () {
        return "".concat(this._v.prefix, "scrollAnimate")
      }
    }, {
      key: "defaultProp", get: function () {
        var t = this._prefix;
        return (0, o.default)(c(f(h.prototype), "defaultProp", this), {
          selectors: {
            outer: ".".concat(t),
            elements: ".".concat(t, "__el"),
            inside: !0
          }, on: !0, resize: !0, resizeTimeout: 0, event: !0, seekInit: !0, horizontal: !1
        })
      }
    }, {
      key: "outer", get: function () {
        return this._outer
      }
    }, {
      key: "elements", get: function () {
        return this._el
      }
    }, {
      key: "_extra", value: function () {
        c(f(h.prototype), "_extra", this).call(this), this._scrollModuleCallback = !1, this._vevetScroll = !1, this._size = 0, this._scrollValue = 0, this._bounding = !1, this._elGet()
      }
    }, {
      key: "_init", value: function () {
        c(f(h.prototype), "_init", this).call(this), this._prop.seekInit && this.seek()
      }
    }, {
      key: "_changeProp", value: function () {
        c(f(h.prototype), "_changeProp", this).call(this), this._removeScrollListeners(), this._elGet(), this.setSize()
      }
    }, {
      key: "_removeScrollListeners", value: function () {
        this.removeEventListeners(), this._scrollModuleCallback && this._vevetScroll.remove(this._scrollModuleCallback)
      }
    }, {
      key: "_elGet", value: function () {
        var t = !1, e = this._prop, n = e.selectors, r = n.outer;
        if (r instanceof i.default) this._vevetScroll = r, this._outer = r.outer, t = !0; else {
          var o = d.one(r);
          this._vevetScroll = o, this._outer = o
        }
        var s = n.elements;
        n.inside ? this._el = this._outer.querySelectorAll(s) : this._el = d.all(s), this._scrollModuleCallback = !1, e.event && (t ? this._scrollModuleCallback = this._vevetScroll.add({
          target: "update",
          do: this.seek.bind(this, null)
        }) : this.listener(this._outer, "scroll", this.seek.bind(this, null)))
      }
    }, {
      key: "_setEvents", value: function () {
        var t = this;
        c(f(h.prototype), "_setEvents", this).call(this);
        var e = this._prop;
        this.setSize(), this.addEvent("viewport", {
          target: "", name: this.name, do: function () {
            setTimeout((function () {
              t.setSize(), e.resize & e.on && t.seek()
            }), e.resizeTimeout)
          }
        })
      }
    }, {
      key: "setSize", value: function () {
        var t = this._prop, e = this._outer;
        if (e instanceof Window) {
          var n = this._v.viewport.size;
          this._size = t.horizontal ? n[0] : n[1], this._bounding = {top: 0, left: 0, bottom: n[1], right: n[0]}
        } else this._size = t.horizontal ? e.clientWidth : e.clientHeight, this._bounding = e.getBoundingClientRect();
        this._setScrollValue(null)
      }
    }, {
      key: "_setScrollValue", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e = this._prop.horizontal;
        this._outer instanceof Window ? this._scrollValue = e ? window.pageXOffset : window.pageYOffset : this._scrollValue = null != t ? t : e ? this._vevetScroll.scrollLeft : this._vevetScroll.scrollTop
      }
    }, {
      key: "seek", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
        return !!this._prop.on && (this._setScrollValue(t), !0)
      }
    }, {
      key: "destroy", value: function () {
        c(f(h.prototype), "destroy", this).call(this), this._scrollModuleCallback && this._vevetScroll.remove(this._scrollModuleCallback)
      }
    }], n && a(e.prototype, n), r && a(e, r), h
  }(i.default);
  e.default = p
}, function (t, e, n) {
  "use strict";

  function r(t) {
    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, r(t)
  }

  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var i = a(n(15)), o = a(n(6)), s = a(n(17));

  function a(t) {
    return t && t.__esModule ? t : {default: t}
  }

  function c(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function l(t, e, n) {
    return l = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = d(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, l(t, e, n || t)
  }

  function u(t, e) {
    return u = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, u(t, e)
  }

  function h(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = d(t);
      if (e) {
        var i = d(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return f(this, n)
    }
  }

  function f(t, e) {
    return !e || "object" !== r(e) && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t) : e
  }

  function d(t) {
    return d = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, d(t)
  }

  var p = n(25), m = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && u(t, e)
    }(a, t);
    var e, n, r, i = h(a);

    function a(t) {
      return function (t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
      }(this, a), i.call(this, t)
    }

    return e = a, (n = [{
      key: "prefix", get: function () {
        return "".concat(this._v.prefix, "menu")
      }
    }, {
      key: "defaultProp", get: function () {
        return (0, o.default)(l(d(a.prototype), "defaultProp", this), {
          events: !0,
          selectors: {outer: ".".concat(this._prefix), button: ".".concat(this._prefix, "-button")},
          delays: {show: 0, hide: 0}
        })
      }
    }, {
      key: "shown", get: function () {
        return this._shown
      }
    }, {
      key: "_extra", value: function () {
        l(d(a.prototype), "_extra", this).call(this), this._shown = !1, this._getElements()
      }
    }, {
      key: "_getElements", value: function () {
        var t = this._prop.selectors;
        this._outer = p.one(t.outer), this._button = p.one(t.button)
      }
    }, {
      key: "_setEvents", value: function () {
        l(d(a.prototype), "_setEvents", this).call(this), this._button && this.listener(this._button, "click", this._buttonClick.bind(this))
      }
    }, {
      key: "_buttonClick", value: function (t) {
        this._prop.events && (t.preventDefault(), this.toggle())
      }
    }, {
      key: "show", value: function () {
        return !this._shown && this.toggle()
      }
    }, {
      key: "hide", value: function () {
        return !!this._shown && this.toggle()
      }
    }, {
      key: "toggle", value: function () {
        var t = this._prop.delays;
        return this._shown ? (0, s.default)(this._hide.bind(this), t.hide) : (0, s.default)(this._show.bind(this), t.show), !0
      }
    }, {
      key: "_show", value: function () {
        this.lbt("show"), this._shown = !0
      }
    }, {
      key: "_hide", value: function () {
        this.lbt("hide"), this._shown = !1
      }
    }]) && c(e.prototype, n), r && c(e, r), a
  }(i.default);
  e.default = m
}, function (t, e, n) {
  "use strict";
  n.r(e), e.default = "#define GLSLIFY 1\nvarying vec4 vUv;\nvarying vec3 pos;\n\nuniform vec3 color;\nuniform sampler2D tDiffuse;\nuniform float u_alpha;\n\nvoid main() {\n    \n    vec4 base = texture2DProj( tDiffuse, vUv );\n    base = blur_texture2DProj(tDiffuse, vUv);\n\n    vec4 reflectionColor = base;\n\n    // fade\n    float fadeAlpha = 1.0;\n    float edge = 0.5;\n    if (pos.y < edge) {\n        fadeAlpha = 1.0 - (edge - pos.y) / edge;\n    }\n    reflectionColor.a *= fadeAlpha * 0.5 * u_alpha;\n\n    gl_FragColor = reflectionColor;\n    \n}"
}, function (t, e, n) {
  "use strict";
  n.r(e), e.default = "#define GLSLIFY 1\nuniform mat4 textureMatrix;\nvarying vec4 vUv;\nvarying vec3 pos;\nuniform float u_size;\nvoid main() {\n    vUv = textureMatrix * vec4( position, 1.0 );\n    pos = (position / u_size) + 0.5;\n    pos.y -= 0.025;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"
}, function (t, e) {
  "use strict";
  Object.defineProperty(e, "__esModule", {value: !0}), e.default = void 0;
  var n = function (t, e) {
    var n = e.parentNode, r = e.nextSibling;
    r ? n.insertBefore(t, r) : n.appendChild(t)
  };
  e.default = n
}, function (t) {
  "use strict";
  t.exports = function (t, e) {
    var n, r;
    if (n = "letter" === e ? this._el.letters : "word" === e ? this._el.words : this._el.lines, r = "letter" === e ? t.letter : "word" === e ? t.word : t.line, n = n.slice(), t.reverse && n.reverse(), t.shuffle && n.sort((function () {
      return Math.random() - .5
    })), t.center) {
      var i = [], o = Math.ceil(n.length / 2) - 1, s = [], a = (i = n.length % 2 == 0 ? [o, o + 1] : [o])[0], c = i[0];
      1 === i.length ? s.push(n[i[0]]) : (s.push([n[i[0]], n[i[1]]]), c = i[1]);
      for (var l = (n.length - i.length) / 2, u = 1; u <= l; u++) {
        var h = [];
        h.push(n[c + u]), h.push(n[a - u]), s.push(h)
      }
      n = s
    }
    return this._animationInfo(Object.assign(t, {el: n, styles: r, type: e}))
  }
}, function (t) {
  "use strict";

  function e(t, e, n) {
    var r = [];
    if ("lineletter" == e.type) if (n.appendWords) for (var i = 0; i < t.children.length; i++) for (var o = t.children[i], s = 0; s < o.children.length; s++) {
      var a = o.children[s];
      r.push(a)
    } else r = t.children; else "lineword" != e.type && "wordletter" != e.type || (r = t.children);
    var c = r.length, l = r.slice();
    return l = l.slice(), e.reverse && l.reverse(), e.shuffle && l.sort((function () {
      return Math.random() - .5
    })), {amount: c, el: l}
  }

  t.exports = function (t, n) {
    var r, i;
    "lineletter" === n || "wordletter" === n ? r = t.letter : "lineword" === n && (r = t.word), "lineletter" === n || "lineword" === n ? i = this._el.lines.slice() : "wordletter" === n && (i = this._el.words.slice()), t.reverseComposite && i.reverse(), t.shuffle && i.sort((function () {
      return Math.random() - .5
    }));
    var o = function (t, n) {
      var r = function (t) {
        var e = t.parents.length, n = t.parents.slice();
        return {amount: e, el: n}
      }(t), i = t.duration, o = [];
      if (t.durationAuto) {
        for (var s = 0, a = 0, c = [], l = [], u = 0; u < r.amount; u++) {
          var h = e(r.el[u], t, n), f = h.amount * t.durationElement - (h.amount - 1) * t.shift * t.durationElement;
          s += f, u > 0 && (a += f * t.shiftLine), c.push(f), l.push(h)
        }
        i = s - a;
        for (var d = 0; d < r.amount; d++) {
          for (var p = 0, m = 0; m < d; m++) p += c[m] - c[m] * t.shiftLine;
          for (var v = 0; v < l[d].amount; v++) {
            var g = p + t.durationElement * (1 - t.shift) * v, y = g + t.durationElement;
            o.push({start: g / i, end: y / i, el: l[d].el[v]})
          }
        }
      } else for (var _ = 1 / (r.amount - t.shiftLine * (r.amount - 1)), b = 0; b < r.amount; b++) for (var x = _ * (1 - t.shiftLine) * b, w = e(r.el[b], t, n), S = _ / (w.amount - t.shift * (w.amount - 1)), M = 0; M < w.amount; M++) {
        var E = x + S * (1 - t.shift) * M, T = E + S;
        o.push({start: E, end: T, el: w.el[M]})
      }
      return {duration: i, timelines: o, styles: t.styles}
    }(Object.assign(t, {styles: r, type: n, parents: i}), this._prop);
    return o
  }
}, function (t, e, n) {
  "use strict";
  n.r(e);
  n(102);
  var r = n(0), i = n(11), o = n(13);

  function s(t, e) {
    return function (t) {
      if (Array.isArray(t)) return t
    }(t) || function (t, e) {
      var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
      if (null == n) return;
      var r, i, o = [], s = !0, a = !1;
      try {
        for (n = n.call(t); !(s = (r = n.next()).done) && (o.push(r.value), !e || o.length !== e); s = !0) ;
      } catch (c) {
        a = !0, i = c
      } finally {
        try {
          s || null == n.return || n.return()
        } finally {
          if (a) throw i
        }
      }
      return o
    }(t, e) || function (t, e) {
      if (!t) return;
      if ("string" == typeof t) return a(t, e);
      var n = Object.prototype.toString.call(t).slice(8, -1);
      "Object" === n && t.constructor && (n = t.constructor.name);
      if ("Map" === n || "Set" === n) return Array.from(t);
      if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return a(t, e)
    }(t, e) || function () {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }()
  }

  function a(t, e) {
    (null == e || e > t.length) && (e = t.length);
    for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
    return r
  }

  !function () {
    var t = 16;

    function e() {
      var t = function () {
        if (!r.a || !i.g) return 1;
        var t = r.a.viewport, e = t.desktop, n = t.tablet, a = t.mobile, c = t.landscape, l = s(t.size, 2), u = l[0],
          h = l[1];
        if (e) return u < 1440 ? u / 1440 : u >= 1440 && u <= 1920 ? 1 : u / 1920;
        if (n) return u / 1024;
        if (a) {
          if (c) return 1;
          if (u > 750) return u / 500;
          if (!(u > h)) return u < 350 ? u / 350 : 1;
          if (u >= 360 && u <= 400) return 1;
          if (u < 360) return Object(o.b)(u / 360, [.9375, 1 / 0]);
          if (u > 400) return u / u
        }
        return 1
      }(), e = Math.round(16 * t);
      return Object(o.b)(e, [13, 27])
    }

    function n() {
      if (r.a) {
        var n = e();
        n !== t && (r.a.html.style.fontSize = "".concat(n, "px"), r.a.html.style.setProperty("--font-size", "".concat(n, "px"))), t = n
      }
    }

    n(), r.a && r.a.viewport.on("w_", (function () {
      n()
    }), {name: "Adaptive Font Size"})
  }();
  var c = r.a.viewport;

  function l() {
    var t = c.size;
    r.a.html.style.setProperty("--vw", "".concat(t[0] / 100, "px")), r.a.html.style.setProperty("--vh", "".concat(t[1] / 100, "px"))
  }

  l(), r.a.load.add({do: l.bind(void 0)}), c.add({target: "", do: l.bind(void 0), name: "CSS Vars"});
  n(62);
  var u = n(7);
  var h = n(1), f = n(65);

  function d() {
    Object(h.f)(f.a.tagName).length > 0 && Promise.all([n.e(2), n.e(3), n.e(5)]).then(n.bind(null, 221))
  }

  function p() {
    Object(h.f)("project-preview").length > 0 && n.e(0).then(n.bind(null, 215))
  }

  var m = n(3);

  function v(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function g(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function y(t, e, n) {
    return y = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = w(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, y(t, e, n || t)
  }

  function _(t, e) {
    return _ = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, _(t, e)
  }

  function b(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = w(t);
      if (e) {
        var i = w(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return x(this, n)
    }
  }

  function x(t, e) {
    if (e && ("object" === S(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function w(t) {
    return w = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, w(t)
  }

  function S(t) {
    return S = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, S(t)
  }

  var M = function (t, e, n, r) {
    var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
    if ("object" === ("undefined" == typeof Reflect ? "undefined" : S(Reflect)) && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--) (i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s);
    return o > 3 && s && Object.defineProperty(e, n, s), s
  }, E = "project-previews-grid", T = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && _(t, e)
    }(o, t);
    var e, n, r, i = b(o);

    function o() {
      return v(this, o), i.apply(this, arguments)
    }

    return e = o, (n = [{
      key: "createRenderRoot", value: function () {
        return this
      }
    }, {
      key: "firstUpdated", value: function () {
        this.classList.add(E)
      }
    }, {
      key: "connectedCallback", value: function () {
        y(w(o.prototype), "connectedCallback", this).call(this);
        for (var t = this.children, e = -1, n = 0; n < t.length; n++) ++e >= 4 && (e = 0);
        this.classList.add("".concat(E, "_").concat(e))
      }
    }]) && g(e.prototype, n), r && g(e, r), o
  }(m.a), O = (T = M([Object(m.b)(E)], T), n(29));

  function H() {
    Object(h.f)(O.b.tagName).length > 0 && n.e(1).then(n.bind(null, 216))
  }

  var A = n(92), P = n.n(A), R = n(20), L = n(26), C = n(9), k = n(18), D = n(37);

  function N(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function z(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function j(t, e, n) {
    return j = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = U(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, j(t, e, n || t)
  }

  function I(t, e) {
    return I = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, I(t, e)
  }

  function B(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = U(t);
      if (e) {
        var i = U(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return F(this, n)
    }
  }

  function F(t, e) {
    if (e && ("object" === G(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function U(t) {
    return U = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, U(t)
  }

  function G(t) {
    return G = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, G(t)
  }

  var V = function (t, e, n, r) {
    var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
    if ("object" === ("undefined" == typeof Reflect ? "undefined" : G(Reflect)) && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--) (i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s);
    return o > 3 && s && Object.defineProperty(e, n, s), s
  }, W = "lazy-img", X = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && I(t, e)
    }(o, t);
    var e, n, r, i = B(o);

    function o() {
      return N(this, o), i.apply(this, arguments)
    }

    return e = o, (n = [{
      key: "createRenderRoot", value: function () {
        return this
      }
    }, {
      key: "connectedCallback", value: function () {
        j(U(o.prototype), "connectedCallback", this).call(this), this.classList.add(W);
        for (var t = this.children, e = 0; e < t.length; e++) {
          var n = t[e];
          n instanceof HTMLImageElement && n.classList.add("lazy-image")
        }
      }
    }]) && z(e.prototype, n), r && z(e, r), o
  }(m.a), q = (X = V([Object(m.b)(W)], X), r.a.viewport);
  var Y = n(28), Z = n(94), J = n.n(Z), K = n(6), Q = n.n(K), $ = "data-view-parent";

  function tt() {
    for (var t = Object(h.f)("*[".concat($, "]")), e = 0, n = t.length; e < n; e++) {
      var r = t[e];
      if (r instanceof HTMLElement) {
        var i = r.getAttribute($);
        if (i) for (var o = r.children, s = 0; s < o.length; s++) o[s].classList.add(i)
      }
    }
  }

  var et, nt = n(48), rt = !1, it = function () {
    return {get: ot.bind(this), create: st.bind(this), enable: at.bind(this)}
  }();

  function ot() {
    return rt
  }

  function st() {
    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    tt();
    var e = Object(C.c)(), n = {
      selectors: {
        outer: e instanceof HTMLHtmlElement ? window : e,
        elements: '*[class*="v-view"]:not([data-view-ignore])',
        inside: !1
      },
      on: !1,
      seekInit: !1,
      classToAdd: "v-viewed",
      stackDelay: 75,
      resizeTimeout: i.e,
      edge: 1,
      autostack: {on: !0, delay: 1e3}
    }, o = Q()(n, t), s = new J.a(o);
    return et = nt.a.add((function () {
      s.updateEl(), s.seek()
    })), r.a.vevetPage && r.a.vevetPage.on("destroy", (function () {
      s.destroy(), et && (et.destroy(), et = !1)
    })), r.a.vevetPage && r.a.vevetPage.addEvent("viewport", {
      target: "w_", do: function () {
        var t = Object(C.c)();
        s.changeProp({selectors: {outer: t instanceof HTMLHtmlElement ? window : t}})
      }, name: "Scroll View", timeout: 50
    }), rt = s, s
  }

  function at() {
    var t = ot();
    t && (t.changeProp({on: !0}), t.seek())
  }

  var ct = ".js-menu-link";
  var lt = n(22), ut = n.n(lt), ht = n(69), ft = n(16);

  function dt(t) {
    var e = ".js-languages";
    Object(h.f)(e, t).forEach((function (t) {
      u.a.on("done", (function () {
        var n = Object(h.g)(e, u.a.lastData.e);
        Object(h.c)(n) && (t.innerHTML = n.innerHTML)
      }))
    }))
  }

  var pt = n(95), mt = n.n(pt), vt = n(36), gt = n.n(vt), yt = n(96), _t = n.n(yt),
    bt = {duration: 1e3, outerScope: [0, .75], innerScope: [.25, 1], elShift: .85}, xt = "v-menu__translate",
    wt = "v-menu__alpha", St = "v-menu__rotate", Mt = function () {
      var t = Object(h.g)("#menu");
      if (!Object(h.c)(t)) return !1;
      var e = Object(h.g)(".v-menu__bg", t);
      if (!Object(h.c)(e)) return !1;
      dt(t);
      var n, i = Object(h.f)(".js-menu-close-button"), o = new mt.a({
        selectors: {button: ".not-existing-element", outer: t},
        timeline: {duration: bt.duration, outerScope: bt.outerScope, innerScope: bt.innerScope, easing: "linear"}
      });
      return (n = new gt.a({easing: [.25, .1, .25, 1]})).on("progress", (function (t) {
        e.style.transform = "scale(1, ".concat(t.se, ")")
      })), o.on("progressOuter", (function (t) {
        n.imitate(t.p)
      })), function () {
        for (var t = Object(h.f)("\n            .".concat(xt, ",\n            .").concat(St, ",\n            .").concat(wt, "\n        ")), e = _t()(t.length, bt.elShift), n = new gt.a({easing: "linear"}), r = function (r) {
          var i = new gt.a({line: e[r], easing: [.25, .1, .25, 1]});
          i.on("progress", (function (e) {
            var n = t[r];
            n.classList.contains(St) ? n.children[0].style.transform = "\n                        translate3d(0, ".concat(-130 * (1 - e.se), "%, 0)\n                        rotate(").concat(-10 * (1 - e.se), "deg)\n                    ") : n.classList.contains(wt) ? n.style.opacity = e.se.toString() : n.classList.contains(xt) && (n.style.transform = "\n                        translate3d(0, ".concat(2 * (1 - e.se), "rem, 0)\n                    "), n.style.opacity = e.se.toString())
          })), n.addTimeline(i)
        }, i = 0; i < e.length; i++) r(i);
        o.on("progressInner", (function (t) {
          n.imitate(t.p)
        }))
      }(), i.forEach((function (t) {
        t.addEventListener("click", (function () {
          o.hide()
        }))
      })), o.on("show", (function () {
        r.a.html.classList.add("prevent-scroll-under-popup-menu")
      })), o.on("hide", (function () {
        r.a.html.classList.remove("prevent-scroll-under-popup-menu")
      })), u.a.on("prepare", (function () {
        o.shown && o.hide()
      }), {timeout: 50}), window.addEventListener("keydown", (function (t) {
        27 === t.keyCode && o.hide()
      })), o
    }(), Et = Mt;

  function Tt(t) {
    Object(h.f)(".js-menu-button", t).forEach((function (t) {
      t.addEventListener("click", (function () {
        Et && Et.toggle()
      }))
    }))
  }

  var Ot = function () {
    var t = Object(h.g)(".header"), e = t.cloneNode(!0);
    return r.a.load.on("", (function () {
      Object(ht.a)(t)
    })), t.classList.add("header_fixed"), e.classList.add("header_static"), dt(e), dt(t), Tt(t), Tt(e), {
      appendStatic: function () {
        var t, n = Object(C.c)();
        (t = n instanceof ut.a ? Object(h.g)(".custom-scroll__outer", n.outer) : Object(h.g)(".custom-scroll__outer")).insertBefore(e, t.firstChild), u.a.setLinks()
      }.bind(this), hideOnScroll: function () {
        Object(ft.a)((function (t) {
          n(t)
        }));
        var e = 0;

        function n(n) {
          n < .75 * r.a.viewport.size[1] || n > e ? i() : n < e && (r.a.html.classList.add("show-fixed-header"), t.classList.add("show-fixed")), e = n
        }

        function i() {
          r.a.html.classList.remove("show-fixed-header"), t.classList.remove("show-fixed")
        }

        n(0)
      }.bind(this), showFixedHeader: function () {
        t.classList.add("show-fixed_important")
      }.bind(this), hideFixedHeader: function () {
        t.classList.remove("show-fixed_important")
      }.bind(this), fixedHeader: t, staticHeader: e
    }
  }(), Ht = n(34);
  var At = n(66);
  var Pt = n(79);
  var Rt = n(70);
  var Lt = n(64);
  var Ct = n(80);

  function kt(t) {
    return "Minified Redux error #" + t + "; visit https://redux.js.org/Errors?code=" + t + " for the full message or use the non-minified dev environment for full errors. "
  }

  var Dt, Nt = "function" == typeof Symbol && Symbol.observable || "@@observable", zt = function () {
    return Math.random().toString(36).substring(7).split("").join(".")
  }, jt = {
    INIT: "@@redux/INIT" + zt(), REPLACE: "@@redux/REPLACE" + zt(), PROBE_UNKNOWN_ACTION: function () {
      return "@@redux/PROBE_UNKNOWN_ACTION" + zt()
    }
  };

  function It(t) {
    if ("object" != typeof t || null === t) return !1;
    for (var e = t; null !== Object.getPrototypeOf(e);) e = Object.getPrototypeOf(e);
    return Object.getPrototypeOf(t) === e
  }

  function Bt(t, e, n) {
    var r;
    if ("function" == typeof e && "function" == typeof n || "function" == typeof n && "function" == typeof arguments[3]) throw new Error(kt(0));
    if ("function" == typeof e && void 0 === n && (n = e, e = void 0), void 0 !== n) {
      if ("function" != typeof n) throw new Error(kt(1));
      return n(Bt)(t, e)
    }
    if ("function" != typeof t) throw new Error(kt(2));
    var i = t, o = e, s = [], a = s, c = !1;

    function l() {
      a === s && (a = s.slice())
    }

    function u() {
      if (c) throw new Error(kt(3));
      return o
    }

    function h(t) {
      if ("function" != typeof t) throw new Error(kt(4));
      if (c) throw new Error(kt(5));
      var e = !0;
      return l(), a.push(t), function () {
        if (e) {
          if (c) throw new Error(kt(6));
          e = !1, l();
          var n = a.indexOf(t);
          a.splice(n, 1), s = null
        }
      }
    }

    function f(t) {
      if (!It(t)) throw new Error(kt(7));
      if (void 0 === t.type) throw new Error(kt(8));
      if (c) throw new Error(kt(9));
      try {
        c = !0, o = i(o, t)
      } finally {
        c = !1
      }
      for (var e = s = a, n = 0; n < e.length; n++) {
        (0, e[n])()
      }
      return t
    }

    function d(t) {
      if ("function" != typeof t) throw new Error(kt(10));
      i = t, f({type: jt.REPLACE})
    }

    function p() {
      var t, e = h;
      return (t = {
        subscribe: function (t) {
          if ("object" != typeof t || null === t) throw new Error(kt(11));

          function n() {
            t.next && t.next(u())
          }

          return n(), {unsubscribe: e(n)}
        }
      })[Nt] = function () {
        return this
      }, t
    }

    return f({type: jt.INIT}), (r = {dispatch: f, subscribe: h, getState: u, replaceReducer: d})[Nt] = p, r
  }

  (function (t) {
    t.enable = "enable", t.disable = "disable"
  })(Dt || (Dt = {}));
  var Ft = Bt((function () {
    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {value: {enabled: !1}},
      e = arguments.length > 1 ? arguments[1] : void 0;
    switch (e.type) {
      case Dt.enable:
        return t.value.enabled = !0, t;
      case Dt.disable:
        return t.value.enabled = !1, t;
      default:
        return t
    }
  }));

  function Ut() {
    Object(h.f)("splash-bg").forEach((function (t) {
      t.bg && t.bg.splat()
    }))
  }

  var Gt = n(24), Vt = n(52);

  function Wt(t) {
    return Wt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Wt(t)
  }

  function Xt(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function qt(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function Yt(t, e, n) {
    return Yt = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Qt(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, Yt(t, e, n || t)
  }

  function Zt(t, e) {
    return Zt = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, Zt(t, e)
  }

  function Jt(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = Qt(t);
      if (e) {
        var i = Qt(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return Kt(this, n)
    }
  }

  function Kt(t, e) {
    if (e && ("object" === Wt(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function Qt(t) {
    return Qt = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, Qt(t)
  }

  Promise.all([n.e(8), n.e(9)]).then(n.bind(null, 220));
  var $t = function (t) {
      !function (t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
        t.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: t,
            writable: !0,
            configurable: !0
          }
        }), e && Zt(t, e)
      }(c, t);
      var e, o, s, a = Jt(c);

      function c() {
        var t;
        return Xt(this, c), (t = a.apply(this, arguments))._pageCreated = !1, t
      }

      return e = c, o = [{
        key: "pageCreated", get: function () {
          return this._pageCreated
        }
      }, {
        key: "lazyImages", get: function () {
          return this._lazyImages
        }
      }, {
        key: "create", value: function () {
          var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return this._pageCreated = !1, !!Yt(Qt(c.prototype), "create", this).call(this, t) && (Y.a.create(), it.create(), Ot.staticHeader.classList.add("no-transition"), Ot.appendStatic(), Ot.hideOnScroll(), this._loadModules(), u.a.changeProp({on: !1}), this._pageCreated = !0, this)
        }
      }, {
        key: "show", value: function () {
          var t = this;
          return !!this.showCheck() && (this._handleCanBeShown().then((function () {
            Yt(Qt(c.prototype), "show", t).call(t), t._showPage()
          })), !0)
        }
      }, {
        key: "_handleCanBeShown", value: function () {
          var t = this;
          return new Promise((function (e) {
            Object(Gt.a)(!0), 1 === Object(Vt.a)("data-preload-in-page") ? (Object(Gt.a)(!1), e()) : setTimeout((function () {
              t._handleCanBeShown().then((function () {
                e()
              }))
            }), 50)
          }))
        }
      }, {
        key: "_showPage", value: function () {
          Object(Gt.a)(!1), Y.a.playAndSetClasses(), it.enable();
          var t = function () {
            var t, e, n = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], o = !1, s = r.a.vevetPage;
            if (!s) return !1;
            var a = "data-lazy-image-proceeded", c = !1, l = !1, u = !1, f = !1, d = [], p = "load", m = "loaded";

            function v() {
              o || (y(), t = g(), e = Object(k.a)(t) ? t.outer : t, w(), s && s.onPageShown(M.bind(this)), Object(D.b)() ? (f = new IntersectionObserver(E.bind(this), {
                root: null,
                rootMargin: "0px",
                threshold: .01
              }), S()) : (Object(k.a)(t) ? u = t.on("update", T.bind(this)) : s && (l = s.listener(t, "scroll", T.bind(this), {})), T()))
            }

            function g() {
              return n || Object(C.c)()
            }

            function y() {
              c = q.add({target: "w_", do: b.bind(this, !0), timeout: i.e, name: "LAZY IMAGE"})
            }

            function _() {
              "boolean" != typeof c && (q.remove(c), c = !1)
            }

            function b() {
              var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
              l && s && (s.removeEventListener({
                el: l.el,
                id: l.id
              }), l = !1), Object(k.a)(t) && "string" == typeof u && (t.remove(u), u = !1), f && (f.disconnect(), f = !1), d.forEach((function (t) {
                t.removeAttribute(a)
              })), _(), e && v()
            }

            function x() {
              o = !0, _(), b(!1)
            }

            function w() {
              d = [];
              for (var t = Object(h.f)(".lazy-image, .lazy-bg", e), n = 0, r = t.length; n < r; n++) {
                var i = t[n];
                i instanceof HTMLElement && null == i.getAttribute(a) && (d.push(i), i.setAttribute(a, "true"))
              }
            }

            function S() {
              if (f instanceof IntersectionObserver) for (var t = 0; t < d.length; t++) f.observe(d[t])
            }

            function M() {
              for (var t = Object(h.f)(".lazy-image-instant, .lazy-bg-instant", e), n = 0, r = t.length; n < r; n++) {
                var i = t[n];
                i instanceof HTMLElement && (i.classList.contains(p) || (i.classList.add(p), H(i)))
              }
            }

            function E(t) {
              t.forEach((function (t) {
                if (t.isIntersecting) {
                  var e = t.target;
                  e instanceof HTMLElement && O(e)
                }
              }))
            }

            function T() {
              for (var t = R.a.app.clientHeight, e = 0; e < d.length; e++) {
                var n = d[e];
                n.getBoundingClientRect().top <= t && O(n)
              }
            }

            function O(t) {
              t.classList.contains(p) || (t.classList.add(p), t.style.willChange = "opacity", H(t))
            }

            function H(t) {
              var e = t.getAttribute("data-src");
              if (e) Object(L.a)(e, (function () {
                t instanceof HTMLImageElement ? t.src = e : t.style.backgroundImage = "url('".concat(e, "')"), A(t)
              })); else if (t instanceof HTMLImageElement) {
                var n = t.getAttribute("data-srcset");
                n && (t.addEventListener("load", (function () {
                  A(t)
                })), t.setAttribute("srcset", n))
              }
            }

            function A(t) {
              setTimeout((function () {
                t.classList.add(m), setTimeout((function () {
                  t.style.willChange = ""
                }), 250)
              }), 50)
            }

            return v(), {set: v.bind(this), destroy: x.bind(this), reset: b.bind(this)}
          }();
          this._lazyImages = t, this.on("destroy", (function () {
            t && t.destroy()
          })), this._throughAjax && u.a.updateMenuLinks({
            selectorOld: ct,
            selectorNew: ct
          }), this._throughAjax && Object(h.f)("page-ajax-loading").forEach((function (t) {
            t.hide(i.a)
          })), Ht.b && (Ht.b.updateElements(), Ht.b.play()), Ft.dispatch({type: Dt.enable}), u.a.changeProp({on: !0})
        }
      }, {
        key: "hide", value: function () {
          return !!Yt(Qt(c.prototype), "hide", this).call(this) && (Y.a.pause(), Ht.b && Ht.b.pause(), !0)
        }
      }, {
        key: "_loadModules", value: function () {
          Object(h.f)("scroll-list").length > 0 && n.e(0).then(n.bind(null, 229)), Object(h.f)("gl-model").length > 0 && Promise.all([n.e(2), n.e(3), n.e(4)]).then(n.bind(null, 227)), Object(h.f)(At.b).length > 0 && n.e(0).then(n.bind(null, 214)), Object(h.f)(Rt.a.tagName).length > 0 && n.e(0).then(n.bind(null, 228)), Object(h.f)(Pt.a.tagName).length > 0 && n.e(0).then(n.bind(null, 222)), Object(h.f)(".".concat(Lt.c.tagName)).length > 0 && Promise.all([n.e(10), n.e(1)]).then(n.bind(null, 223)), Object(Ct.a)()
        }
      }], o && qt(e.prototype, o), s && qt(e, s), c
    }(P.a), te = (new $t({name: "default-page"}), n(38)), ee = n(2), ne = n(8), re = n.n(ne), ie = n(42), oe = n.n(ie),
    se = n(81), ae = n(12), ce = n(59), le = n(83), ue = n(87), he = n(31), fe = n(67), de = n(68), pe = n(5),
    me = "\n    data:image/png;base64,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\n",
    ve = n(4), ge = {
      tagName: "showreel-video",
      camera: {far: 2e3},
      rotate: {ease: .1, x: 0, y: .1 * Math.PI},
      appear: {start: 0, end: 1, zScale: 2, yRotate: .5 * -Math.PI},
      marquee: {zRotate: -.1569},
      elements: {appearStart: .9},
      imageMarqueeRenderSettings: {paddingXRatio: 0, parallaxFriction: .128, alpha: 1, speed: -2, rotationY: .4168},
      reflection: {appearStart: .7}
    }, ye = ge;
  if (ve.b) {
    var _e = ve.b.addFolder(ge.tagName), be = ge.rotate, xe = ge.appear, we = ge.marquee, Se = ge.elements,
      Me = _e.addFolder("rotate");
    Me.add(be, "ease", ve.a, .2, ve.a), Me.add(be, "x", -Math.PI / 4, Math.PI / 4, ve.a), Me.add(be, "y", -Math.PI / 4, Math.PI / 4, ve.a);
    var Ee = _e.addFolder("appear");
    Ee.add(xe, "start", 0, 1, ve.a), Ee.add(xe, "end", 0, 1.25, ve.a), Ee.add(xe, "zScale", 0, 2, ve.a), Ee.add(xe, "yRotate", -Math.PI / 2, Math.PI / 2, ve.a), _e.addFolder("marquee").add(we, "zRotate", -Math.PI / 2, Math.PI / 2, ve.a), _e.addFolder("elements").add(Se, "appearStart", .5, 1, ve.a)
  }
  var Te = !1;
  var Oe = n(45), He = n(58);

  function Ae(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function Pe(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function Re(t, e, n) {
    return Re = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = De(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, Re(t, e, n || t)
  }

  function Le(t, e) {
    return Le = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, Le(t, e)
  }

  function Ce(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = De(t);
      if (e) {
        var i = De(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return ke(this, n)
    }
  }

  function ke(t, e) {
    if (e && ("object" === Ne(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function De(t) {
    return De = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, De(t)
  }

  function Ne(t) {
    return Ne = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Ne(t)
  }

  var ze = function (t, e, n, r) {
      var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
      if ("object" === ("undefined" == typeof Reflect ? "undefined" : Ne(Reflect)) && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--) (i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s);
      return o > 3 && s && Object.defineProperty(e, n, s), s
    }, je = n(119).default, Ie = n(120).default, Be = n(101).default, Fe = ye.tagName, Ue = ye.camera, Ge = ye.reflection,
    Ve = !r.a.viewport.mobile, We = 100, Xe = function (t) {
      !function (t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
        t.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: t,
            writable: !0,
            configurable: !0
          }
        }), e && Le(t, e)
      }(a, t);
      var e, n, i, s = Ce(a);

      function a() {
        var t;
        return Ae(this, a), (t = s.apply(this, arguments))._videoOuter = !1, t._playOuter = !1, t._video = !1, t._image = !1, t._videoPlane = !1, t._listeners = [], t._threeEvents = [], t._loadProgress = 0, t._onScene = !1, t._globalProgress = 0, t._appearProgress = 0, t._appearProgressEl = 0, t._appearProgressMirror = 0, t._disappearProgress = 0, t._targetMouse = {
          x: 0,
          y: 0
        }, t._currentMouse = {x: 0, y: 0}, t
      }

      return e = a, (n = [{
        key: "loadProgress", get: function () {
          return this._loadProgress
        }
      }, {
        key: "_connectedCallback", value: function () {
          var t = this;
          Re(De(a.prototype), "_connectedCallback", this).call(this), this._loadProgress = 0, this._onPreloaderReady = Object(Oe.a)((function () {
            t._disconnected || t._createElements()
          }))
        }
      }, {
        key: "_disconnectedCallback", value: function () {
          Re(De(a.prototype), "_disconnectedCallback", this).call(this), this._loadProgress = 0, this._onPreloaderReady && (this._onPreloaderReady.destroy(), this._onPreloaderReady = !1), this._destroy()
        }
      }, {
        key: "_createElements", value: function () {
          var t = this;
          this._videoOuter || (this._videoOuter = Object(h.b)("div", {
            class: "".concat(Fe, "__outer"),
            parent: this
          })), this._marqueeOuter || (this._marqueeOuter = Object(h.b)("div", {
            class: "".concat(Fe, "__marquee"),
            parent: this._videoOuter
          }));
          var e, n = Object(h.g)("*[data-play]", this);
          n && !this._playOuter && (this._playOuter = Object(h.b)("div", {
            class: "".concat(Fe, "-play"),
            children: [n]
          }), this._playOuter.addEventListener("wheel", (function (t) {
            var e = Object(C.c)();
            if (e instanceof ut.a) {
              var n = oe()(t);
              e.targetTop += n.pixelY
            }
          }))), this.videoSrc && Ve ? (e = this.videoSrc, new Promise((function (t) {
            if (Te) t(Te); else {
              (Te = document.createElement("video")).disablePictureInPicture = !0, Te.setAttribute("preload", "auto"), Te.crossOrigin = "anonymous", Te.autoplay = !1, Te.controls = !1, Te.playsInline = !0, Te.muted = !0, Te.loop = !0, Te.setAttribute("muted", "muted");
              var n = document.createElement("source");
              n.setAttribute("src", "".concat(e, "#t=0.1")), Te.appendChild(n), Te.addEventListener("loadedmetadata", (function () {
                if (Te) {
                  try {
                    Te.play()
                  } catch (e) {
                  }
                  t(Te)
                }
              })), Te.load()
            }
          }))).then((function (e) {
            t._video = e, t._disconnected || t._createGL(e)
          })) : this.imageSrc && Object(L.a)(this.imageSrc, (function (e) {
            t._image = e, t._createGL(e)
          }))
        }
      }, {
        key: "_createGL", value: function (t) {
          if (!this._disconnected) {
            this._renderTarget = new de.a({el: !1, autoRender: !1, cameraSettings: Ue, dpr: Object(He.a)()});
            var e = this._renderTarget.scene;
            this._renderTargetPlane = new he.a({
              el: !1,
              scene: !1,
              texture: this._renderTarget.renderer.texture,
              materialProp: {transparent: !0, opacity: 0},
              zIndex: -2,
              renderPosition: !1
            }), this._group = new ee.s, e.add(this._group), this._videoPlane = new fe.a({
              el: this._videoOuter,
              resource: t,
              scene: this._group,
              posRule: "cover",
              renderPosition: !1,
              zIndex: -2
            }), this._marquee = Object(ue.a)({
              parent: this._marqueeOuter,
              data: [me, me, me, me, me, me, me],
              intersectionEl: this._marqueeOuter,
              renderPosition: !1,
              heightRatio: .2494,
              settings: ye.imageMarqueeRenderSettings,
              scene: this._group
            }), this._createMirror(), this._setEvents(), this._loadProgress = 1
          }
        }
      }, {
        key: "_createMirror", value: function () {
          var t = new ee.Q(We, We, 1, 1), e = new se.a(t, {clipBias: .003, textureWidth: We, textureHeight: We});
          this._mirror = e, e.getRenderTarget().texture.format = ee.U;
          var n = e.material;
          n.onBeforeCompile = function (t) {
            n.userData = t.uniforms, t.uniforms.u_alpha = {value: 0}, t.uniforms.u_size = {value: We}, t.vertexShader = Ie, t.fragmentShader = Be + je
          }, e.rotation.x = .5 * -Math.PI, e.position.z = 0, this._group && this._group.add(e)
        }
      }, {
        key: "_destroy", value: function () {
          if (this._playOuter) {
            for (; this._playOuter.children.length > 0;) this.appendChild(this._playOuter.children[0]);
            this._playOuter.remove(), this._playOuter = !1
          }
          this._threeEvents.forEach((function (t) {
            pe.a.remove(t)
          })), this._threeEvents = [], this._listeners.forEach((function (t) {
            t.remove()
          })), this._listeners = [], this._mirror && (this._group && this._group.remove(this._mirror), this._renderTarget && this._renderTarget.scene.remove(this._mirror), this._mirror = !1), this._videoPlane && (this._videoPlane.destroy(), this._videoPlane = !1), this._renderTargetPlane && (this._renderTargetPlane.destroy(), this._renderTargetPlane = !1), this._renderTarget && (this._renderTarget.destroy(), this._renderTarget = !1), this._marquee && (this._marquee.destroy(), this._marquee = !1)
        }
      }, {
        key: "_setEvents", value: function () {
          var t = this;
          this._threeEvents.push(pe.a.on("prerender", (function () {
            t._render()
          }))), this._updateSizes(), this._threeEvents.push(pe.a.on("resize", (function () {
            t._updateSizes()
          }))), this._listeners.push(Object(h.a)(window, "mousemove", this._handleMouseMove.bind(this))), Object(le.a)((function (e) {
            t._handleDeviceOrientation(e)
          })).then((function (e) {
            t._listeners.push(e)
          }))
        }
      }, {
        key: "_handleMouseMove", value: function (t) {
          r.a.viewport.mobiledevice || (this._targetMouse.x = re()(t.clientX, [r.a.viewport.size[0] / 2, r.a.viewport.size[0]]), this._targetMouse.y = re()(t.clientY, [r.a.viewport.size[1] / 2, r.a.viewport.size[1]]))
        }
      }, {
        key: "_handleDeviceOrientation", value: function (t) {
          if (r.a.viewport.mobiledevice) {
            var e = Object(ce.b)(t);
            this._targetMouse.x = 1.25 * e;
            var n = Object(ce.a)(t);
            this._targetMouse.y = 1.25 * n
          }
        }
      }, {
        key: "_updateSizes", value: function () {
          if (this._videoOuter) {
            var t = this._videoOuter.getBoundingClientRect();
            this._videoBounding = t;
            var e = 5;
            if (this._renderTarget && (e *= Object(He.a)()), this._mirror) {
              var n = pe.a.width, i = r.a.viewport.portrait ? 2 : 1;
              this._mirror.scale.x = n / We * i;
              var o = Ue.far / 2;
              this._mirror.scale.y = o / We, this._mirror.position.z = 0, this._mirror.position.y = -t.height / 2 - e, this._mirror.getRenderTarget().setSize(n, o)
            }
          }
        }
      }, {
        key: "_render", value: function () {
          var t = this._renderTarget;
          if (t) {
            this._bounding = this.getBoundingClientRect();
            var e = this._bounding, n = pe.a.height;
            if (this._globalProgress = re()(this._bounding.top, [r.a.viewport.size[1], -1 * e.height]), this._globalProgress < 0 || this._globalProgress > 1) this._removeFromScene(); else {
              this._addToScene();
              var i = ye.appear, s = Object(o.b)(re()(e.top, [n - n * i.start, n - n * i.end]));
              this._appearProgress = s;
              var a = ye.elements;
              this._appearProgressEl = Object(o.b)(re()(this._appearProgress, [a.appearStart, 1])), this._appearProgressMirror = Object(o.b)(re()(this._appearProgress, [Ge.appearStart, 1])), this._disappearProgress = Object(o.b)(1 - re()(e.top, [-1 * e.height, 0]));
              var c = this._targetMouse, l = this._currentMouse, u = ye.rotate.ease;
              if (l.x = Object(o.a)(l.x, c.x, u), l.y = Object(o.a)(l.y, c.y, u), this._renderGroup(), this._renderMarquee(), this._renderPlay(), this._mirror) {
                var h = this._mirror.material;
                h.userData && h.userData.u_alpha && (h.userData.u_alpha.value = this._appearProgressMirror)
              }
              t.render()
            }
          }
        }
      }, {
        key: "_renderGroup", value: function () {
          var t = this._bounding, e = this._group, n = this._renderTargetPlane;
          if (n) {
            var r = ye.appear, i = n.mesh, o = n.material, s = this._currentMouse, a = ye.rotate,
              c = {x: s.y * a.x, y: s.x * a.y}, l = Object(te.b)(1 - this._appearProgress, te.a.easeOutQuad) * r.yRotate,
              u = Object(te.b)(this._appearProgress, te.a.easeOutSine);
            e.rotation.x = c.x, e.rotation.y = c.y + l, e.position.z = 0 - Ue.far * r.zScale * (1 - u), i.position.y = t.top * this._disappearProgress * -1, o.opacity = u
          }
        }
      }, {
        key: "_renderMarquee", value: function () {
          var t = this, e = this._marquee;
          if (e) {
            var n = ye.marquee, i = e.getGroup();
            if (i) {
              var s = Object(o.b)(re()(this._bounding.top, [r.a.viewport.size[1] / 2, -1 * (this._bounding.height - r.a.viewport.size[1] / 2)])),
                a = re()(s, [.5, 1]);
              i.position.y = a * (this._videoBounding.height / 2), i.rotation.z = a * n.zRotate
            }
            e.getElements().forEach((function (e) {
              var n = e.plane;
              if (n) {
                var r = n.mesh;
                if (r) {
                  var i = r.material;
                  i && (i.opacity = t._appearProgressEl)
                }
              }
            }))
          }
        }
      }, {
        key: "_renderPlay", value: function () {
          var t = this._playOuter, e = this._bounding;
          if (t) {
            var n = e.top * this._disappearProgress;
            t.style.transform = "translate3d(0, ".concat(n, "px, 0)"), t.style.opacity = "".concat(this._appearProgressEl), 0 === this._appearProgressEl ? t.style.pointerEvents = "none" : t.style.pointerEvents = ""
          }
        }
      }, {
        key: "_addToScene", value: function () {
          var t = this._renderTargetPlane;
          if (t && !this._onScene) {
            if (pe.a.scene3d.add(t.mesh), this._onScene = !0, this._video) try {
              this._video.play()
            } catch (e) {
            }
            this._playOuter && R.a.page.appendChild(this._playOuter)
          }
        }
      }, {
        key: "_removeFromScene", value: function () {
          var t = this._renderTargetPlane;
          t && this._onScene && (pe.a.scene3d.remove(t.mesh), this._onScene = !1, this._playOuter && this._playOuter.remove())
        }
      }]) && Pe(e.prototype, n), i && Pe(e, i), a
    }(ae.a);
  ze([Object(m.c)({attribute: "video-src"})], Xe.prototype, "videoSrc", void 0), ze([Object(m.c)({attribute: "image-src"})], Xe.prototype, "imageSrc", void 0);
  Xe = ze([Object(m.b)(Fe)], Xe);

  function qe(t) {
    return qe = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, qe(t)
  }

  function Ye(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function Ze(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function Je(t, e, n) {
    return Je = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = tn(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, Je(t, e, n || t)
  }

  function Ke(t, e) {
    return Ke = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, Ke(t, e)
  }

  function Qe(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = tn(t);
      if (e) {
        var i = tn(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return $e(this, n)
    }
  }

  function $e(t, e) {
    if (e && ("object" === qe(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function tn(t) {
    return tn = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, tn(t)
  }

  var en = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && Ke(t, e)
    }(o, t);
    var e, n, r, i = Qe(o);

    function o() {
      return Ye(this, o), i.apply(this, arguments)
    }

    return e = o, n = [{
      key: "create", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return !!Je(tn(o.prototype), "create", this).call(this, t) && (d(), H(), p(), this)
      }
    }], n && Ze(e.prototype, n), r && Ze(e, r), o
  }($t), nn = (new en({name: "home-page"}), n(71));

  function rn() {
    var t = nn.a.tagName;
    Object(h.f)(t).length > 0 && n.e(1).then(n.bind(null, 226))
  }

  function on() {
    Object(h.f)("project-image-scene").length > 0 && n.e(5).then(n.bind(null, 224))
  }

  function sn() {
    Object(h.f)("project-link").length > 0 && n.e(4).then(n.bind(null, 217))
  }

  function an(t) {
    return an = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, an(t)
  }

  function cn(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function ln(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function un(t, e, n) {
    return un = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = pn(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, un(t, e, n || t)
  }

  function hn(t, e) {
    return hn = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, hn(t, e)
  }

  function fn(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = pn(t);
      if (e) {
        var i = pn(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return dn(this, n)
    }
  }

  function dn(t, e) {
    if (e && ("object" === an(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function pn(t) {
    return pn = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, pn(t)
  }

  var mn = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && hn(t, e)
    }(o, t);
    var e, n, r, i = fn(o);

    function o() {
      return cn(this, o), i.apply(this, arguments)
    }

    return e = o, n = [{
      key: "create", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return !!un(pn(o.prototype), "create", this).call(this, t) && (on(), sn(), rn(), this)
      }
    }], n && ln(e.prototype, n), r && ln(e, r), o
  }($t);
  new mn({name: "project-page"});

  function vn(t, e) {
    t.style.gridRowStart = e.toString()
  }

  function gn(t, e) {
    t.style.gridRowEnd = e.toString()
  }

  function yn(t, e) {
    t.style.gridColumnStart = e.toString()
  }

  function _n(t, e) {
    t.style.gridColumnEnd = e.toString()
  }

  function bn(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function xn(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function wn(t, e, n) {
    return wn = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Tn(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, wn(t, e, n || t)
  }

  function Sn(t, e) {
    return Sn = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, Sn(t, e)
  }

  function Mn(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = Tn(t);
      if (e) {
        var i = Tn(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return En(this, n)
    }
  }

  function En(t, e) {
    if (e && ("object" === On(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function Tn(t) {
    return Tn = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, Tn(t)
  }

  function On(t) {
    return On = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, On(t)
  }

  var Hn = function (t, e, n, r) {
    var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
    if ("object" === ("undefined" == typeof Reflect ? "undefined" : On(Reflect)) && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--) (i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s);
    return o > 3 && s && Object.defineProperty(e, n, s), s
  }, An = "project-previews-ladder-grid", Pn = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && Sn(t, e)
    }(s, t);
    var e, n, i, o = Mn(s);

    function s() {
      var t;
      return bn(this, s), (t = o.apply(this, arguments))._viewportEvents = [], t
    }

    return e = s, (n = [{
      key: "createRenderRoot", value: function () {
        return this
      }
    }, {
      key: "firstUpdated", value: function () {
        this.classList.add(An)
      }
    }, {
      key: "connectedCallback", value: function () {
        var t = this;
        wn(Tn(s.prototype), "connectedCallback", this).call(this), this.align(), this._viewportEvents.push(r.a.viewport.on("w_", (function () {
          t.align()
        }), {name: An}))
      }
    }, {
      key: "disconnectedCallback", value: function () {
        wn(Tn(s.prototype), "disconnectedCallback", this).call(this), this._viewportEvents.forEach((function (t) {
          r.a.viewport.remove(t)
        }))
      }
    }, {
      key: "align", value: function () {
        var t = 0, e = 0;

        function n(t) {
          return e + t
        }

        for (var i = this.children, o = 0, s = i.length; o < s; o++) {
          var a = i[o], c = o - 8 * t + 1;
          r.a.viewport.mobile ? (a.style.gridColumn = "", vn(a, ""), gn(a, ""), yn(a, ""), _n(a, "")) : ([1, 5].includes(c) && (a.style.gridColumn = "span 2"), 1 === c ? (vn(a, n(1)), gn(a, n(62))) : 2 === c ? (vn(a, n(41)), gn(a, n(91)), yn(a, 3)) : 3 === c ? (vn(a, n(70)), gn(a, n(120)), yn(a, 2)) : 4 === c ? (vn(a, n(100)), gn(a, n(150)), yn(a, 1)) : 5 === c ? (vn(a, n(129)), gn(a, n(190)), yn(a, 2), _n(a, 4)) : 6 === c ? (vn(a, n(169)), gn(a, n(219)), yn(a, 1)) : 7 === c ? (vn(a, n(199)), gn(a, n(249)), yn(a, 2)) : 8 === c && (vn(a, n(228)), gn(a, n(278)), yn(a, 3)), 8 === c && (t++, e += 258))
        }
      }
    }]) && xn(e.prototype, n), i && xn(e, i), s
  }(m.a);
  Pn = Hn([Object(m.b)(An)], Pn);

  function Rn(t) {
    return Rn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Rn(t)
  }

  function Ln(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function Cn(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function kn(t, e, n) {
    return kn = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = jn(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, kn(t, e, n || t)
  }

  function Dn(t, e) {
    return Dn = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, Dn(t, e)
  }

  function Nn(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = jn(t);
      if (e) {
        var i = jn(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return zn(this, n)
    }
  }

  function zn(t, e) {
    if (e && ("object" === Rn(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function jn(t) {
    return jn = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, jn(t)
  }

  var In = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && Dn(t, e)
    }(o, t);
    var e, n, r, i = Nn(o);

    function o() {
      return Ln(this, o), i.apply(this, arguments)
    }

    return e = o, n = [{
      key: "create", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return !!kn(jn(o.prototype), "create", this).call(this, t) && (p(), this)
      }
    }], n && Cn(e.prototype, n), r && Cn(e, r), o
  }($t), Bn = (new In({name: "portfolio-page"}), n(85));

  function Fn() {
    Object(h.f)(Bn.a.tagName).length > 0 && Promise.all([n.e(2), n.e(3), n.e(4)]).then(n.bind(null, 218))
  }

  function Un(t) {
    return Un = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Un(t)
  }

  function Gn(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function Vn(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function Wn(t, e, n) {
    return Wn = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Zn(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, Wn(t, e, n || t)
  }

  function Xn(t, e) {
    return Xn = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, Xn(t, e)
  }

  function qn(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = Zn(t);
      if (e) {
        var i = Zn(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return Yn(this, n)
    }
  }

  function Yn(t, e) {
    if (e && ("object" === Un(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function Zn(t) {
    return Zn = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, Zn(t)
  }

  var Jn = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && Xn(t, e)
    }(o, t);
    var e, n, r, i = qn(o);

    function o() {
      return Gn(this, o), i.apply(this, arguments)
    }

    return e = o, n = [{
      key: "create", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return !!Wn(Zn(o.prototype), "create", this).call(this, t) && (Fn(), this)
      }
    }], n && Vn(e.prototype, n), r && Vn(e, r), o
  }($t);
  new Jn({name: "about-page"});

  function Kn(t) {
    return Kn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Kn(t)
  }

  function Qn(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function $n(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function tr(t, e, n) {
    return tr = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = ir(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, tr(t, e, n || t)
  }

  function er(t, e) {
    return er = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, er(t, e)
  }

  function nr(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = ir(t);
      if (e) {
        var i = ir(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return rr(this, n)
    }
  }

  function rr(t, e) {
    if (e && ("object" === Kn(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function ir(t) {
    return ir = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, ir(t)
  }

  var or = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && er(t, e)
    }(o, t);
    var e, n, r, i = nr(o);

    function o() {
      return Qn(this, o), i.apply(this, arguments)
    }

    return e = o, n = [{
      key: "create", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return !!tr(ir(o.prototype), "create", this).call(this, t) && this
      }
    }], n && $n(e.prototype, n), r && $n(e, r), o
  }($t);
  new or({name: "services-page"});

  function sr(t) {
    return sr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, sr(t)
  }

  function ar(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function cr(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function lr(t, e, n) {
    return lr = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var r = function (t, e) {
        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = dr(t));) ;
        return t
      }(t, e);
      if (r) {
        var i = Object.getOwnPropertyDescriptor(r, e);
        return i.get ? i.get.call(n) : i.value
      }
    }, lr(t, e, n || t)
  }

  function ur(t, e) {
    return ur = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, ur(t, e)
  }

  function hr(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = dr(t);
      if (e) {
        var i = dr(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return fr(this, n)
    }
  }

  function fr(t, e) {
    if (e && ("object" === sr(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function dr(t) {
    return dr = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, dr(t)
  }

  var pr = function (t) {
    !function (t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && ur(t, e)
    }(o, t);
    var e, n, r, i = hr(o);

    function o() {
      return ar(this, o), i.apply(this, arguments)
    }

    return e = o, n = [{
      key: "create", value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return !!lr(dr(o.prototype), "create", this).call(this, t) && this
      }
    }], n && cr(e.prototype, n), r && cr(e, r), o
  }($t);
  new pr({name: "contacts-page"});
  !function () {
    for (var t = r.a.page[0], e = !1, n = !1, o = 0; o < r.a.vevetPages.length; o++) {
      var s = r.a.vevetPages[o];
      s.name === t && (e = s), s.name === i.d.default && (n = s)
    }
    if (e) e.create(); else {
      if (!n) throw new Error("Default page doesn't exist!");
      n.create()
    }
  }();
  var mr = n(10), vr = n.n(mr);

  function gr(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function yr(t) {
    t.width = t.clientWidth / 2, t.height = t.clientHeight / 2;
    var e = {
      SIM_RESOLUTION: 128,
      DYE_RESOLUTION: 512,
      DENSITY_DISSIPATION: .97,
      VELOCITY_DISSIPATION: .98,
      PRESSURE_DISSIPATION: .8,
      PRESSURE_ITERATIONS: 10,
      CURL: 5,
      SPLAT_RADIUS: .6,
      SHADING: !0,
      COLORFUL: !0,
      BACK_COLOR: {r: 0, g: 0, b: 0},
      TRANSPARENT: !1,
      BLOOM: !1,
      BLOOM_ITERATIONS: 8,
      BLOOM_RESOLUTION: 256,
      BLOOM_INTENSITY: .8,
      BLOOM_THRESHOLD: .6,
      BLOOM_SOFT_KNEE: .7
    };

    function n() {
      this.id = -1, this.x = 0, this.y = 0, this.dx = 0, this.dy = 0, this.down = !1, this.moved = !1, this.color = [30, 0, 300]
    }

    var i = [], o = [], s = [];
    i.push(new n);
    var a = function (t) {
      var e, n, r = {alpha: !0, depth: !1, stencil: !1, antialias: !1, preserveDrawingBuffer: !1},
        i = t.getContext("webgl2", r), o = !!i;
      o || (i = t.getContext("webgl", r) || t.getContext("experimental-webgl", r));
      o ? (i.getExtension("EXT_color_buffer_float"), n = i.getExtension("OES_texture_float_linear")) : (e = i.getExtension("OES_texture_half_float"), n = i.getExtension("OES_texture_half_float_linear"));
      i.clearColor(0, 0, 0, 1);
      var s, a, c, l = o ? i.HALF_FLOAT : e.HALF_FLOAT_OES;
      o ? (s = u(i, i.RGBA16F, i.RGBA, l), a = u(i, i.RG16F, i.RG, l), c = u(i, i.R16F, i.RED, l)) : (s = u(i, i.RGBA, i.RGBA, l), a = u(i, i.RGBA, i.RGBA, l), c = u(i, i.RGBA, i.RGBA, l));
      return {gl: i, ext: {formatRGBA: s, formatRG: a, formatR: c, halfFloatTexType: l, supportLinearFiltering: n}}
    }(t), c = a.gl, l = a.ext;

    function u(t, e, n, r) {
      if (!function (t, e, n, r) {
        var i = t.createTexture();
        t.bindTexture(t.TEXTURE_2D, i), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texImage2D(t.TEXTURE_2D, 0, e, 4, 4, 0, n, r, null);
        var o = t.createFramebuffer();
        if (t.bindFramebuffer(t.FRAMEBUFFER, o), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, i, 0), t.checkFramebufferStatus(t.FRAMEBUFFER) !== t.FRAMEBUFFER_COMPLETE) return !1;
        return !0
      }(t, e, n, r)) switch (e) {
        case t.R16F:
          return u(t, t.RG16F, t.RG, r);
        case t.RG16F:
          return u(t, t.RGBA16F, t.RGBA, r);
        default:
          return null
      }
      return {internalFormat: e, format: n}
    }

    r.a.viewport.mobiledevice && (e.SHADING = !1), l.supportLinearFiltering || (e.SHADING = !1, e.BLOOM = !1), function () {
      if (!ve.b) return;
      var t = ve.b.addFolder("splash bg");
      t.add(e, "DENSITY_DISSIPATION", 0, 4), t.add(e, "VELOCITY_DISSIPATION", 0, 1), t.add(e, "PRESSURE_DISSIPATION", 0, 1), t.add(e, "CURL", 0, 50).name("vorticity").step(1), t.add(e, "SPLAT_RADIUS", .01, 1), t.add(e, "SHADING"), t.add(e, "COLORFUL"), t.add(e, "BLOOM"), t.add(e, "BLOOM_INTENSITY", .1, 2).name("intensity"), t.add(e, "BLOOM_THRESHOLD", 0, 1).name("threshold")
    }();
    var h = function () {
      function t(e, n) {
        if (function (t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }(this, t), this.uniforms = {}, this.program = c.createProgram(), c.attachShader(this.program, e), c.attachShader(this.program, n), c.linkProgram(this.program), !c.getProgramParameter(this.program, c.LINK_STATUS)) throw c.getProgramInfoLog(this.program);
        for (var r = c.getProgramParameter(this.program, c.ACTIVE_UNIFORMS), i = 0; i < r; i++) {
          var o = c.getActiveUniform(this.program, i).name;
          this.uniforms[o] = c.getUniformLocation(this.program, o)
        }
      }

      var e, n, r;
      return e = t, (n = [{
        key: "bind", value: function () {
          c.useProgram(this.program)
        }
      }]) && gr(e.prototype, n), r && gr(e, r), t
    }();

    function f(t, e) {
      var n = c.createShader(t);
      if (c.shaderSource(n, e), c.compileShader(n), !c.getShaderParameter(n, c.COMPILE_STATUS)) throw c.getShaderInfoLog(n);
      return n
    }

    var d, p, m, v, g, y, _, b, x, w,
      S = f(c.VERTEX_SHADER, "\n    precision highp float;\n    attribute vec2 aPosition;\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform vec2 texelSize;\n    void main () {\n        vUv = aPosition * 0.5 + 0.5;\n        vL = vUv - vec2(texelSize.x, 0.0);\n        vR = vUv + vec2(texelSize.x, 0.0);\n        vT = vUv + vec2(0.0, texelSize.y);\n        vB = vUv - vec2(0.0, texelSize.y);\n        gl_Position = vec4(aPosition, 0.0, 1.0);\n    }\n"),
      M = f(c.FRAGMENT_SHADER, "\n    precision mediump float;\n    precision mediump sampler2D;\n    varying highp vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform float value;\n    void main () {\n        gl_FragColor = value * texture2D(uTexture, vUv);\n    }\n"),
      E = f(c.FRAGMENT_SHADER, "\n    precision mediump float;\n    uniform vec4 color;\n    void main () {\n        gl_FragColor = color;\n    }\n"),
      T = f(c.FRAGMENT_SHADER, "\n    precision highp float;\n    precision highp sampler2D;\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform float aspectRatio;\n    #define SCALE 25.0\n    void main () {\n        vec2 uv = floor(vUv * SCALE * vec2(aspectRatio, 1.0));\n        float v = mod(uv.x + uv.y, 2.0);\n        v = v * 0.1 + 0.8;\n        gl_FragColor = vec4(vec3(v), 1.0);\n    }\n"),
      O = f(c.FRAGMENT_SHADER, "\n    precision highp float;\n    precision highp sampler2D;\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n    void main () {\n        vec3 C = texture2D(uTexture, vUv).rgb;\n        float a = max(C.r, max(C.g, C.b));\n        gl_FragColor = vec4(C, a);\n    }\n"),
      H = f(c.FRAGMENT_SHADER, "\n    precision highp float;\n    precision highp sampler2D;\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform sampler2D uBloom;\n    uniform sampler2D uDithering;\n    uniform vec2 ditherScale;\n    void main () {\n        vec3 C = texture2D(uTexture, vUv).rgb;\n        vec3 bloom = texture2D(uBloom, vUv).rgb;\n        vec3 noise = texture2D(uDithering, vUv * ditherScale).rgb;\n        noise = noise * 2.0 - 1.0;\n        bloom += noise / 800.0;\n        bloom = pow(bloom.rgb, vec3(1.0 / 2.2));\n        C += bloom;\n        float a = max(C.r, max(C.g, C.b));\n        gl_FragColor = vec4(C, a);\n    }\n"),
      A = f(c.FRAGMENT_SHADER, "\n    precision highp float;\n    precision highp sampler2D;\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n    uniform vec2 texelSize;\n    void main () {\n        vec3 L = texture2D(uTexture, vL).rgb;\n        vec3 R = texture2D(uTexture, vR).rgb;\n        vec3 T = texture2D(uTexture, vT).rgb;\n        vec3 B = texture2D(uTexture, vB).rgb;\n        vec3 C = texture2D(uTexture, vUv).rgb;\n        float dx = length(R) - length(L);\n        float dy = length(T) - length(B);\n        vec3 n = normalize(vec3(dx, dy, length(texelSize)));\n        vec3 l = vec3(0.0, 0.0, 1.0);\n        float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\n        C.rgb *= diffuse;\n        float a = max(C.r, max(C.g, C.b));\n        gl_FragColor = vec4(C, a);\n    }\n"),
      P = f(c.FRAGMENT_SHADER, "\n    precision highp float;\n    precision highp sampler2D;\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n    uniform sampler2D uBloom;\n    uniform sampler2D uDithering;\n    uniform vec2 ditherScale;\n    uniform vec2 texelSize;\n    void main () {\n        vec3 L = texture2D(uTexture, vL).rgb;\n        vec3 R = texture2D(uTexture, vR).rgb;\n        vec3 T = texture2D(uTexture, vT).rgb;\n        vec3 B = texture2D(uTexture, vB).rgb;\n        vec3 C = texture2D(uTexture, vUv).rgb;\n        float dx = length(R) - length(L);\n        float dy = length(T) - length(B);\n        vec3 n = normalize(vec3(dx, dy, length(texelSize)));\n        vec3 l = vec3(0.0, 0.0, 1.0);\n        float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\n        C *= diffuse;\n        vec3 bloom = texture2D(uBloom, vUv).rgb;\n        vec3 noise = texture2D(uDithering, vUv * ditherScale).rgb;\n        noise = noise * 2.0 - 1.0;\n        bloom += noise / 800.0;\n        bloom = pow(bloom.rgb, vec3(1.0 / 2.2));\n        C += bloom;\n        float a = max(C.r, max(C.g, C.b));\n        gl_FragColor = vec4(C, a);\n    }\n"),
      R = f(c.FRAGMENT_SHADER, "\n    precision mediump float;\n    precision mediump sampler2D;\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform vec3 curve;\n    uniform float threshold;\n    void main () {\n        vec3 c = texture2D(uTexture, vUv).rgb;\n        float br = max(c.r, max(c.g, c.b));\n        float rq = clamp(br - curve.x, 0.0, curve.y);\n        rq = curve.z * rq * rq;\n        c *= max(rq, br - threshold) / max(br, 0.0001);\n        gl_FragColor = vec4(c, 0.0);\n    }\n"),
      L = f(c.FRAGMENT_SHADER, "\n    precision mediump float;\n    precision mediump sampler2D;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n    void main () {\n        vec4 sum = vec4(0.0);\n        sum += texture2D(uTexture, vL);\n        sum += texture2D(uTexture, vR);\n        sum += texture2D(uTexture, vT);\n        sum += texture2D(uTexture, vB);\n        sum *= 0.25;\n        gl_FragColor = sum;\n    }\n"),
      C = f(c.FRAGMENT_SHADER, "\n    precision mediump float;\n    precision mediump sampler2D;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n    uniform float intensity;\n    void main () {\n        vec4 sum = vec4(0.0);\n        sum += texture2D(uTexture, vL);\n        sum += texture2D(uTexture, vR);\n        sum += texture2D(uTexture, vT);\n        sum += texture2D(uTexture, vB);\n        sum *= 0.25;\n        gl_FragColor = sum * intensity;\n    }\n"),
      k = f(c.FRAGMENT_SHADER, "\n    precision highp float;\n    precision highp sampler2D;\n    varying vec2 vUv;\n    uniform sampler2D uTarget;\n    uniform float aspectRatio;\n    uniform vec3 color;\n    uniform vec2 point;\n    uniform float radius;\n    void main () {\n        vec2 p = vUv - point.xy;\n        p.x *= aspectRatio;\n        vec3 splat = exp(-dot(p, p) / radius) * color;\n        vec3 base = texture2D(uTarget, vUv).xyz;\n        gl_FragColor = vec4(base + splat, 1.0);\n    }\n"),
      D = f(c.FRAGMENT_SHADER, "\n    precision highp float;\n    precision highp sampler2D;\n    varying vec2 vUv;\n    uniform sampler2D uVelocity;\n    uniform sampler2D uSource;\n    uniform vec2 texelSize;\n    uniform vec2 dyeTexelSize;\n    uniform float dt;\n    uniform float dissipation;\n    vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n        vec2 st = uv / tsize - 0.5;\n        vec2 iuv = floor(st);\n        vec2 fuv = fract(st);\n        vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n        vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n        vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n        vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n        return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n    }\n    void main () {\n        vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\n        gl_FragColor = dissipation * bilerp(uSource, coord, dyeTexelSize);\n        gl_FragColor.a = 1.0;\n    }\n"),
      N = f(c.FRAGMENT_SHADER, "\n    precision highp float;\n    precision highp sampler2D;\n    varying vec2 vUv;\n    uniform sampler2D uVelocity;\n    uniform sampler2D uSource;\n    uniform vec2 texelSize;\n    uniform float dt;\n    uniform float dissipation;\n    void main () {\n        vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n        gl_FragColor = dissipation * texture2D(uSource, coord);\n        gl_FragColor.a = 1.0;\n    }\n"),
      z = f(c.FRAGMENT_SHADER, "\n    precision mediump float;\n    precision mediump sampler2D;\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uVelocity;\n    void main () {\n        float L = texture2D(uVelocity, vL).x;\n        float R = texture2D(uVelocity, vR).x;\n        float T = texture2D(uVelocity, vT).y;\n        float B = texture2D(uVelocity, vB).y;\n        vec2 C = texture2D(uVelocity, vUv).xy;\n        if (vL.x < 0.0) { L = -C.x; }\n        if (vR.x > 1.0) { R = -C.x; }\n        if (vT.y > 1.0) { T = -C.y; }\n        if (vB.y < 0.0) { B = -C.y; }\n        float div = 0.5 * (R - L + T - B);\n        gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n    }\n"),
      j = f(c.FRAGMENT_SHADER, "\n    precision mediump float;\n    precision mediump sampler2D;\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uVelocity;\n    void main () {\n        float L = texture2D(uVelocity, vL).y;\n        float R = texture2D(uVelocity, vR).y;\n        float T = texture2D(uVelocity, vT).x;\n        float B = texture2D(uVelocity, vB).x;\n        float vorticity = R - L - T + B;\n        gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\n    }\n"),
      I = f(c.FRAGMENT_SHADER, "\n    precision highp float;\n    precision highp sampler2D;\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uVelocity;\n    uniform sampler2D uCurl;\n    uniform float curl;\n    uniform float dt;\n    void main () {\n        float L = texture2D(uCurl, vL).x;\n        float R = texture2D(uCurl, vR).x;\n        float T = texture2D(uCurl, vT).x;\n        float B = texture2D(uCurl, vB).x;\n        float C = texture2D(uCurl, vUv).x;\n        vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n        force /= length(force) + 0.0001;\n        force *= curl * C;\n        force.y *= -1.0;\n        vec2 vel = texture2D(uVelocity, vUv).xy;\n        gl_FragColor = vec4(vel + force * dt, 0.0, 1.0);\n    }\n"),
      B = f(c.FRAGMENT_SHADER, "\n    precision mediump float;\n    precision mediump sampler2D;\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uPressure;\n    uniform sampler2D uDivergence;\n    vec2 boundary (vec2 uv) {\n        return uv;\n        // uncomment if you use wrap or repeat texture mode\n        // uv = min(max(uv, 0.0), 1.0);\n        // return uv;\n    }\n    void main () {\n        float L = texture2D(uPressure, boundary(vL)).x;\n        float R = texture2D(uPressure, boundary(vR)).x;\n        float T = texture2D(uPressure, boundary(vT)).x;\n        float B = texture2D(uPressure, boundary(vB)).x;\n        float C = texture2D(uPressure, vUv).x;\n        float divergence = texture2D(uDivergence, vUv).x;\n        float pressure = (L + R + B + T - divergence) * 0.25;\n        gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n    }\n"),
      F = f(c.FRAGMENT_SHADER, "\n    precision mediump float;\n    precision mediump sampler2D;\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uPressure;\n    uniform sampler2D uVelocity;\n    vec2 boundary (vec2 uv) {\n        return uv;\n        // uv = min(max(uv, 0.0), 1.0);\n        // return uv;\n    }\n    void main () {\n        float L = texture2D(uPressure, boundary(vL)).x;\n        float R = texture2D(uPressure, boundary(vR)).x;\n        float T = texture2D(uPressure, boundary(vT)).x;\n        float B = texture2D(uPressure, boundary(vB)).x;\n        vec2 velocity = texture2D(uVelocity, vUv).xy;\n        velocity.xy -= vec2(R - L, T - B);\n        gl_FragColor = vec4(velocity, 0.0, 1.0);\n    }\n"),
      U = (c.bindBuffer(c.ARRAY_BUFFER, c.createBuffer()), c.bufferData(c.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), c.STATIC_DRAW), c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, c.createBuffer()), c.bufferData(c.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), c.STATIC_DRAW), c.vertexAttribPointer(0, 2, c.FLOAT, !1, 0, 0), c.enableVertexAttribArray(0), function (t) {
        c.bindFramebuffer(c.FRAMEBUFFER, t), c.drawElements(c.TRIANGLES, 6, c.UNSIGNED_SHORT, 0)
      }), G = function (t) {
        var e = c.createTexture();
        c.bindTexture(c.TEXTURE_2D, e), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.LINEAR), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.LINEAR), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.REPEAT), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.REPEAT), c.texImage2D(c.TEXTURE_2D, 0, c.RGB, 1, 1, 0, c.RGB, c.UNSIGNED_BYTE, new Uint8Array([255, 255, 255]));
        var n = {
          texture: e, width: 1, height: 1, attach: function (t) {
            return c.activeTexture(c.TEXTURE0 + t), c.bindTexture(c.TEXTURE_2D, e), t
          }
        }, r = new Image;
        return r.crossOrigin = "anonymous", r.onload = function () {
          n.width = r.width, n.height = r.height, c.bindTexture(c.TEXTURE_2D, e), c.texImage2D(c.TEXTURE_2D, 0, c.RGB, c.RGB, c.UNSIGNED_BYTE, r)
        }, r.src = t, n
      }("data:image/png;base64,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"),
      V = new h(S, M), W = new h(S, E), X = new h(S, T), q = new h(S, O), Y = new h(S, H), Z = new h(S, A),
      J = new h(S, P), K = new h(S, R), Q = new h(S, L), $ = new h(S, C), tt = new h(S, k),
      et = new h(S, l.supportLinearFiltering ? N : D), nt = new h(S, z), rt = new h(S, j), it = new h(S, I),
      ot = new h(S, B), st = new h(S, F);

    function at() {
      var t = mt(e.SIM_RESOLUTION), n = mt(e.DYE_RESOLUTION);
      d = t.width, p = t.height, m = n.width, v = n.height;
      var r = l.halfFloatTexType, i = l.formatRGBA, o = l.formatRG, a = l.formatR,
        u = l.supportLinearFiltering ? c.LINEAR : c.NEAREST;
      g = null == g ? lt(m, v, i.internalFormat, i.format, r, u) : ut(g, m, v, i.internalFormat, i.format, r, u), y = null == y ? lt(d, p, o.internalFormat, o.format, r, u) : ut(y, d, p, o.internalFormat, o.format, r, u), _ = ct(d, p, a.internalFormat, a.format, r, c.NEAREST), b = ct(d, p, a.internalFormat, a.format, r, c.NEAREST), x = lt(d, p, a.internalFormat, a.format, r, c.NEAREST), function () {
        var t = mt(e.BLOOM_RESOLUTION), n = l.halfFloatTexType, r = l.formatRGBA,
          i = l.supportLinearFiltering ? c.LINEAR : c.NEAREST;
        w = ct(t.width, t.height, r.internalFormat, r.format, n, i), s.length = 0;
        for (var o = 0; o < e.BLOOM_ITERATIONS; o++) {
          var a = t.width >> o + 1, u = t.height >> o + 1;
          if (a < 2 || u < 2) break;
          var h = ct(a, u, r.internalFormat, r.format, n, i);
          s.push(h)
        }
      }()
    }

    function ct(t, e, n, r, i, o) {
      c.activeTexture(c.TEXTURE0);
      var s = c.createTexture();
      c.bindTexture(c.TEXTURE_2D, s), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, o), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, o), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), c.texImage2D(c.TEXTURE_2D, 0, n, t, e, 0, r, i, null);
      var a = c.createFramebuffer();
      return c.bindFramebuffer(c.FRAMEBUFFER, a), c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, s, 0), c.viewport(0, 0, t, e), c.clear(c.COLOR_BUFFER_BIT), {
        texture: s,
        fbo: a,
        width: t,
        height: e,
        attach: function (t) {
          return c.activeTexture(c.TEXTURE0 + t), c.bindTexture(c.TEXTURE_2D, s), t
        }
      }
    }

    function lt(t, e, n, r, i, o) {
      var s = ct(t, e, n, r, i, o), a = ct(t, e, n, r, i, o);
      return {
        get read() {
          return s
        }, set read(t) {
          s = t
        }, get write() {
          return a
        }, set write(t) {
          a = t
        }, swap: function () {
          var t = s;
          s = a, a = t
        }
      }
    }

    function ut(t, e, n, r, i, o, s) {
      return t.read = function (t, e, n, r, i, o, s) {
        var a = ct(e, n, r, i, o, s);
        return V.bind(), c.uniform1i(V.uniforms.uTexture, t.attach(0)), c.uniform1f(V.uniforms.value, 1), U(a.fbo), a
      }(t.read, e, n, r, i, o, s), t.write = ct(e, n, r, i, o, s), t
    }

    at();
    var ht = Date.now(), ft = [1, 1];

    function dt(n, r, i, o, s) {
      c.viewport(0, 0, d, p), tt.bind(), c.uniform1i(tt.uniforms.uTarget, y.read.attach(0)), c.uniform1f(tt.uniforms.aspectRatio, t.width / t.height), c.uniform2f(tt.uniforms.point, n / t.width, 1 - r / t.height), c.uniform3f(tt.uniforms.color, i, -o, 1), c.uniform1f(tt.uniforms.radius, e.SPLAT_RADIUS / 100), U(y.write.fbo), y.swap(), c.viewport(0, 0, m, v), c.uniform1i(tt.uniforms.uTarget, g.read.attach(0)), c.uniform3f(tt.uniforms.color, s.r, s.g, s.b), U(g.write.fbo), g.swap()
    }

    function pt() {
      var t = function (t, e, n) {
        var r, i, o, s, a, c, l, u;
        switch (s = Math.floor(6 * t), c = n * (1 - e), l = n * (1 - (a = 6 * t - s) * e), u = n * (1 - (1 - a) * e), s % 6) {
          case 0:
            r = n, i = u, o = c;
            break;
          case 1:
            r = l, i = n, o = c;
            break;
          case 2:
            r = c, i = n, o = u;
            break;
          case 3:
            r = c, i = l, o = n;
            break;
          case 4:
            r = u, i = c, o = n;
            break;
          case 5:
            r = n, i = c, o = l
        }
        return {r: r, g: i, b: o}
      }(Math.random(), 1, 1);
      return t.r *= .15, t.g *= .15, t.b *= .15, t
    }

    function mt(t) {
      var e = c.drawingBufferWidth / c.drawingBufferHeight;
      e < 1 && (e = 1 / e);
      var n = Math.round(t * e), r = Math.round(t);
      return c.drawingBufferWidth > c.drawingBufferHeight ? {width: n, height: r} : {width: r, height: n}
    }

    function vt(t, e, n) {
      return {x: e / t.width, y: n / t.height}
    }

    return i[0].down = !0, i[0].color = pt(), window.addEventListener("mousemove", (function (t) {
      i[0].moved = i[0].down, i[0].dx = 5 * (t.clientX - i[0].x), i[0].dy = 5 * (t.clientY - i[0].y), i[0].x = t.clientX, i[0].y = t.clientY
    })), window.addEventListener("touchmove", (function (t) {
      for (var e = t.targetTouches, n = 0; n < e.length; n++) {
        var r = i[n];
        r.moved = r.down, r.dx = 8 * (e[n].clientX - r.x), r.dy = 8 * (e[n].clientY - r.y), r.x = e[n].clientX, r.y = e[n].clientY
      }
    }), !1), window.addEventListener("touchstart", (function (t) {
      for (var e = t.targetTouches, r = 0; r < e.length; r++) r >= i.length && i.push(new n), i[r].id = e[r].identifier, i[r].down = !0, i[r].x = e[r].clientX, i[r].y = e[r].clientY, i[r].color = pt()
    })), window.addEventListener("touchend", (function (t) {
      for (var e = t.changedTouches, n = 0; n < e.length; n++) for (var r = 0; r < i.length; r++) e[n].identifier === i[r].id && (i[r].down = !1)
    })), {
      update: function () {
        !function () {
          var e = r.a.viewport.size;
          ft[0] === e[0] && ft[1] === e[1] || (t.width = e[0], t.height = e[1], at());
          ft = e.slice(0)
        }(), function () {
          o.length > 0 && function (e) {
            for (var n = 0; n < e; n++) {
              var r = pt();
              r.r *= 10, r.g *= 10, r.b *= 10, dt(t.width * Math.random(), t.height * Math.random(), 1e3 * (Math.random() - .5), 1e3 * (Math.random() - .5), r)
            }
          }(o.pop());
          for (var n = 0; n < i.length; n++) {
            var r = i[n];
            r.moved && (dt(r.x, r.y, r.dx, r.dy, r.color), r.moved = !1)
          }
          if (!e.COLORFUL) return;
          if (ht + 100 < Date.now()) {
            ht = Date.now();
            for (var s = 0; s < i.length; s++) {
              i[s].color = pt()
            }
          }
        }(), function (t) {
          c.disable(c.BLEND), c.viewport(0, 0, d, p), rt.bind(), c.uniform2f(rt.uniforms.texelSize, 1 / d, 1 / p), c.uniform1i(rt.uniforms.uVelocity, y.read.attach(0)), U(b.fbo), it.bind(), c.uniform2f(it.uniforms.texelSize, 1 / d, 1 / p), c.uniform1i(it.uniforms.uVelocity, y.read.attach(0)), c.uniform1i(it.uniforms.uCurl, b.attach(1)), c.uniform1f(it.uniforms.curl, e.CURL), c.uniform1f(it.uniforms.dt, t), U(y.write.fbo), y.swap(), nt.bind(), c.uniform2f(nt.uniforms.texelSize, 1 / d, 1 / p), c.uniform1i(nt.uniforms.uVelocity, y.read.attach(0)), U(_.fbo), V.bind(), c.uniform1i(V.uniforms.uTexture, x.read.attach(0)), c.uniform1f(V.uniforms.value, e.PRESSURE_DISSIPATION), U(x.write.fbo), x.swap(), ot.bind(), c.uniform2f(ot.uniforms.texelSize, 1 / d, 1 / p), c.uniform1i(ot.uniforms.uDivergence, _.attach(0));
          for (var n = 0; n < e.PRESSURE_ITERATIONS; n++) c.uniform1i(ot.uniforms.uPressure, x.read.attach(1)), U(x.write.fbo), x.swap();
          st.bind(), c.uniform2f(st.uniforms.texelSize, 1 / d, 1 / p), c.uniform1i(st.uniforms.uPressure, x.read.attach(0)), c.uniform1i(st.uniforms.uVelocity, y.read.attach(1)), U(y.write.fbo), y.swap(), et.bind(), c.uniform2f(et.uniforms.texelSize, 1 / d, 1 / p), l.supportLinearFiltering || c.uniform2f(et.uniforms.dyeTexelSize, 1 / d, 1 / p);
          var r = y.read.attach(0);
          c.uniform1i(et.uniforms.uVelocity, r), c.uniform1i(et.uniforms.uSource, r), c.uniform1f(et.uniforms.dt, t), c.uniform1f(et.uniforms.dissipation, e.VELOCITY_DISSIPATION), U(y.write.fbo), y.swap(), c.viewport(0, 0, m, v), l.supportLinearFiltering || c.uniform2f(et.uniforms.dyeTexelSize, 1 / m, 1 / v);
          c.uniform1i(et.uniforms.uVelocity, y.read.attach(0)), c.uniform1i(et.uniforms.uSource, g.read.attach(1)), c.uniform1f(et.uniforms.dissipation, e.DENSITY_DISSIPATION), U(g.write.fbo), g.swap()
        }(.016), function (n) {
          e.BLOOM && function (t, n) {
            if (s.length < 2) return;
            var r = n;
            c.disable(c.BLEND), K.bind();
            var i = e.BLOOM_THRESHOLD * e.BLOOM_SOFT_KNEE + 1e-4, o = e.BLOOM_THRESHOLD - i, a = 2 * i, l = .25 / i;
            c.uniform3f(K.uniforms.curve, o, a, l), c.uniform1f(K.uniforms.threshold, e.BLOOM_THRESHOLD), c.uniform1i(K.uniforms.uTexture, t.attach(0)), c.viewport(0, 0, r.width, r.height), U(r.fbo), Q.bind();
            for (var u = 0; u < s.length; u++) {
              var h = s[u];
              c.uniform2f(Q.uniforms.texelSize, 1 / r.width, 1 / r.height), c.uniform1i(Q.uniforms.uTexture, r.attach(0)), c.viewport(0, 0, h.width, h.height), U(h.fbo), r = h
            }
            c.blendFunc(c.ONE, c.ONE), c.enable(c.BLEND);
            for (var f = s.length - 2; f >= 0; f--) {
              var d = s[f];
              c.uniform2f(Q.uniforms.texelSize, 1 / r.width, 1 / r.height), c.uniform1i(Q.uniforms.uTexture, r.attach(0)), c.viewport(0, 0, d.width, d.height), U(d.fbo), r = d
            }
            c.disable(c.BLEND), $.bind(), c.uniform2f($.uniforms.texelSize, 1 / r.width, 1 / r.height), c.uniform1i($.uniforms.uTexture, r.attach(0)), c.uniform1f($.uniforms.intensity, e.BLOOM_INTENSITY), c.viewport(0, 0, n.width, n.height), U(n.fbo)
          }(g.read, w);
          null != n && e.TRANSPARENT ? c.disable(c.BLEND) : (c.blendFunc(c.ONE, c.ONE_MINUS_SRC_ALPHA), c.enable(c.BLEND));
          var r = null == n ? c.drawingBufferWidth : m, i = null == n ? c.drawingBufferHeight : v;
          if (c.viewport(0, 0, r, i), !e.TRANSPARENT) {
            W.bind();
            var o = e.BACK_COLOR;
            c.uniform4f(W.uniforms.color, o.r / 255, o.g / 255, o.b / 255, 1), U(n)
          }
          null == n && e.TRANSPARENT && (X.bind(), c.uniform1f(X.uniforms.aspectRatio, t.width / t.height), U(null));
          if (e.SHADING) {
            var a = e.BLOOM ? J : Z;
            if (a.bind(), c.uniform2f(a.uniforms.texelSize, 1 / r, 1 / i), c.uniform1i(a.uniforms.uTexture, g.read.attach(0)), e.BLOOM) {
              c.uniform1i(a.uniforms.uBloom, w.attach(1)), c.uniform1i(a.uniforms.uDithering, G.attach(2));
              var l = vt(G, r, i);
              c.uniform2f(a.uniforms.ditherScale, l.x, l.y)
            }
          } else {
            var u = e.BLOOM ? Y : q;
            if (u.bind(), c.uniform1i(u.uniforms.uTexture, g.read.attach(0)), e.BLOOM) {
              c.uniform1i(u.uniforms.uBloom, w.attach(1)), c.uniform1i(u.uniforms.uDithering, G.attach(2));
              var h = vt(G, r, i);
              c.uniform2f(u.uniforms.ditherScale, h.x, h.y)
            }
          }
          U(n)
        }(null)
      }.bind(this), splat: function () {
        o.push(parseInt(20 * Math.random(), 10) + 5)
      }
    }
  }

  function _r(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
  }

  function br(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
  }

  function xr(t, e) {
    return xr = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t
    }, xr(t, e)
  }

  function wr(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {
        }))), !0
      } catch (t) {
        return !1
      }
    }();
    return function () {
      var n, r = Mr(t);
      if (e) {
        var i = Mr(this).constructor;
        n = Reflect.construct(r, arguments, i)
      } else n = r.apply(this, arguments);
      return Sr(this, n)
    }
  }

  function Sr(t, e) {
    if (e && ("object" === Er(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }(t)
  }

  function Mr(t) {
    return Mr = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t)
    }, Mr(t)
  }

  function Er(t) {
    return Er = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Er(t)
  }

  var Tr = function (t, e, n, r) {
      var i, o = arguments.length, s = o < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
      if ("object" === ("undefined" == typeof Reflect ? "undefined" : Er(Reflect)) && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--) (i = t[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(e, n, s) : i(e, n)) || s);
      return o > 3 && s && Object.defineProperty(e, n, s), s
    }, Or = "splash-bg", Hr = function (t) {
      !function (t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
        t.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: t,
            writable: !0,
            configurable: !0
          }
        }), e && xr(t, e)
      }(s, t);
      var e, n, i, o = wr(s);

      function s() {
        var t;
        return _r(this, s), (t = o.apply(this, arguments))._bg = !1, t._canvas = !1, t._appearTimeline = !1, t._contextLost = !1, t._threeRenderEvent = !1, t
      }

      return e = s, n = [{
        key: "bg", get: function () {
          return this._bg
        }
      }, {
        key: "createRenderRoot", value: function () {
          return this
        }
      }, {
        key: "firstUpdated", value: function () {
          var t = this;
          this.classList.add(Or), r.a.load.loaded ? this._createBgOnPageShown() : r.a.load.on("", (function () {
            t._createBgOnPageShown()
          }))
        }
      }, {
        key: "_createBgOnPageShown", value: function () {

          var t = this, e = r.a.vevetPage;
          e && e.onPageShown((function () {
            t._createBg()
          }), {timeout: 500})
        }
      }, {
        key: "_createBg", value: function () {
          var t = this, e = Object(h.b)("canvas", {parent: this});
          this._canvas = e, e.addEventListener("webglcontextlost", (function () {
            t._contextLost = !0, t._toggleRendering(!1)
          }), !1), this._bg = yr(e), setTimeout((function () {
            t._setEvents()
          }), 500)
        }
      }, {
        key: "_setEvents", value: function () {
          var t = this;
          if (this._bg) {
            var e = new vr.a;
            t.style.opacity = 1
            this._appearTimeline = e, e.on("progress", (function (e) {
              // t.style.opacity = "".concat(e.p)
            })), Ft.subscribe((function () {
              t._toggleShow(Ft.getState().value.enabled)
            })), this._toggleShow(Ft.getState().value.enabled)
          }
        }
      }, {
        key: "_toggleRendering", value: function (t) {
          var e = this;
          if (t) {
            if (this._contextLost) return;
            this._threeRenderEvent || (this._threeRenderEvent = pe.a.on("prerender", (function () {
              e._bg && e._bg.update()
            })))
          } else this._threeRenderEvent && (pe.a.remove(this._threeRenderEvent), this._threeRenderEvent = !1)
        }
      }, {
        key: "_toggleShow", value: function (t) {
          var e = this._appearTimeline;
          e && (e.pause(), t || e.reversed ? t && e.reversed && e.reverse() : e.reverse(), e.play({duration: 500}), this._toggleRendering(t))
        }
      }, {
        key: "showElement", value: function () {
          var t = this, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 350,
            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function () {
            }, r = new vr.a;
          r.on("progress", (function (e) {
            t._canvas && (t._canvas.style.opacity = "".concat(e.p))
          })), r.on("end", (function () {
            n()
          })), r.play({duration: e})
        }
      }, {
        key: "hideElement", value: function () {
          var t = this, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 350,
            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function () {
            }, r = new vr.a;
          r.on("progress", (function (e) {
            t._canvas && (t._canvas.style.opacity = "".concat(1 - e.p))
          })), r.on("end", (function () {
            n()
          })), r.play({duration: e})
        }
      }], n && br(e.prototype, n), i && br(e, i), s
    }(m.a), Ar = (Hr = Tr([Object(m.b)(Or)], Hr), n(51)), Pr = "like-button-pushed", Rr = "yes",
    Lr = localStorage.getItem(Pr) === Rr, Cr = Bt((function () {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
        value: {
          active: Lr,
          count: ''//window.LIKE.count
        }
      }, e = arguments.length > 1 ? arguments[1] : void 0;
      return "iterate" === e.type ? (t.value.count++, t.value.active = !0, localStorage.setItem(Pr, Rr), Ut(), t) : t
    }));



}, function (t, e, n) {
  "use strict";
  n.r(e), n.d(e, "default", (function () {
    return _
  }));
  function _(t) {
    return ''
  }
}]);